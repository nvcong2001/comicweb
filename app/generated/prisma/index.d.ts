
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model Categories
 * 
 */
export type Categories = $Result.DefaultSelection<Prisma.$CategoriesPayload>
/**
 * Model Authors
 * 
 */
export type Authors = $Result.DefaultSelection<Prisma.$AuthorsPayload>
/**
 * Model Comics
 * 
 */
export type Comics = $Result.DefaultSelection<Prisma.$ComicsPayload>
/**
 * Model Volumes
 * 
 */
export type Volumes = $Result.DefaultSelection<Prisma.$VolumesPayload>
/**
 * Model Chapters
 * 
 */
export type Chapters = $Result.DefaultSelection<Prisma.$ChaptersPayload>
/**
 * Model Roles
 * 
 */
export type Roles = $Result.DefaultSelection<Prisma.$RolesPayload>
/**
 * Model Users
 * 
 */
export type Users = $Result.DefaultSelection<Prisma.$UsersPayload>
/**
 * Model Favorites
 * 
 */
export type Favorites = $Result.DefaultSelection<Prisma.$FavoritesPayload>
/**
 * Model Rates
 * 
 */
export type Rates = $Result.DefaultSelection<Prisma.$RatesPayload>
/**
 * Model Errors
 * 
 */
export type Errors = $Result.DefaultSelection<Prisma.$ErrorsPayload>
/**
 * Model Views
 * 
 */
export type Views = $Result.DefaultSelection<Prisma.$ViewsPayload>
/**
 * Model Comments
 * 
 */
export type Comments = $Result.DefaultSelection<Prisma.$CommentsPayload>
/**
 * Model Notifications
 * 
 */
export type Notifications = $Result.DefaultSelection<Prisma.$NotificationsPayload>
/**
 * Model Wallets
 * 
 */
export type Wallets = $Result.DefaultSelection<Prisma.$WalletsPayload>
/**
 * Model Transactions
 * 
 */
export type Transactions = $Result.DefaultSelection<Prisma.$TransactionsPayload>
/**
 * Model Unlock_comic
 * 
 */
export type Unlock_comic = $Result.DefaultSelection<Prisma.$Unlock_comicPayload>
/**
 * Model Unlock_volume
 * 
 */
export type Unlock_volume = $Result.DefaultSelection<Prisma.$Unlock_volumePayload>
/**
 * Model Unlock_chapter
 * 
 */
export type Unlock_chapter = $Result.DefaultSelection<Prisma.$Unlock_chapterPayload>

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Categories
 * const categories = await prisma.categories.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Categories
   * const categories = await prisma.categories.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.categories`: Exposes CRUD operations for the **Categories** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Categories
    * const categories = await prisma.categories.findMany()
    * ```
    */
  get categories(): Prisma.CategoriesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.authors`: Exposes CRUD operations for the **Authors** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Authors
    * const authors = await prisma.authors.findMany()
    * ```
    */
  get authors(): Prisma.AuthorsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.comics`: Exposes CRUD operations for the **Comics** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Comics
    * const comics = await prisma.comics.findMany()
    * ```
    */
  get comics(): Prisma.ComicsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.volumes`: Exposes CRUD operations for the **Volumes** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Volumes
    * const volumes = await prisma.volumes.findMany()
    * ```
    */
  get volumes(): Prisma.VolumesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.chapters`: Exposes CRUD operations for the **Chapters** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Chapters
    * const chapters = await prisma.chapters.findMany()
    * ```
    */
  get chapters(): Prisma.ChaptersDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.roles`: Exposes CRUD operations for the **Roles** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Roles
    * const roles = await prisma.roles.findMany()
    * ```
    */
  get roles(): Prisma.RolesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.users`: Exposes CRUD operations for the **Users** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.users.findMany()
    * ```
    */
  get users(): Prisma.UsersDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.favorites`: Exposes CRUD operations for the **Favorites** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Favorites
    * const favorites = await prisma.favorites.findMany()
    * ```
    */
  get favorites(): Prisma.FavoritesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.rates`: Exposes CRUD operations for the **Rates** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Rates
    * const rates = await prisma.rates.findMany()
    * ```
    */
  get rates(): Prisma.RatesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.errors`: Exposes CRUD operations for the **Errors** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Errors
    * const errors = await prisma.errors.findMany()
    * ```
    */
  get errors(): Prisma.ErrorsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.views`: Exposes CRUD operations for the **Views** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Views
    * const views = await prisma.views.findMany()
    * ```
    */
  get views(): Prisma.ViewsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.comments`: Exposes CRUD operations for the **Comments** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Comments
    * const comments = await prisma.comments.findMany()
    * ```
    */
  get comments(): Prisma.CommentsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.notifications`: Exposes CRUD operations for the **Notifications** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Notifications
    * const notifications = await prisma.notifications.findMany()
    * ```
    */
  get notifications(): Prisma.NotificationsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.wallets`: Exposes CRUD operations for the **Wallets** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Wallets
    * const wallets = await prisma.wallets.findMany()
    * ```
    */
  get wallets(): Prisma.WalletsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.transactions`: Exposes CRUD operations for the **Transactions** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Transactions
    * const transactions = await prisma.transactions.findMany()
    * ```
    */
  get transactions(): Prisma.TransactionsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.unlock_comic`: Exposes CRUD operations for the **Unlock_comic** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Unlock_comics
    * const unlock_comics = await prisma.unlock_comic.findMany()
    * ```
    */
  get unlock_comic(): Prisma.Unlock_comicDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.unlock_volume`: Exposes CRUD operations for the **Unlock_volume** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Unlock_volumes
    * const unlock_volumes = await prisma.unlock_volume.findMany()
    * ```
    */
  get unlock_volume(): Prisma.Unlock_volumeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.unlock_chapter`: Exposes CRUD operations for the **Unlock_chapter** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Unlock_chapters
    * const unlock_chapters = await prisma.unlock_chapter.findMany()
    * ```
    */
  get unlock_chapter(): Prisma.Unlock_chapterDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.6.0
   * Query Engine version: f676762280b54cd07c770017ed3711ddde35f37a
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    Categories: 'Categories',
    Authors: 'Authors',
    Comics: 'Comics',
    Volumes: 'Volumes',
    Chapters: 'Chapters',
    Roles: 'Roles',
    Users: 'Users',
    Favorites: 'Favorites',
    Rates: 'Rates',
    Errors: 'Errors',
    Views: 'Views',
    Comments: 'Comments',
    Notifications: 'Notifications',
    Wallets: 'Wallets',
    Transactions: 'Transactions',
    Unlock_comic: 'Unlock_comic',
    Unlock_volume: 'Unlock_volume',
    Unlock_chapter: 'Unlock_chapter'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "categories" | "authors" | "comics" | "volumes" | "chapters" | "roles" | "users" | "favorites" | "rates" | "errors" | "views" | "comments" | "notifications" | "wallets" | "transactions" | "unlock_comic" | "unlock_volume" | "unlock_chapter"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      Categories: {
        payload: Prisma.$CategoriesPayload<ExtArgs>
        fields: Prisma.CategoriesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CategoriesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoriesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CategoriesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoriesPayload>
          }
          findFirst: {
            args: Prisma.CategoriesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoriesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CategoriesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoriesPayload>
          }
          findMany: {
            args: Prisma.CategoriesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoriesPayload>[]
          }
          create: {
            args: Prisma.CategoriesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoriesPayload>
          }
          createMany: {
            args: Prisma.CategoriesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.CategoriesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoriesPayload>
          }
          update: {
            args: Prisma.CategoriesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoriesPayload>
          }
          deleteMany: {
            args: Prisma.CategoriesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CategoriesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CategoriesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoriesPayload>
          }
          aggregate: {
            args: Prisma.CategoriesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCategories>
          }
          groupBy: {
            args: Prisma.CategoriesGroupByArgs<ExtArgs>
            result: $Utils.Optional<CategoriesGroupByOutputType>[]
          }
          count: {
            args: Prisma.CategoriesCountArgs<ExtArgs>
            result: $Utils.Optional<CategoriesCountAggregateOutputType> | number
          }
        }
      }
      Authors: {
        payload: Prisma.$AuthorsPayload<ExtArgs>
        fields: Prisma.AuthorsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AuthorsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuthorsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AuthorsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuthorsPayload>
          }
          findFirst: {
            args: Prisma.AuthorsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuthorsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AuthorsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuthorsPayload>
          }
          findMany: {
            args: Prisma.AuthorsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuthorsPayload>[]
          }
          create: {
            args: Prisma.AuthorsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuthorsPayload>
          }
          createMany: {
            args: Prisma.AuthorsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.AuthorsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuthorsPayload>
          }
          update: {
            args: Prisma.AuthorsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuthorsPayload>
          }
          deleteMany: {
            args: Prisma.AuthorsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AuthorsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AuthorsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuthorsPayload>
          }
          aggregate: {
            args: Prisma.AuthorsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAuthors>
          }
          groupBy: {
            args: Prisma.AuthorsGroupByArgs<ExtArgs>
            result: $Utils.Optional<AuthorsGroupByOutputType>[]
          }
          count: {
            args: Prisma.AuthorsCountArgs<ExtArgs>
            result: $Utils.Optional<AuthorsCountAggregateOutputType> | number
          }
        }
      }
      Comics: {
        payload: Prisma.$ComicsPayload<ExtArgs>
        fields: Prisma.ComicsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ComicsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComicsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ComicsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComicsPayload>
          }
          findFirst: {
            args: Prisma.ComicsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComicsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ComicsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComicsPayload>
          }
          findMany: {
            args: Prisma.ComicsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComicsPayload>[]
          }
          create: {
            args: Prisma.ComicsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComicsPayload>
          }
          createMany: {
            args: Prisma.ComicsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ComicsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComicsPayload>
          }
          update: {
            args: Prisma.ComicsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComicsPayload>
          }
          deleteMany: {
            args: Prisma.ComicsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ComicsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ComicsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComicsPayload>
          }
          aggregate: {
            args: Prisma.ComicsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateComics>
          }
          groupBy: {
            args: Prisma.ComicsGroupByArgs<ExtArgs>
            result: $Utils.Optional<ComicsGroupByOutputType>[]
          }
          count: {
            args: Prisma.ComicsCountArgs<ExtArgs>
            result: $Utils.Optional<ComicsCountAggregateOutputType> | number
          }
        }
      }
      Volumes: {
        payload: Prisma.$VolumesPayload<ExtArgs>
        fields: Prisma.VolumesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.VolumesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VolumesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.VolumesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VolumesPayload>
          }
          findFirst: {
            args: Prisma.VolumesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VolumesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.VolumesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VolumesPayload>
          }
          findMany: {
            args: Prisma.VolumesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VolumesPayload>[]
          }
          create: {
            args: Prisma.VolumesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VolumesPayload>
          }
          createMany: {
            args: Prisma.VolumesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.VolumesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VolumesPayload>
          }
          update: {
            args: Prisma.VolumesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VolumesPayload>
          }
          deleteMany: {
            args: Prisma.VolumesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.VolumesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.VolumesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VolumesPayload>
          }
          aggregate: {
            args: Prisma.VolumesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateVolumes>
          }
          groupBy: {
            args: Prisma.VolumesGroupByArgs<ExtArgs>
            result: $Utils.Optional<VolumesGroupByOutputType>[]
          }
          count: {
            args: Prisma.VolumesCountArgs<ExtArgs>
            result: $Utils.Optional<VolumesCountAggregateOutputType> | number
          }
        }
      }
      Chapters: {
        payload: Prisma.$ChaptersPayload<ExtArgs>
        fields: Prisma.ChaptersFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ChaptersFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChaptersPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ChaptersFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChaptersPayload>
          }
          findFirst: {
            args: Prisma.ChaptersFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChaptersPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ChaptersFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChaptersPayload>
          }
          findMany: {
            args: Prisma.ChaptersFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChaptersPayload>[]
          }
          create: {
            args: Prisma.ChaptersCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChaptersPayload>
          }
          createMany: {
            args: Prisma.ChaptersCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ChaptersDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChaptersPayload>
          }
          update: {
            args: Prisma.ChaptersUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChaptersPayload>
          }
          deleteMany: {
            args: Prisma.ChaptersDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ChaptersUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ChaptersUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChaptersPayload>
          }
          aggregate: {
            args: Prisma.ChaptersAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateChapters>
          }
          groupBy: {
            args: Prisma.ChaptersGroupByArgs<ExtArgs>
            result: $Utils.Optional<ChaptersGroupByOutputType>[]
          }
          count: {
            args: Prisma.ChaptersCountArgs<ExtArgs>
            result: $Utils.Optional<ChaptersCountAggregateOutputType> | number
          }
        }
      }
      Roles: {
        payload: Prisma.$RolesPayload<ExtArgs>
        fields: Prisma.RolesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RolesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RolesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolesPayload>
          }
          findFirst: {
            args: Prisma.RolesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RolesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolesPayload>
          }
          findMany: {
            args: Prisma.RolesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolesPayload>[]
          }
          create: {
            args: Prisma.RolesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolesPayload>
          }
          createMany: {
            args: Prisma.RolesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.RolesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolesPayload>
          }
          update: {
            args: Prisma.RolesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolesPayload>
          }
          deleteMany: {
            args: Prisma.RolesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RolesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.RolesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolesPayload>
          }
          aggregate: {
            args: Prisma.RolesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRoles>
          }
          groupBy: {
            args: Prisma.RolesGroupByArgs<ExtArgs>
            result: $Utils.Optional<RolesGroupByOutputType>[]
          }
          count: {
            args: Prisma.RolesCountArgs<ExtArgs>
            result: $Utils.Optional<RolesCountAggregateOutputType> | number
          }
        }
      }
      Users: {
        payload: Prisma.$UsersPayload<ExtArgs>
        fields: Prisma.UsersFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UsersFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsersPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UsersFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsersPayload>
          }
          findFirst: {
            args: Prisma.UsersFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsersPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UsersFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsersPayload>
          }
          findMany: {
            args: Prisma.UsersFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsersPayload>[]
          }
          create: {
            args: Prisma.UsersCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsersPayload>
          }
          createMany: {
            args: Prisma.UsersCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.UsersDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsersPayload>
          }
          update: {
            args: Prisma.UsersUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsersPayload>
          }
          deleteMany: {
            args: Prisma.UsersDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UsersUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UsersUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsersPayload>
          }
          aggregate: {
            args: Prisma.UsersAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUsers>
          }
          groupBy: {
            args: Prisma.UsersGroupByArgs<ExtArgs>
            result: $Utils.Optional<UsersGroupByOutputType>[]
          }
          count: {
            args: Prisma.UsersCountArgs<ExtArgs>
            result: $Utils.Optional<UsersCountAggregateOutputType> | number
          }
        }
      }
      Favorites: {
        payload: Prisma.$FavoritesPayload<ExtArgs>
        fields: Prisma.FavoritesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FavoritesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FavoritesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FavoritesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FavoritesPayload>
          }
          findFirst: {
            args: Prisma.FavoritesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FavoritesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FavoritesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FavoritesPayload>
          }
          findMany: {
            args: Prisma.FavoritesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FavoritesPayload>[]
          }
          create: {
            args: Prisma.FavoritesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FavoritesPayload>
          }
          createMany: {
            args: Prisma.FavoritesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.FavoritesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FavoritesPayload>
          }
          update: {
            args: Prisma.FavoritesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FavoritesPayload>
          }
          deleteMany: {
            args: Prisma.FavoritesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FavoritesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.FavoritesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FavoritesPayload>
          }
          aggregate: {
            args: Prisma.FavoritesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFavorites>
          }
          groupBy: {
            args: Prisma.FavoritesGroupByArgs<ExtArgs>
            result: $Utils.Optional<FavoritesGroupByOutputType>[]
          }
          count: {
            args: Prisma.FavoritesCountArgs<ExtArgs>
            result: $Utils.Optional<FavoritesCountAggregateOutputType> | number
          }
        }
      }
      Rates: {
        payload: Prisma.$RatesPayload<ExtArgs>
        fields: Prisma.RatesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RatesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RatesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RatesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RatesPayload>
          }
          findFirst: {
            args: Prisma.RatesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RatesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RatesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RatesPayload>
          }
          findMany: {
            args: Prisma.RatesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RatesPayload>[]
          }
          create: {
            args: Prisma.RatesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RatesPayload>
          }
          createMany: {
            args: Prisma.RatesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.RatesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RatesPayload>
          }
          update: {
            args: Prisma.RatesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RatesPayload>
          }
          deleteMany: {
            args: Prisma.RatesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RatesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.RatesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RatesPayload>
          }
          aggregate: {
            args: Prisma.RatesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRates>
          }
          groupBy: {
            args: Prisma.RatesGroupByArgs<ExtArgs>
            result: $Utils.Optional<RatesGroupByOutputType>[]
          }
          count: {
            args: Prisma.RatesCountArgs<ExtArgs>
            result: $Utils.Optional<RatesCountAggregateOutputType> | number
          }
        }
      }
      Errors: {
        payload: Prisma.$ErrorsPayload<ExtArgs>
        fields: Prisma.ErrorsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ErrorsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ErrorsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ErrorsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ErrorsPayload>
          }
          findFirst: {
            args: Prisma.ErrorsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ErrorsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ErrorsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ErrorsPayload>
          }
          findMany: {
            args: Prisma.ErrorsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ErrorsPayload>[]
          }
          create: {
            args: Prisma.ErrorsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ErrorsPayload>
          }
          createMany: {
            args: Prisma.ErrorsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ErrorsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ErrorsPayload>
          }
          update: {
            args: Prisma.ErrorsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ErrorsPayload>
          }
          deleteMany: {
            args: Prisma.ErrorsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ErrorsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ErrorsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ErrorsPayload>
          }
          aggregate: {
            args: Prisma.ErrorsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateErrors>
          }
          groupBy: {
            args: Prisma.ErrorsGroupByArgs<ExtArgs>
            result: $Utils.Optional<ErrorsGroupByOutputType>[]
          }
          count: {
            args: Prisma.ErrorsCountArgs<ExtArgs>
            result: $Utils.Optional<ErrorsCountAggregateOutputType> | number
          }
        }
      }
      Views: {
        payload: Prisma.$ViewsPayload<ExtArgs>
        fields: Prisma.ViewsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ViewsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ViewsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ViewsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ViewsPayload>
          }
          findFirst: {
            args: Prisma.ViewsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ViewsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ViewsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ViewsPayload>
          }
          findMany: {
            args: Prisma.ViewsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ViewsPayload>[]
          }
          create: {
            args: Prisma.ViewsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ViewsPayload>
          }
          createMany: {
            args: Prisma.ViewsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ViewsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ViewsPayload>
          }
          update: {
            args: Prisma.ViewsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ViewsPayload>
          }
          deleteMany: {
            args: Prisma.ViewsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ViewsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ViewsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ViewsPayload>
          }
          aggregate: {
            args: Prisma.ViewsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateViews>
          }
          groupBy: {
            args: Prisma.ViewsGroupByArgs<ExtArgs>
            result: $Utils.Optional<ViewsGroupByOutputType>[]
          }
          count: {
            args: Prisma.ViewsCountArgs<ExtArgs>
            result: $Utils.Optional<ViewsCountAggregateOutputType> | number
          }
        }
      }
      Comments: {
        payload: Prisma.$CommentsPayload<ExtArgs>
        fields: Prisma.CommentsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CommentsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CommentsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentsPayload>
          }
          findFirst: {
            args: Prisma.CommentsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CommentsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentsPayload>
          }
          findMany: {
            args: Prisma.CommentsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentsPayload>[]
          }
          create: {
            args: Prisma.CommentsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentsPayload>
          }
          createMany: {
            args: Prisma.CommentsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.CommentsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentsPayload>
          }
          update: {
            args: Prisma.CommentsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentsPayload>
          }
          deleteMany: {
            args: Prisma.CommentsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CommentsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CommentsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentsPayload>
          }
          aggregate: {
            args: Prisma.CommentsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateComments>
          }
          groupBy: {
            args: Prisma.CommentsGroupByArgs<ExtArgs>
            result: $Utils.Optional<CommentsGroupByOutputType>[]
          }
          count: {
            args: Prisma.CommentsCountArgs<ExtArgs>
            result: $Utils.Optional<CommentsCountAggregateOutputType> | number
          }
        }
      }
      Notifications: {
        payload: Prisma.$NotificationsPayload<ExtArgs>
        fields: Prisma.NotificationsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.NotificationsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NotificationsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationsPayload>
          }
          findFirst: {
            args: Prisma.NotificationsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NotificationsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationsPayload>
          }
          findMany: {
            args: Prisma.NotificationsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationsPayload>[]
          }
          create: {
            args: Prisma.NotificationsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationsPayload>
          }
          createMany: {
            args: Prisma.NotificationsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.NotificationsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationsPayload>
          }
          update: {
            args: Prisma.NotificationsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationsPayload>
          }
          deleteMany: {
            args: Prisma.NotificationsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.NotificationsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.NotificationsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationsPayload>
          }
          aggregate: {
            args: Prisma.NotificationsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNotifications>
          }
          groupBy: {
            args: Prisma.NotificationsGroupByArgs<ExtArgs>
            result: $Utils.Optional<NotificationsGroupByOutputType>[]
          }
          count: {
            args: Prisma.NotificationsCountArgs<ExtArgs>
            result: $Utils.Optional<NotificationsCountAggregateOutputType> | number
          }
        }
      }
      Wallets: {
        payload: Prisma.$WalletsPayload<ExtArgs>
        fields: Prisma.WalletsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.WalletsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WalletsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.WalletsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WalletsPayload>
          }
          findFirst: {
            args: Prisma.WalletsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WalletsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.WalletsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WalletsPayload>
          }
          findMany: {
            args: Prisma.WalletsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WalletsPayload>[]
          }
          create: {
            args: Prisma.WalletsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WalletsPayload>
          }
          createMany: {
            args: Prisma.WalletsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.WalletsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WalletsPayload>
          }
          update: {
            args: Prisma.WalletsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WalletsPayload>
          }
          deleteMany: {
            args: Prisma.WalletsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.WalletsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.WalletsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WalletsPayload>
          }
          aggregate: {
            args: Prisma.WalletsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWallets>
          }
          groupBy: {
            args: Prisma.WalletsGroupByArgs<ExtArgs>
            result: $Utils.Optional<WalletsGroupByOutputType>[]
          }
          count: {
            args: Prisma.WalletsCountArgs<ExtArgs>
            result: $Utils.Optional<WalletsCountAggregateOutputType> | number
          }
        }
      }
      Transactions: {
        payload: Prisma.$TransactionsPayload<ExtArgs>
        fields: Prisma.TransactionsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TransactionsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TransactionsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionsPayload>
          }
          findFirst: {
            args: Prisma.TransactionsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TransactionsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionsPayload>
          }
          findMany: {
            args: Prisma.TransactionsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionsPayload>[]
          }
          create: {
            args: Prisma.TransactionsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionsPayload>
          }
          createMany: {
            args: Prisma.TransactionsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.TransactionsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionsPayload>
          }
          update: {
            args: Prisma.TransactionsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionsPayload>
          }
          deleteMany: {
            args: Prisma.TransactionsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TransactionsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TransactionsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionsPayload>
          }
          aggregate: {
            args: Prisma.TransactionsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTransactions>
          }
          groupBy: {
            args: Prisma.TransactionsGroupByArgs<ExtArgs>
            result: $Utils.Optional<TransactionsGroupByOutputType>[]
          }
          count: {
            args: Prisma.TransactionsCountArgs<ExtArgs>
            result: $Utils.Optional<TransactionsCountAggregateOutputType> | number
          }
        }
      }
      Unlock_comic: {
        payload: Prisma.$Unlock_comicPayload<ExtArgs>
        fields: Prisma.Unlock_comicFieldRefs
        operations: {
          findUnique: {
            args: Prisma.Unlock_comicFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Unlock_comicPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.Unlock_comicFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Unlock_comicPayload>
          }
          findFirst: {
            args: Prisma.Unlock_comicFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Unlock_comicPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.Unlock_comicFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Unlock_comicPayload>
          }
          findMany: {
            args: Prisma.Unlock_comicFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Unlock_comicPayload>[]
          }
          create: {
            args: Prisma.Unlock_comicCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Unlock_comicPayload>
          }
          createMany: {
            args: Prisma.Unlock_comicCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.Unlock_comicDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Unlock_comicPayload>
          }
          update: {
            args: Prisma.Unlock_comicUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Unlock_comicPayload>
          }
          deleteMany: {
            args: Prisma.Unlock_comicDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.Unlock_comicUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.Unlock_comicUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Unlock_comicPayload>
          }
          aggregate: {
            args: Prisma.Unlock_comicAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUnlock_comic>
          }
          groupBy: {
            args: Prisma.Unlock_comicGroupByArgs<ExtArgs>
            result: $Utils.Optional<Unlock_comicGroupByOutputType>[]
          }
          count: {
            args: Prisma.Unlock_comicCountArgs<ExtArgs>
            result: $Utils.Optional<Unlock_comicCountAggregateOutputType> | number
          }
        }
      }
      Unlock_volume: {
        payload: Prisma.$Unlock_volumePayload<ExtArgs>
        fields: Prisma.Unlock_volumeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.Unlock_volumeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Unlock_volumePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.Unlock_volumeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Unlock_volumePayload>
          }
          findFirst: {
            args: Prisma.Unlock_volumeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Unlock_volumePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.Unlock_volumeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Unlock_volumePayload>
          }
          findMany: {
            args: Prisma.Unlock_volumeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Unlock_volumePayload>[]
          }
          create: {
            args: Prisma.Unlock_volumeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Unlock_volumePayload>
          }
          createMany: {
            args: Prisma.Unlock_volumeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.Unlock_volumeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Unlock_volumePayload>
          }
          update: {
            args: Prisma.Unlock_volumeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Unlock_volumePayload>
          }
          deleteMany: {
            args: Prisma.Unlock_volumeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.Unlock_volumeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.Unlock_volumeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Unlock_volumePayload>
          }
          aggregate: {
            args: Prisma.Unlock_volumeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUnlock_volume>
          }
          groupBy: {
            args: Prisma.Unlock_volumeGroupByArgs<ExtArgs>
            result: $Utils.Optional<Unlock_volumeGroupByOutputType>[]
          }
          count: {
            args: Prisma.Unlock_volumeCountArgs<ExtArgs>
            result: $Utils.Optional<Unlock_volumeCountAggregateOutputType> | number
          }
        }
      }
      Unlock_chapter: {
        payload: Prisma.$Unlock_chapterPayload<ExtArgs>
        fields: Prisma.Unlock_chapterFieldRefs
        operations: {
          findUnique: {
            args: Prisma.Unlock_chapterFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Unlock_chapterPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.Unlock_chapterFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Unlock_chapterPayload>
          }
          findFirst: {
            args: Prisma.Unlock_chapterFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Unlock_chapterPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.Unlock_chapterFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Unlock_chapterPayload>
          }
          findMany: {
            args: Prisma.Unlock_chapterFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Unlock_chapterPayload>[]
          }
          create: {
            args: Prisma.Unlock_chapterCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Unlock_chapterPayload>
          }
          createMany: {
            args: Prisma.Unlock_chapterCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.Unlock_chapterDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Unlock_chapterPayload>
          }
          update: {
            args: Prisma.Unlock_chapterUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Unlock_chapterPayload>
          }
          deleteMany: {
            args: Prisma.Unlock_chapterDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.Unlock_chapterUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.Unlock_chapterUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Unlock_chapterPayload>
          }
          aggregate: {
            args: Prisma.Unlock_chapterAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUnlock_chapter>
          }
          groupBy: {
            args: Prisma.Unlock_chapterGroupByArgs<ExtArgs>
            result: $Utils.Optional<Unlock_chapterGroupByOutputType>[]
          }
          count: {
            args: Prisma.Unlock_chapterCountArgs<ExtArgs>
            result: $Utils.Optional<Unlock_chapterCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    categories?: CategoriesOmit
    authors?: AuthorsOmit
    comics?: ComicsOmit
    volumes?: VolumesOmit
    chapters?: ChaptersOmit
    roles?: RolesOmit
    users?: UsersOmit
    favorites?: FavoritesOmit
    rates?: RatesOmit
    errors?: ErrorsOmit
    views?: ViewsOmit
    comments?: CommentsOmit
    notifications?: NotificationsOmit
    wallets?: WalletsOmit
    transactions?: TransactionsOmit
    unlock_comic?: Unlock_comicOmit
    unlock_volume?: Unlock_volumeOmit
    unlock_chapter?: Unlock_chapterOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type CategoriesCountOutputType
   */

  export type CategoriesCountOutputType = {
    comics: number
  }

  export type CategoriesCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    comics?: boolean | CategoriesCountOutputTypeCountComicsArgs
  }

  // Custom InputTypes
  /**
   * CategoriesCountOutputType without action
   */
  export type CategoriesCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CategoriesCountOutputType
     */
    select?: CategoriesCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CategoriesCountOutputType without action
   */
  export type CategoriesCountOutputTypeCountComicsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ComicsWhereInput
  }


  /**
   * Count Type AuthorsCountOutputType
   */

  export type AuthorsCountOutputType = {
    comics: number
  }

  export type AuthorsCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    comics?: boolean | AuthorsCountOutputTypeCountComicsArgs
  }

  // Custom InputTypes
  /**
   * AuthorsCountOutputType without action
   */
  export type AuthorsCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuthorsCountOutputType
     */
    select?: AuthorsCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AuthorsCountOutputType without action
   */
  export type AuthorsCountOutputTypeCountComicsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ComicsWhereInput
  }


  /**
   * Count Type ComicsCountOutputType
   */

  export type ComicsCountOutputType = {
    categories: number
    authors: number
    volumes: number
    favorites: number
    rates: number
    views: number
    comment: number
    unlock_comic: number
  }

  export type ComicsCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    categories?: boolean | ComicsCountOutputTypeCountCategoriesArgs
    authors?: boolean | ComicsCountOutputTypeCountAuthorsArgs
    volumes?: boolean | ComicsCountOutputTypeCountVolumesArgs
    favorites?: boolean | ComicsCountOutputTypeCountFavoritesArgs
    rates?: boolean | ComicsCountOutputTypeCountRatesArgs
    views?: boolean | ComicsCountOutputTypeCountViewsArgs
    comment?: boolean | ComicsCountOutputTypeCountCommentArgs
    unlock_comic?: boolean | ComicsCountOutputTypeCountUnlock_comicArgs
  }

  // Custom InputTypes
  /**
   * ComicsCountOutputType without action
   */
  export type ComicsCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ComicsCountOutputType
     */
    select?: ComicsCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ComicsCountOutputType without action
   */
  export type ComicsCountOutputTypeCountCategoriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CategoriesWhereInput
  }

  /**
   * ComicsCountOutputType without action
   */
  export type ComicsCountOutputTypeCountAuthorsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AuthorsWhereInput
  }

  /**
   * ComicsCountOutputType without action
   */
  export type ComicsCountOutputTypeCountVolumesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VolumesWhereInput
  }

  /**
   * ComicsCountOutputType without action
   */
  export type ComicsCountOutputTypeCountFavoritesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FavoritesWhereInput
  }

  /**
   * ComicsCountOutputType without action
   */
  export type ComicsCountOutputTypeCountRatesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RatesWhereInput
  }

  /**
   * ComicsCountOutputType without action
   */
  export type ComicsCountOutputTypeCountViewsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ViewsWhereInput
  }

  /**
   * ComicsCountOutputType without action
   */
  export type ComicsCountOutputTypeCountCommentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CommentsWhereInput
  }

  /**
   * ComicsCountOutputType without action
   */
  export type ComicsCountOutputTypeCountUnlock_comicArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: Unlock_comicWhereInput
  }


  /**
   * Count Type VolumesCountOutputType
   */

  export type VolumesCountOutputType = {
    chapters: number
    unlock_volume: number
  }

  export type VolumesCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    chapters?: boolean | VolumesCountOutputTypeCountChaptersArgs
    unlock_volume?: boolean | VolumesCountOutputTypeCountUnlock_volumeArgs
  }

  // Custom InputTypes
  /**
   * VolumesCountOutputType without action
   */
  export type VolumesCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VolumesCountOutputType
     */
    select?: VolumesCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * VolumesCountOutputType without action
   */
  export type VolumesCountOutputTypeCountChaptersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChaptersWhereInput
  }

  /**
   * VolumesCountOutputType without action
   */
  export type VolumesCountOutputTypeCountUnlock_volumeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: Unlock_volumeWhereInput
  }


  /**
   * Count Type ChaptersCountOutputType
   */

  export type ChaptersCountOutputType = {
    errors: number
    views: number
    coments: number
    unlock_chapter: number
  }

  export type ChaptersCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    errors?: boolean | ChaptersCountOutputTypeCountErrorsArgs
    views?: boolean | ChaptersCountOutputTypeCountViewsArgs
    coments?: boolean | ChaptersCountOutputTypeCountComentsArgs
    unlock_chapter?: boolean | ChaptersCountOutputTypeCountUnlock_chapterArgs
  }

  // Custom InputTypes
  /**
   * ChaptersCountOutputType without action
   */
  export type ChaptersCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChaptersCountOutputType
     */
    select?: ChaptersCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ChaptersCountOutputType without action
   */
  export type ChaptersCountOutputTypeCountErrorsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ErrorsWhereInput
  }

  /**
   * ChaptersCountOutputType without action
   */
  export type ChaptersCountOutputTypeCountViewsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ViewsWhereInput
  }

  /**
   * ChaptersCountOutputType without action
   */
  export type ChaptersCountOutputTypeCountComentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CommentsWhereInput
  }

  /**
   * ChaptersCountOutputType without action
   */
  export type ChaptersCountOutputTypeCountUnlock_chapterArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: Unlock_chapterWhereInput
  }


  /**
   * Count Type RolesCountOutputType
   */

  export type RolesCountOutputType = {
    users: number
  }

  export type RolesCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | RolesCountOutputTypeCountUsersArgs
  }

  // Custom InputTypes
  /**
   * RolesCountOutputType without action
   */
  export type RolesCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolesCountOutputType
     */
    select?: RolesCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * RolesCountOutputType without action
   */
  export type RolesCountOutputTypeCountUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UsersWhereInput
  }


  /**
   * Count Type UsersCountOutputType
   */

  export type UsersCountOutputType = {
    comics: number
    userRole: number
    favorites: number
    rates: number
    errors: number
    views: number
    coments: number
    notifications: number
    unlock_comic: number
    unlock_volume: number
    unlock_chapter: number
  }

  export type UsersCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    comics?: boolean | UsersCountOutputTypeCountComicsArgs
    userRole?: boolean | UsersCountOutputTypeCountUserRoleArgs
    favorites?: boolean | UsersCountOutputTypeCountFavoritesArgs
    rates?: boolean | UsersCountOutputTypeCountRatesArgs
    errors?: boolean | UsersCountOutputTypeCountErrorsArgs
    views?: boolean | UsersCountOutputTypeCountViewsArgs
    coments?: boolean | UsersCountOutputTypeCountComentsArgs
    notifications?: boolean | UsersCountOutputTypeCountNotificationsArgs
    unlock_comic?: boolean | UsersCountOutputTypeCountUnlock_comicArgs
    unlock_volume?: boolean | UsersCountOutputTypeCountUnlock_volumeArgs
    unlock_chapter?: boolean | UsersCountOutputTypeCountUnlock_chapterArgs
  }

  // Custom InputTypes
  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsersCountOutputType
     */
    select?: UsersCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountComicsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ComicsWhereInput
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountUserRoleArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RolesWhereInput
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountFavoritesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FavoritesWhereInput
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountRatesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RatesWhereInput
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountErrorsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ErrorsWhereInput
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountViewsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ViewsWhereInput
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountComentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CommentsWhereInput
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountNotificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationsWhereInput
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountUnlock_comicArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: Unlock_comicWhereInput
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountUnlock_volumeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: Unlock_volumeWhereInput
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountUnlock_chapterArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: Unlock_chapterWhereInput
  }


  /**
   * Count Type CommentsCountOutputType
   */

  export type CommentsCountOutputType = {
    notification: number
  }

  export type CommentsCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    notification?: boolean | CommentsCountOutputTypeCountNotificationArgs
  }

  // Custom InputTypes
  /**
   * CommentsCountOutputType without action
   */
  export type CommentsCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommentsCountOutputType
     */
    select?: CommentsCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CommentsCountOutputType without action
   */
  export type CommentsCountOutputTypeCountNotificationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationsWhereInput
  }


  /**
   * Count Type WalletsCountOutputType
   */

  export type WalletsCountOutputType = {
    transactions: number
  }

  export type WalletsCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    transactions?: boolean | WalletsCountOutputTypeCountTransactionsArgs
  }

  // Custom InputTypes
  /**
   * WalletsCountOutputType without action
   */
  export type WalletsCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WalletsCountOutputType
     */
    select?: WalletsCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * WalletsCountOutputType without action
   */
  export type WalletsCountOutputTypeCountTransactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TransactionsWhereInput
  }


  /**
   * Count Type TransactionsCountOutputType
   */

  export type TransactionsCountOutputType = {
    unlock_comic: number
    unlock_volume: number
    unlock_chapter: number
  }

  export type TransactionsCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    unlock_comic?: boolean | TransactionsCountOutputTypeCountUnlock_comicArgs
    unlock_volume?: boolean | TransactionsCountOutputTypeCountUnlock_volumeArgs
    unlock_chapter?: boolean | TransactionsCountOutputTypeCountUnlock_chapterArgs
  }

  // Custom InputTypes
  /**
   * TransactionsCountOutputType without action
   */
  export type TransactionsCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransactionsCountOutputType
     */
    select?: TransactionsCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TransactionsCountOutputType without action
   */
  export type TransactionsCountOutputTypeCountUnlock_comicArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: Unlock_comicWhereInput
  }

  /**
   * TransactionsCountOutputType without action
   */
  export type TransactionsCountOutputTypeCountUnlock_volumeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: Unlock_volumeWhereInput
  }

  /**
   * TransactionsCountOutputType without action
   */
  export type TransactionsCountOutputTypeCountUnlock_chapterArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: Unlock_chapterWhereInput
  }


  /**
   * Models
   */

  /**
   * Model Categories
   */

  export type AggregateCategories = {
    _count: CategoriesCountAggregateOutputType | null
    _avg: CategoriesAvgAggregateOutputType | null
    _sum: CategoriesSumAggregateOutputType | null
    _min: CategoriesMinAggregateOutputType | null
    _max: CategoriesMaxAggregateOutputType | null
  }

  export type CategoriesAvgAggregateOutputType = {
    id: number | null
  }

  export type CategoriesSumAggregateOutputType = {
    id: number | null
  }

  export type CategoriesMinAggregateOutputType = {
    id: number | null
    title: string | null
  }

  export type CategoriesMaxAggregateOutputType = {
    id: number | null
    title: string | null
  }

  export type CategoriesCountAggregateOutputType = {
    id: number
    title: number
    _all: number
  }


  export type CategoriesAvgAggregateInputType = {
    id?: true
  }

  export type CategoriesSumAggregateInputType = {
    id?: true
  }

  export type CategoriesMinAggregateInputType = {
    id?: true
    title?: true
  }

  export type CategoriesMaxAggregateInputType = {
    id?: true
    title?: true
  }

  export type CategoriesCountAggregateInputType = {
    id?: true
    title?: true
    _all?: true
  }

  export type CategoriesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Categories to aggregate.
     */
    where?: CategoriesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Categories to fetch.
     */
    orderBy?: CategoriesOrderByWithRelationInput | CategoriesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CategoriesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Categories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Categories
    **/
    _count?: true | CategoriesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CategoriesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CategoriesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CategoriesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CategoriesMaxAggregateInputType
  }

  export type GetCategoriesAggregateType<T extends CategoriesAggregateArgs> = {
        [P in keyof T & keyof AggregateCategories]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCategories[P]>
      : GetScalarType<T[P], AggregateCategories[P]>
  }




  export type CategoriesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CategoriesWhereInput
    orderBy?: CategoriesOrderByWithAggregationInput | CategoriesOrderByWithAggregationInput[]
    by: CategoriesScalarFieldEnum[] | CategoriesScalarFieldEnum
    having?: CategoriesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CategoriesCountAggregateInputType | true
    _avg?: CategoriesAvgAggregateInputType
    _sum?: CategoriesSumAggregateInputType
    _min?: CategoriesMinAggregateInputType
    _max?: CategoriesMaxAggregateInputType
  }

  export type CategoriesGroupByOutputType = {
    id: number
    title: string
    _count: CategoriesCountAggregateOutputType | null
    _avg: CategoriesAvgAggregateOutputType | null
    _sum: CategoriesSumAggregateOutputType | null
    _min: CategoriesMinAggregateOutputType | null
    _max: CategoriesMaxAggregateOutputType | null
  }

  type GetCategoriesGroupByPayload<T extends CategoriesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CategoriesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CategoriesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CategoriesGroupByOutputType[P]>
            : GetScalarType<T[P], CategoriesGroupByOutputType[P]>
        }
      >
    >


  export type CategoriesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    comics?: boolean | Categories$comicsArgs<ExtArgs>
    _count?: boolean | CategoriesCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["categories"]>



  export type CategoriesSelectScalar = {
    id?: boolean
    title?: boolean
  }

  export type CategoriesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "title", ExtArgs["result"]["categories"]>
  export type CategoriesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    comics?: boolean | Categories$comicsArgs<ExtArgs>
    _count?: boolean | CategoriesCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $CategoriesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Categories"
    objects: {
      comics: Prisma.$ComicsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      title: string
    }, ExtArgs["result"]["categories"]>
    composites: {}
  }

  type CategoriesGetPayload<S extends boolean | null | undefined | CategoriesDefaultArgs> = $Result.GetResult<Prisma.$CategoriesPayload, S>

  type CategoriesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CategoriesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CategoriesCountAggregateInputType | true
    }

  export interface CategoriesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Categories'], meta: { name: 'Categories' } }
    /**
     * Find zero or one Categories that matches the filter.
     * @param {CategoriesFindUniqueArgs} args - Arguments to find a Categories
     * @example
     * // Get one Categories
     * const categories = await prisma.categories.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CategoriesFindUniqueArgs>(args: SelectSubset<T, CategoriesFindUniqueArgs<ExtArgs>>): Prisma__CategoriesClient<$Result.GetResult<Prisma.$CategoriesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Categories that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CategoriesFindUniqueOrThrowArgs} args - Arguments to find a Categories
     * @example
     * // Get one Categories
     * const categories = await prisma.categories.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CategoriesFindUniqueOrThrowArgs>(args: SelectSubset<T, CategoriesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CategoriesClient<$Result.GetResult<Prisma.$CategoriesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Categories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoriesFindFirstArgs} args - Arguments to find a Categories
     * @example
     * // Get one Categories
     * const categories = await prisma.categories.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CategoriesFindFirstArgs>(args?: SelectSubset<T, CategoriesFindFirstArgs<ExtArgs>>): Prisma__CategoriesClient<$Result.GetResult<Prisma.$CategoriesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Categories that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoriesFindFirstOrThrowArgs} args - Arguments to find a Categories
     * @example
     * // Get one Categories
     * const categories = await prisma.categories.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CategoriesFindFirstOrThrowArgs>(args?: SelectSubset<T, CategoriesFindFirstOrThrowArgs<ExtArgs>>): Prisma__CategoriesClient<$Result.GetResult<Prisma.$CategoriesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Categories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoriesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Categories
     * const categories = await prisma.categories.findMany()
     * 
     * // Get first 10 Categories
     * const categories = await prisma.categories.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const categoriesWithIdOnly = await prisma.categories.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CategoriesFindManyArgs>(args?: SelectSubset<T, CategoriesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CategoriesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Categories.
     * @param {CategoriesCreateArgs} args - Arguments to create a Categories.
     * @example
     * // Create one Categories
     * const Categories = await prisma.categories.create({
     *   data: {
     *     // ... data to create a Categories
     *   }
     * })
     * 
     */
    create<T extends CategoriesCreateArgs>(args: SelectSubset<T, CategoriesCreateArgs<ExtArgs>>): Prisma__CategoriesClient<$Result.GetResult<Prisma.$CategoriesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Categories.
     * @param {CategoriesCreateManyArgs} args - Arguments to create many Categories.
     * @example
     * // Create many Categories
     * const categories = await prisma.categories.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CategoriesCreateManyArgs>(args?: SelectSubset<T, CategoriesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Categories.
     * @param {CategoriesDeleteArgs} args - Arguments to delete one Categories.
     * @example
     * // Delete one Categories
     * const Categories = await prisma.categories.delete({
     *   where: {
     *     // ... filter to delete one Categories
     *   }
     * })
     * 
     */
    delete<T extends CategoriesDeleteArgs>(args: SelectSubset<T, CategoriesDeleteArgs<ExtArgs>>): Prisma__CategoriesClient<$Result.GetResult<Prisma.$CategoriesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Categories.
     * @param {CategoriesUpdateArgs} args - Arguments to update one Categories.
     * @example
     * // Update one Categories
     * const categories = await prisma.categories.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CategoriesUpdateArgs>(args: SelectSubset<T, CategoriesUpdateArgs<ExtArgs>>): Prisma__CategoriesClient<$Result.GetResult<Prisma.$CategoriesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Categories.
     * @param {CategoriesDeleteManyArgs} args - Arguments to filter Categories to delete.
     * @example
     * // Delete a few Categories
     * const { count } = await prisma.categories.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CategoriesDeleteManyArgs>(args?: SelectSubset<T, CategoriesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Categories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoriesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Categories
     * const categories = await prisma.categories.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CategoriesUpdateManyArgs>(args: SelectSubset<T, CategoriesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Categories.
     * @param {CategoriesUpsertArgs} args - Arguments to update or create a Categories.
     * @example
     * // Update or create a Categories
     * const categories = await prisma.categories.upsert({
     *   create: {
     *     // ... data to create a Categories
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Categories we want to update
     *   }
     * })
     */
    upsert<T extends CategoriesUpsertArgs>(args: SelectSubset<T, CategoriesUpsertArgs<ExtArgs>>): Prisma__CategoriesClient<$Result.GetResult<Prisma.$CategoriesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Categories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoriesCountArgs} args - Arguments to filter Categories to count.
     * @example
     * // Count the number of Categories
     * const count = await prisma.categories.count({
     *   where: {
     *     // ... the filter for the Categories we want to count
     *   }
     * })
    **/
    count<T extends CategoriesCountArgs>(
      args?: Subset<T, CategoriesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CategoriesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Categories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoriesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CategoriesAggregateArgs>(args: Subset<T, CategoriesAggregateArgs>): Prisma.PrismaPromise<GetCategoriesAggregateType<T>>

    /**
     * Group by Categories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoriesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CategoriesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CategoriesGroupByArgs['orderBy'] }
        : { orderBy?: CategoriesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CategoriesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCategoriesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Categories model
   */
  readonly fields: CategoriesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Categories.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CategoriesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    comics<T extends Categories$comicsArgs<ExtArgs> = {}>(args?: Subset<T, Categories$comicsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ComicsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Categories model
   */
  interface CategoriesFieldRefs {
    readonly id: FieldRef<"Categories", 'Int'>
    readonly title: FieldRef<"Categories", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Categories findUnique
   */
  export type CategoriesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Categories
     */
    select?: CategoriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Categories
     */
    omit?: CategoriesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoriesInclude<ExtArgs> | null
    /**
     * Filter, which Categories to fetch.
     */
    where: CategoriesWhereUniqueInput
  }

  /**
   * Categories findUniqueOrThrow
   */
  export type CategoriesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Categories
     */
    select?: CategoriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Categories
     */
    omit?: CategoriesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoriesInclude<ExtArgs> | null
    /**
     * Filter, which Categories to fetch.
     */
    where: CategoriesWhereUniqueInput
  }

  /**
   * Categories findFirst
   */
  export type CategoriesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Categories
     */
    select?: CategoriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Categories
     */
    omit?: CategoriesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoriesInclude<ExtArgs> | null
    /**
     * Filter, which Categories to fetch.
     */
    where?: CategoriesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Categories to fetch.
     */
    orderBy?: CategoriesOrderByWithRelationInput | CategoriesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Categories.
     */
    cursor?: CategoriesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Categories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Categories.
     */
    distinct?: CategoriesScalarFieldEnum | CategoriesScalarFieldEnum[]
  }

  /**
   * Categories findFirstOrThrow
   */
  export type CategoriesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Categories
     */
    select?: CategoriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Categories
     */
    omit?: CategoriesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoriesInclude<ExtArgs> | null
    /**
     * Filter, which Categories to fetch.
     */
    where?: CategoriesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Categories to fetch.
     */
    orderBy?: CategoriesOrderByWithRelationInput | CategoriesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Categories.
     */
    cursor?: CategoriesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Categories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Categories.
     */
    distinct?: CategoriesScalarFieldEnum | CategoriesScalarFieldEnum[]
  }

  /**
   * Categories findMany
   */
  export type CategoriesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Categories
     */
    select?: CategoriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Categories
     */
    omit?: CategoriesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoriesInclude<ExtArgs> | null
    /**
     * Filter, which Categories to fetch.
     */
    where?: CategoriesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Categories to fetch.
     */
    orderBy?: CategoriesOrderByWithRelationInput | CategoriesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Categories.
     */
    cursor?: CategoriesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Categories.
     */
    skip?: number
    distinct?: CategoriesScalarFieldEnum | CategoriesScalarFieldEnum[]
  }

  /**
   * Categories create
   */
  export type CategoriesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Categories
     */
    select?: CategoriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Categories
     */
    omit?: CategoriesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoriesInclude<ExtArgs> | null
    /**
     * The data needed to create a Categories.
     */
    data: XOR<CategoriesCreateInput, CategoriesUncheckedCreateInput>
  }

  /**
   * Categories createMany
   */
  export type CategoriesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Categories.
     */
    data: CategoriesCreateManyInput | CategoriesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Categories update
   */
  export type CategoriesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Categories
     */
    select?: CategoriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Categories
     */
    omit?: CategoriesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoriesInclude<ExtArgs> | null
    /**
     * The data needed to update a Categories.
     */
    data: XOR<CategoriesUpdateInput, CategoriesUncheckedUpdateInput>
    /**
     * Choose, which Categories to update.
     */
    where: CategoriesWhereUniqueInput
  }

  /**
   * Categories updateMany
   */
  export type CategoriesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Categories.
     */
    data: XOR<CategoriesUpdateManyMutationInput, CategoriesUncheckedUpdateManyInput>
    /**
     * Filter which Categories to update
     */
    where?: CategoriesWhereInput
    /**
     * Limit how many Categories to update.
     */
    limit?: number
  }

  /**
   * Categories upsert
   */
  export type CategoriesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Categories
     */
    select?: CategoriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Categories
     */
    omit?: CategoriesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoriesInclude<ExtArgs> | null
    /**
     * The filter to search for the Categories to update in case it exists.
     */
    where: CategoriesWhereUniqueInput
    /**
     * In case the Categories found by the `where` argument doesn't exist, create a new Categories with this data.
     */
    create: XOR<CategoriesCreateInput, CategoriesUncheckedCreateInput>
    /**
     * In case the Categories was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CategoriesUpdateInput, CategoriesUncheckedUpdateInput>
  }

  /**
   * Categories delete
   */
  export type CategoriesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Categories
     */
    select?: CategoriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Categories
     */
    omit?: CategoriesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoriesInclude<ExtArgs> | null
    /**
     * Filter which Categories to delete.
     */
    where: CategoriesWhereUniqueInput
  }

  /**
   * Categories deleteMany
   */
  export type CategoriesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Categories to delete
     */
    where?: CategoriesWhereInput
    /**
     * Limit how many Categories to delete.
     */
    limit?: number
  }

  /**
   * Categories.comics
   */
  export type Categories$comicsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comics
     */
    select?: ComicsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comics
     */
    omit?: ComicsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComicsInclude<ExtArgs> | null
    where?: ComicsWhereInput
    orderBy?: ComicsOrderByWithRelationInput | ComicsOrderByWithRelationInput[]
    cursor?: ComicsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ComicsScalarFieldEnum | ComicsScalarFieldEnum[]
  }

  /**
   * Categories without action
   */
  export type CategoriesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Categories
     */
    select?: CategoriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Categories
     */
    omit?: CategoriesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoriesInclude<ExtArgs> | null
  }


  /**
   * Model Authors
   */

  export type AggregateAuthors = {
    _count: AuthorsCountAggregateOutputType | null
    _avg: AuthorsAvgAggregateOutputType | null
    _sum: AuthorsSumAggregateOutputType | null
    _min: AuthorsMinAggregateOutputType | null
    _max: AuthorsMaxAggregateOutputType | null
  }

  export type AuthorsAvgAggregateOutputType = {
    id: number | null
  }

  export type AuthorsSumAggregateOutputType = {
    id: number | null
  }

  export type AuthorsMinAggregateOutputType = {
    id: number | null
    name: string | null
    description: string | null
    keywords: string | null
  }

  export type AuthorsMaxAggregateOutputType = {
    id: number | null
    name: string | null
    description: string | null
    keywords: string | null
  }

  export type AuthorsCountAggregateOutputType = {
    id: number
    name: number
    description: number
    keywords: number
    _all: number
  }


  export type AuthorsAvgAggregateInputType = {
    id?: true
  }

  export type AuthorsSumAggregateInputType = {
    id?: true
  }

  export type AuthorsMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    keywords?: true
  }

  export type AuthorsMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    keywords?: true
  }

  export type AuthorsCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    keywords?: true
    _all?: true
  }

  export type AuthorsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Authors to aggregate.
     */
    where?: AuthorsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Authors to fetch.
     */
    orderBy?: AuthorsOrderByWithRelationInput | AuthorsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AuthorsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Authors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Authors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Authors
    **/
    _count?: true | AuthorsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AuthorsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AuthorsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AuthorsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AuthorsMaxAggregateInputType
  }

  export type GetAuthorsAggregateType<T extends AuthorsAggregateArgs> = {
        [P in keyof T & keyof AggregateAuthors]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAuthors[P]>
      : GetScalarType<T[P], AggregateAuthors[P]>
  }




  export type AuthorsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AuthorsWhereInput
    orderBy?: AuthorsOrderByWithAggregationInput | AuthorsOrderByWithAggregationInput[]
    by: AuthorsScalarFieldEnum[] | AuthorsScalarFieldEnum
    having?: AuthorsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AuthorsCountAggregateInputType | true
    _avg?: AuthorsAvgAggregateInputType
    _sum?: AuthorsSumAggregateInputType
    _min?: AuthorsMinAggregateInputType
    _max?: AuthorsMaxAggregateInputType
  }

  export type AuthorsGroupByOutputType = {
    id: number
    name: string
    description: string
    keywords: string
    _count: AuthorsCountAggregateOutputType | null
    _avg: AuthorsAvgAggregateOutputType | null
    _sum: AuthorsSumAggregateOutputType | null
    _min: AuthorsMinAggregateOutputType | null
    _max: AuthorsMaxAggregateOutputType | null
  }

  type GetAuthorsGroupByPayload<T extends AuthorsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AuthorsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AuthorsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AuthorsGroupByOutputType[P]>
            : GetScalarType<T[P], AuthorsGroupByOutputType[P]>
        }
      >
    >


  export type AuthorsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    keywords?: boolean
    comics?: boolean | Authors$comicsArgs<ExtArgs>
    _count?: boolean | AuthorsCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["authors"]>



  export type AuthorsSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    keywords?: boolean
  }

  export type AuthorsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "description" | "keywords", ExtArgs["result"]["authors"]>
  export type AuthorsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    comics?: boolean | Authors$comicsArgs<ExtArgs>
    _count?: boolean | AuthorsCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $AuthorsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Authors"
    objects: {
      comics: Prisma.$ComicsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      description: string
      keywords: string
    }, ExtArgs["result"]["authors"]>
    composites: {}
  }

  type AuthorsGetPayload<S extends boolean | null | undefined | AuthorsDefaultArgs> = $Result.GetResult<Prisma.$AuthorsPayload, S>

  type AuthorsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AuthorsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AuthorsCountAggregateInputType | true
    }

  export interface AuthorsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Authors'], meta: { name: 'Authors' } }
    /**
     * Find zero or one Authors that matches the filter.
     * @param {AuthorsFindUniqueArgs} args - Arguments to find a Authors
     * @example
     * // Get one Authors
     * const authors = await prisma.authors.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AuthorsFindUniqueArgs>(args: SelectSubset<T, AuthorsFindUniqueArgs<ExtArgs>>): Prisma__AuthorsClient<$Result.GetResult<Prisma.$AuthorsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Authors that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AuthorsFindUniqueOrThrowArgs} args - Arguments to find a Authors
     * @example
     * // Get one Authors
     * const authors = await prisma.authors.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AuthorsFindUniqueOrThrowArgs>(args: SelectSubset<T, AuthorsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AuthorsClient<$Result.GetResult<Prisma.$AuthorsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Authors that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuthorsFindFirstArgs} args - Arguments to find a Authors
     * @example
     * // Get one Authors
     * const authors = await prisma.authors.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AuthorsFindFirstArgs>(args?: SelectSubset<T, AuthorsFindFirstArgs<ExtArgs>>): Prisma__AuthorsClient<$Result.GetResult<Prisma.$AuthorsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Authors that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuthorsFindFirstOrThrowArgs} args - Arguments to find a Authors
     * @example
     * // Get one Authors
     * const authors = await prisma.authors.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AuthorsFindFirstOrThrowArgs>(args?: SelectSubset<T, AuthorsFindFirstOrThrowArgs<ExtArgs>>): Prisma__AuthorsClient<$Result.GetResult<Prisma.$AuthorsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Authors that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuthorsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Authors
     * const authors = await prisma.authors.findMany()
     * 
     * // Get first 10 Authors
     * const authors = await prisma.authors.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const authorsWithIdOnly = await prisma.authors.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AuthorsFindManyArgs>(args?: SelectSubset<T, AuthorsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuthorsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Authors.
     * @param {AuthorsCreateArgs} args - Arguments to create a Authors.
     * @example
     * // Create one Authors
     * const Authors = await prisma.authors.create({
     *   data: {
     *     // ... data to create a Authors
     *   }
     * })
     * 
     */
    create<T extends AuthorsCreateArgs>(args: SelectSubset<T, AuthorsCreateArgs<ExtArgs>>): Prisma__AuthorsClient<$Result.GetResult<Prisma.$AuthorsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Authors.
     * @param {AuthorsCreateManyArgs} args - Arguments to create many Authors.
     * @example
     * // Create many Authors
     * const authors = await prisma.authors.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AuthorsCreateManyArgs>(args?: SelectSubset<T, AuthorsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Authors.
     * @param {AuthorsDeleteArgs} args - Arguments to delete one Authors.
     * @example
     * // Delete one Authors
     * const Authors = await prisma.authors.delete({
     *   where: {
     *     // ... filter to delete one Authors
     *   }
     * })
     * 
     */
    delete<T extends AuthorsDeleteArgs>(args: SelectSubset<T, AuthorsDeleteArgs<ExtArgs>>): Prisma__AuthorsClient<$Result.GetResult<Prisma.$AuthorsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Authors.
     * @param {AuthorsUpdateArgs} args - Arguments to update one Authors.
     * @example
     * // Update one Authors
     * const authors = await prisma.authors.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AuthorsUpdateArgs>(args: SelectSubset<T, AuthorsUpdateArgs<ExtArgs>>): Prisma__AuthorsClient<$Result.GetResult<Prisma.$AuthorsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Authors.
     * @param {AuthorsDeleteManyArgs} args - Arguments to filter Authors to delete.
     * @example
     * // Delete a few Authors
     * const { count } = await prisma.authors.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AuthorsDeleteManyArgs>(args?: SelectSubset<T, AuthorsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Authors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuthorsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Authors
     * const authors = await prisma.authors.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AuthorsUpdateManyArgs>(args: SelectSubset<T, AuthorsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Authors.
     * @param {AuthorsUpsertArgs} args - Arguments to update or create a Authors.
     * @example
     * // Update or create a Authors
     * const authors = await prisma.authors.upsert({
     *   create: {
     *     // ... data to create a Authors
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Authors we want to update
     *   }
     * })
     */
    upsert<T extends AuthorsUpsertArgs>(args: SelectSubset<T, AuthorsUpsertArgs<ExtArgs>>): Prisma__AuthorsClient<$Result.GetResult<Prisma.$AuthorsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Authors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuthorsCountArgs} args - Arguments to filter Authors to count.
     * @example
     * // Count the number of Authors
     * const count = await prisma.authors.count({
     *   where: {
     *     // ... the filter for the Authors we want to count
     *   }
     * })
    **/
    count<T extends AuthorsCountArgs>(
      args?: Subset<T, AuthorsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AuthorsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Authors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuthorsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AuthorsAggregateArgs>(args: Subset<T, AuthorsAggregateArgs>): Prisma.PrismaPromise<GetAuthorsAggregateType<T>>

    /**
     * Group by Authors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuthorsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AuthorsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AuthorsGroupByArgs['orderBy'] }
        : { orderBy?: AuthorsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AuthorsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAuthorsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Authors model
   */
  readonly fields: AuthorsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Authors.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AuthorsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    comics<T extends Authors$comicsArgs<ExtArgs> = {}>(args?: Subset<T, Authors$comicsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ComicsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Authors model
   */
  interface AuthorsFieldRefs {
    readonly id: FieldRef<"Authors", 'Int'>
    readonly name: FieldRef<"Authors", 'String'>
    readonly description: FieldRef<"Authors", 'String'>
    readonly keywords: FieldRef<"Authors", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Authors findUnique
   */
  export type AuthorsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Authors
     */
    select?: AuthorsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Authors
     */
    omit?: AuthorsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuthorsInclude<ExtArgs> | null
    /**
     * Filter, which Authors to fetch.
     */
    where: AuthorsWhereUniqueInput
  }

  /**
   * Authors findUniqueOrThrow
   */
  export type AuthorsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Authors
     */
    select?: AuthorsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Authors
     */
    omit?: AuthorsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuthorsInclude<ExtArgs> | null
    /**
     * Filter, which Authors to fetch.
     */
    where: AuthorsWhereUniqueInput
  }

  /**
   * Authors findFirst
   */
  export type AuthorsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Authors
     */
    select?: AuthorsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Authors
     */
    omit?: AuthorsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuthorsInclude<ExtArgs> | null
    /**
     * Filter, which Authors to fetch.
     */
    where?: AuthorsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Authors to fetch.
     */
    orderBy?: AuthorsOrderByWithRelationInput | AuthorsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Authors.
     */
    cursor?: AuthorsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Authors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Authors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Authors.
     */
    distinct?: AuthorsScalarFieldEnum | AuthorsScalarFieldEnum[]
  }

  /**
   * Authors findFirstOrThrow
   */
  export type AuthorsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Authors
     */
    select?: AuthorsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Authors
     */
    omit?: AuthorsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuthorsInclude<ExtArgs> | null
    /**
     * Filter, which Authors to fetch.
     */
    where?: AuthorsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Authors to fetch.
     */
    orderBy?: AuthorsOrderByWithRelationInput | AuthorsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Authors.
     */
    cursor?: AuthorsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Authors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Authors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Authors.
     */
    distinct?: AuthorsScalarFieldEnum | AuthorsScalarFieldEnum[]
  }

  /**
   * Authors findMany
   */
  export type AuthorsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Authors
     */
    select?: AuthorsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Authors
     */
    omit?: AuthorsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuthorsInclude<ExtArgs> | null
    /**
     * Filter, which Authors to fetch.
     */
    where?: AuthorsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Authors to fetch.
     */
    orderBy?: AuthorsOrderByWithRelationInput | AuthorsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Authors.
     */
    cursor?: AuthorsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Authors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Authors.
     */
    skip?: number
    distinct?: AuthorsScalarFieldEnum | AuthorsScalarFieldEnum[]
  }

  /**
   * Authors create
   */
  export type AuthorsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Authors
     */
    select?: AuthorsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Authors
     */
    omit?: AuthorsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuthorsInclude<ExtArgs> | null
    /**
     * The data needed to create a Authors.
     */
    data: XOR<AuthorsCreateInput, AuthorsUncheckedCreateInput>
  }

  /**
   * Authors createMany
   */
  export type AuthorsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Authors.
     */
    data: AuthorsCreateManyInput | AuthorsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Authors update
   */
  export type AuthorsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Authors
     */
    select?: AuthorsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Authors
     */
    omit?: AuthorsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuthorsInclude<ExtArgs> | null
    /**
     * The data needed to update a Authors.
     */
    data: XOR<AuthorsUpdateInput, AuthorsUncheckedUpdateInput>
    /**
     * Choose, which Authors to update.
     */
    where: AuthorsWhereUniqueInput
  }

  /**
   * Authors updateMany
   */
  export type AuthorsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Authors.
     */
    data: XOR<AuthorsUpdateManyMutationInput, AuthorsUncheckedUpdateManyInput>
    /**
     * Filter which Authors to update
     */
    where?: AuthorsWhereInput
    /**
     * Limit how many Authors to update.
     */
    limit?: number
  }

  /**
   * Authors upsert
   */
  export type AuthorsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Authors
     */
    select?: AuthorsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Authors
     */
    omit?: AuthorsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuthorsInclude<ExtArgs> | null
    /**
     * The filter to search for the Authors to update in case it exists.
     */
    where: AuthorsWhereUniqueInput
    /**
     * In case the Authors found by the `where` argument doesn't exist, create a new Authors with this data.
     */
    create: XOR<AuthorsCreateInput, AuthorsUncheckedCreateInput>
    /**
     * In case the Authors was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AuthorsUpdateInput, AuthorsUncheckedUpdateInput>
  }

  /**
   * Authors delete
   */
  export type AuthorsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Authors
     */
    select?: AuthorsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Authors
     */
    omit?: AuthorsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuthorsInclude<ExtArgs> | null
    /**
     * Filter which Authors to delete.
     */
    where: AuthorsWhereUniqueInput
  }

  /**
   * Authors deleteMany
   */
  export type AuthorsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Authors to delete
     */
    where?: AuthorsWhereInput
    /**
     * Limit how many Authors to delete.
     */
    limit?: number
  }

  /**
   * Authors.comics
   */
  export type Authors$comicsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comics
     */
    select?: ComicsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comics
     */
    omit?: ComicsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComicsInclude<ExtArgs> | null
    where?: ComicsWhereInput
    orderBy?: ComicsOrderByWithRelationInput | ComicsOrderByWithRelationInput[]
    cursor?: ComicsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ComicsScalarFieldEnum | ComicsScalarFieldEnum[]
  }

  /**
   * Authors without action
   */
  export type AuthorsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Authors
     */
    select?: AuthorsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Authors
     */
    omit?: AuthorsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuthorsInclude<ExtArgs> | null
  }


  /**
   * Model Comics
   */

  export type AggregateComics = {
    _count: ComicsCountAggregateOutputType | null
    _avg: ComicsAvgAggregateOutputType | null
    _sum: ComicsSumAggregateOutputType | null
    _min: ComicsMinAggregateOutputType | null
    _max: ComicsMaxAggregateOutputType | null
  }

  export type ComicsAvgAggregateOutputType = {
    id: number | null
    price: Decimal | null
    userId: number | null
  }

  export type ComicsSumAggregateOutputType = {
    id: number | null
    price: Decimal | null
    userId: number | null
  }

  export type ComicsMinAggregateOutputType = {
    id: number | null
    title: string | null
    description: string | null
    image: string | null
    keywords: string | null
    status: string | null
    price: Decimal | null
    createdAt: Date | null
    updatedAt: Date | null
    userId: number | null
  }

  export type ComicsMaxAggregateOutputType = {
    id: number | null
    title: string | null
    description: string | null
    image: string | null
    keywords: string | null
    status: string | null
    price: Decimal | null
    createdAt: Date | null
    updatedAt: Date | null
    userId: number | null
  }

  export type ComicsCountAggregateOutputType = {
    id: number
    title: number
    description: number
    image: number
    keywords: number
    status: number
    price: number
    createdAt: number
    updatedAt: number
    userId: number
    _all: number
  }


  export type ComicsAvgAggregateInputType = {
    id?: true
    price?: true
    userId?: true
  }

  export type ComicsSumAggregateInputType = {
    id?: true
    price?: true
    userId?: true
  }

  export type ComicsMinAggregateInputType = {
    id?: true
    title?: true
    description?: true
    image?: true
    keywords?: true
    status?: true
    price?: true
    createdAt?: true
    updatedAt?: true
    userId?: true
  }

  export type ComicsMaxAggregateInputType = {
    id?: true
    title?: true
    description?: true
    image?: true
    keywords?: true
    status?: true
    price?: true
    createdAt?: true
    updatedAt?: true
    userId?: true
  }

  export type ComicsCountAggregateInputType = {
    id?: true
    title?: true
    description?: true
    image?: true
    keywords?: true
    status?: true
    price?: true
    createdAt?: true
    updatedAt?: true
    userId?: true
    _all?: true
  }

  export type ComicsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Comics to aggregate.
     */
    where?: ComicsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Comics to fetch.
     */
    orderBy?: ComicsOrderByWithRelationInput | ComicsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ComicsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Comics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Comics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Comics
    **/
    _count?: true | ComicsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ComicsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ComicsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ComicsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ComicsMaxAggregateInputType
  }

  export type GetComicsAggregateType<T extends ComicsAggregateArgs> = {
        [P in keyof T & keyof AggregateComics]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateComics[P]>
      : GetScalarType<T[P], AggregateComics[P]>
  }




  export type ComicsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ComicsWhereInput
    orderBy?: ComicsOrderByWithAggregationInput | ComicsOrderByWithAggregationInput[]
    by: ComicsScalarFieldEnum[] | ComicsScalarFieldEnum
    having?: ComicsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ComicsCountAggregateInputType | true
    _avg?: ComicsAvgAggregateInputType
    _sum?: ComicsSumAggregateInputType
    _min?: ComicsMinAggregateInputType
    _max?: ComicsMaxAggregateInputType
  }

  export type ComicsGroupByOutputType = {
    id: number
    title: string
    description: string
    image: string
    keywords: string
    status: string
    price: Decimal
    createdAt: Date
    updatedAt: Date
    userId: number
    _count: ComicsCountAggregateOutputType | null
    _avg: ComicsAvgAggregateOutputType | null
    _sum: ComicsSumAggregateOutputType | null
    _min: ComicsMinAggregateOutputType | null
    _max: ComicsMaxAggregateOutputType | null
  }

  type GetComicsGroupByPayload<T extends ComicsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ComicsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ComicsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ComicsGroupByOutputType[P]>
            : GetScalarType<T[P], ComicsGroupByOutputType[P]>
        }
      >
    >


  export type ComicsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    image?: boolean
    keywords?: boolean
    status?: boolean
    price?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    userId?: boolean
    categories?: boolean | Comics$categoriesArgs<ExtArgs>
    authors?: boolean | Comics$authorsArgs<ExtArgs>
    volumes?: boolean | Comics$volumesArgs<ExtArgs>
    favorites?: boolean | Comics$favoritesArgs<ExtArgs>
    rates?: boolean | Comics$ratesArgs<ExtArgs>
    views?: boolean | Comics$viewsArgs<ExtArgs>
    comment?: boolean | Comics$commentArgs<ExtArgs>
    unlock_comic?: boolean | Comics$unlock_comicArgs<ExtArgs>
    user?: boolean | UsersDefaultArgs<ExtArgs>
    _count?: boolean | ComicsCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["comics"]>



  export type ComicsSelectScalar = {
    id?: boolean
    title?: boolean
    description?: boolean
    image?: boolean
    keywords?: boolean
    status?: boolean
    price?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    userId?: boolean
  }

  export type ComicsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "title" | "description" | "image" | "keywords" | "status" | "price" | "createdAt" | "updatedAt" | "userId", ExtArgs["result"]["comics"]>
  export type ComicsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    categories?: boolean | Comics$categoriesArgs<ExtArgs>
    authors?: boolean | Comics$authorsArgs<ExtArgs>
    volumes?: boolean | Comics$volumesArgs<ExtArgs>
    favorites?: boolean | Comics$favoritesArgs<ExtArgs>
    rates?: boolean | Comics$ratesArgs<ExtArgs>
    views?: boolean | Comics$viewsArgs<ExtArgs>
    comment?: boolean | Comics$commentArgs<ExtArgs>
    unlock_comic?: boolean | Comics$unlock_comicArgs<ExtArgs>
    user?: boolean | UsersDefaultArgs<ExtArgs>
    _count?: boolean | ComicsCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $ComicsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Comics"
    objects: {
      categories: Prisma.$CategoriesPayload<ExtArgs>[]
      authors: Prisma.$AuthorsPayload<ExtArgs>[]
      volumes: Prisma.$VolumesPayload<ExtArgs>[]
      favorites: Prisma.$FavoritesPayload<ExtArgs>[]
      rates: Prisma.$RatesPayload<ExtArgs>[]
      views: Prisma.$ViewsPayload<ExtArgs>[]
      comment: Prisma.$CommentsPayload<ExtArgs>[]
      unlock_comic: Prisma.$Unlock_comicPayload<ExtArgs>[]
      user: Prisma.$UsersPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      title: string
      description: string
      image: string
      keywords: string
      status: string
      price: Prisma.Decimal
      createdAt: Date
      updatedAt: Date
      userId: number
    }, ExtArgs["result"]["comics"]>
    composites: {}
  }

  type ComicsGetPayload<S extends boolean | null | undefined | ComicsDefaultArgs> = $Result.GetResult<Prisma.$ComicsPayload, S>

  type ComicsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ComicsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ComicsCountAggregateInputType | true
    }

  export interface ComicsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Comics'], meta: { name: 'Comics' } }
    /**
     * Find zero or one Comics that matches the filter.
     * @param {ComicsFindUniqueArgs} args - Arguments to find a Comics
     * @example
     * // Get one Comics
     * const comics = await prisma.comics.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ComicsFindUniqueArgs>(args: SelectSubset<T, ComicsFindUniqueArgs<ExtArgs>>): Prisma__ComicsClient<$Result.GetResult<Prisma.$ComicsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Comics that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ComicsFindUniqueOrThrowArgs} args - Arguments to find a Comics
     * @example
     * // Get one Comics
     * const comics = await prisma.comics.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ComicsFindUniqueOrThrowArgs>(args: SelectSubset<T, ComicsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ComicsClient<$Result.GetResult<Prisma.$ComicsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Comics that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComicsFindFirstArgs} args - Arguments to find a Comics
     * @example
     * // Get one Comics
     * const comics = await prisma.comics.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ComicsFindFirstArgs>(args?: SelectSubset<T, ComicsFindFirstArgs<ExtArgs>>): Prisma__ComicsClient<$Result.GetResult<Prisma.$ComicsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Comics that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComicsFindFirstOrThrowArgs} args - Arguments to find a Comics
     * @example
     * // Get one Comics
     * const comics = await prisma.comics.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ComicsFindFirstOrThrowArgs>(args?: SelectSubset<T, ComicsFindFirstOrThrowArgs<ExtArgs>>): Prisma__ComicsClient<$Result.GetResult<Prisma.$ComicsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Comics that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComicsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Comics
     * const comics = await prisma.comics.findMany()
     * 
     * // Get first 10 Comics
     * const comics = await prisma.comics.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const comicsWithIdOnly = await prisma.comics.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ComicsFindManyArgs>(args?: SelectSubset<T, ComicsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ComicsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Comics.
     * @param {ComicsCreateArgs} args - Arguments to create a Comics.
     * @example
     * // Create one Comics
     * const Comics = await prisma.comics.create({
     *   data: {
     *     // ... data to create a Comics
     *   }
     * })
     * 
     */
    create<T extends ComicsCreateArgs>(args: SelectSubset<T, ComicsCreateArgs<ExtArgs>>): Prisma__ComicsClient<$Result.GetResult<Prisma.$ComicsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Comics.
     * @param {ComicsCreateManyArgs} args - Arguments to create many Comics.
     * @example
     * // Create many Comics
     * const comics = await prisma.comics.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ComicsCreateManyArgs>(args?: SelectSubset<T, ComicsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Comics.
     * @param {ComicsDeleteArgs} args - Arguments to delete one Comics.
     * @example
     * // Delete one Comics
     * const Comics = await prisma.comics.delete({
     *   where: {
     *     // ... filter to delete one Comics
     *   }
     * })
     * 
     */
    delete<T extends ComicsDeleteArgs>(args: SelectSubset<T, ComicsDeleteArgs<ExtArgs>>): Prisma__ComicsClient<$Result.GetResult<Prisma.$ComicsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Comics.
     * @param {ComicsUpdateArgs} args - Arguments to update one Comics.
     * @example
     * // Update one Comics
     * const comics = await prisma.comics.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ComicsUpdateArgs>(args: SelectSubset<T, ComicsUpdateArgs<ExtArgs>>): Prisma__ComicsClient<$Result.GetResult<Prisma.$ComicsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Comics.
     * @param {ComicsDeleteManyArgs} args - Arguments to filter Comics to delete.
     * @example
     * // Delete a few Comics
     * const { count } = await prisma.comics.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ComicsDeleteManyArgs>(args?: SelectSubset<T, ComicsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Comics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComicsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Comics
     * const comics = await prisma.comics.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ComicsUpdateManyArgs>(args: SelectSubset<T, ComicsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Comics.
     * @param {ComicsUpsertArgs} args - Arguments to update or create a Comics.
     * @example
     * // Update or create a Comics
     * const comics = await prisma.comics.upsert({
     *   create: {
     *     // ... data to create a Comics
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Comics we want to update
     *   }
     * })
     */
    upsert<T extends ComicsUpsertArgs>(args: SelectSubset<T, ComicsUpsertArgs<ExtArgs>>): Prisma__ComicsClient<$Result.GetResult<Prisma.$ComicsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Comics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComicsCountArgs} args - Arguments to filter Comics to count.
     * @example
     * // Count the number of Comics
     * const count = await prisma.comics.count({
     *   where: {
     *     // ... the filter for the Comics we want to count
     *   }
     * })
    **/
    count<T extends ComicsCountArgs>(
      args?: Subset<T, ComicsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ComicsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Comics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComicsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ComicsAggregateArgs>(args: Subset<T, ComicsAggregateArgs>): Prisma.PrismaPromise<GetComicsAggregateType<T>>

    /**
     * Group by Comics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComicsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ComicsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ComicsGroupByArgs['orderBy'] }
        : { orderBy?: ComicsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ComicsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetComicsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Comics model
   */
  readonly fields: ComicsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Comics.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ComicsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    categories<T extends Comics$categoriesArgs<ExtArgs> = {}>(args?: Subset<T, Comics$categoriesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CategoriesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    authors<T extends Comics$authorsArgs<ExtArgs> = {}>(args?: Subset<T, Comics$authorsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuthorsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    volumes<T extends Comics$volumesArgs<ExtArgs> = {}>(args?: Subset<T, Comics$volumesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VolumesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    favorites<T extends Comics$favoritesArgs<ExtArgs> = {}>(args?: Subset<T, Comics$favoritesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FavoritesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    rates<T extends Comics$ratesArgs<ExtArgs> = {}>(args?: Subset<T, Comics$ratesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RatesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    views<T extends Comics$viewsArgs<ExtArgs> = {}>(args?: Subset<T, Comics$viewsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ViewsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    comment<T extends Comics$commentArgs<ExtArgs> = {}>(args?: Subset<T, Comics$commentArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommentsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    unlock_comic<T extends Comics$unlock_comicArgs<ExtArgs> = {}>(args?: Subset<T, Comics$unlock_comicArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$Unlock_comicPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    user<T extends UsersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UsersDefaultArgs<ExtArgs>>): Prisma__UsersClient<$Result.GetResult<Prisma.$UsersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Comics model
   */
  interface ComicsFieldRefs {
    readonly id: FieldRef<"Comics", 'Int'>
    readonly title: FieldRef<"Comics", 'String'>
    readonly description: FieldRef<"Comics", 'String'>
    readonly image: FieldRef<"Comics", 'String'>
    readonly keywords: FieldRef<"Comics", 'String'>
    readonly status: FieldRef<"Comics", 'String'>
    readonly price: FieldRef<"Comics", 'Decimal'>
    readonly createdAt: FieldRef<"Comics", 'DateTime'>
    readonly updatedAt: FieldRef<"Comics", 'DateTime'>
    readonly userId: FieldRef<"Comics", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Comics findUnique
   */
  export type ComicsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comics
     */
    select?: ComicsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comics
     */
    omit?: ComicsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComicsInclude<ExtArgs> | null
    /**
     * Filter, which Comics to fetch.
     */
    where: ComicsWhereUniqueInput
  }

  /**
   * Comics findUniqueOrThrow
   */
  export type ComicsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comics
     */
    select?: ComicsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comics
     */
    omit?: ComicsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComicsInclude<ExtArgs> | null
    /**
     * Filter, which Comics to fetch.
     */
    where: ComicsWhereUniqueInput
  }

  /**
   * Comics findFirst
   */
  export type ComicsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comics
     */
    select?: ComicsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comics
     */
    omit?: ComicsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComicsInclude<ExtArgs> | null
    /**
     * Filter, which Comics to fetch.
     */
    where?: ComicsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Comics to fetch.
     */
    orderBy?: ComicsOrderByWithRelationInput | ComicsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Comics.
     */
    cursor?: ComicsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Comics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Comics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Comics.
     */
    distinct?: ComicsScalarFieldEnum | ComicsScalarFieldEnum[]
  }

  /**
   * Comics findFirstOrThrow
   */
  export type ComicsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comics
     */
    select?: ComicsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comics
     */
    omit?: ComicsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComicsInclude<ExtArgs> | null
    /**
     * Filter, which Comics to fetch.
     */
    where?: ComicsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Comics to fetch.
     */
    orderBy?: ComicsOrderByWithRelationInput | ComicsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Comics.
     */
    cursor?: ComicsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Comics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Comics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Comics.
     */
    distinct?: ComicsScalarFieldEnum | ComicsScalarFieldEnum[]
  }

  /**
   * Comics findMany
   */
  export type ComicsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comics
     */
    select?: ComicsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comics
     */
    omit?: ComicsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComicsInclude<ExtArgs> | null
    /**
     * Filter, which Comics to fetch.
     */
    where?: ComicsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Comics to fetch.
     */
    orderBy?: ComicsOrderByWithRelationInput | ComicsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Comics.
     */
    cursor?: ComicsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Comics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Comics.
     */
    skip?: number
    distinct?: ComicsScalarFieldEnum | ComicsScalarFieldEnum[]
  }

  /**
   * Comics create
   */
  export type ComicsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comics
     */
    select?: ComicsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comics
     */
    omit?: ComicsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComicsInclude<ExtArgs> | null
    /**
     * The data needed to create a Comics.
     */
    data: XOR<ComicsCreateInput, ComicsUncheckedCreateInput>
  }

  /**
   * Comics createMany
   */
  export type ComicsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Comics.
     */
    data: ComicsCreateManyInput | ComicsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Comics update
   */
  export type ComicsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comics
     */
    select?: ComicsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comics
     */
    omit?: ComicsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComicsInclude<ExtArgs> | null
    /**
     * The data needed to update a Comics.
     */
    data: XOR<ComicsUpdateInput, ComicsUncheckedUpdateInput>
    /**
     * Choose, which Comics to update.
     */
    where: ComicsWhereUniqueInput
  }

  /**
   * Comics updateMany
   */
  export type ComicsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Comics.
     */
    data: XOR<ComicsUpdateManyMutationInput, ComicsUncheckedUpdateManyInput>
    /**
     * Filter which Comics to update
     */
    where?: ComicsWhereInput
    /**
     * Limit how many Comics to update.
     */
    limit?: number
  }

  /**
   * Comics upsert
   */
  export type ComicsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comics
     */
    select?: ComicsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comics
     */
    omit?: ComicsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComicsInclude<ExtArgs> | null
    /**
     * The filter to search for the Comics to update in case it exists.
     */
    where: ComicsWhereUniqueInput
    /**
     * In case the Comics found by the `where` argument doesn't exist, create a new Comics with this data.
     */
    create: XOR<ComicsCreateInput, ComicsUncheckedCreateInput>
    /**
     * In case the Comics was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ComicsUpdateInput, ComicsUncheckedUpdateInput>
  }

  /**
   * Comics delete
   */
  export type ComicsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comics
     */
    select?: ComicsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comics
     */
    omit?: ComicsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComicsInclude<ExtArgs> | null
    /**
     * Filter which Comics to delete.
     */
    where: ComicsWhereUniqueInput
  }

  /**
   * Comics deleteMany
   */
  export type ComicsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Comics to delete
     */
    where?: ComicsWhereInput
    /**
     * Limit how many Comics to delete.
     */
    limit?: number
  }

  /**
   * Comics.categories
   */
  export type Comics$categoriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Categories
     */
    select?: CategoriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Categories
     */
    omit?: CategoriesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoriesInclude<ExtArgs> | null
    where?: CategoriesWhereInput
    orderBy?: CategoriesOrderByWithRelationInput | CategoriesOrderByWithRelationInput[]
    cursor?: CategoriesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CategoriesScalarFieldEnum | CategoriesScalarFieldEnum[]
  }

  /**
   * Comics.authors
   */
  export type Comics$authorsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Authors
     */
    select?: AuthorsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Authors
     */
    omit?: AuthorsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuthorsInclude<ExtArgs> | null
    where?: AuthorsWhereInput
    orderBy?: AuthorsOrderByWithRelationInput | AuthorsOrderByWithRelationInput[]
    cursor?: AuthorsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AuthorsScalarFieldEnum | AuthorsScalarFieldEnum[]
  }

  /**
   * Comics.volumes
   */
  export type Comics$volumesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Volumes
     */
    select?: VolumesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Volumes
     */
    omit?: VolumesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VolumesInclude<ExtArgs> | null
    where?: VolumesWhereInput
    orderBy?: VolumesOrderByWithRelationInput | VolumesOrderByWithRelationInput[]
    cursor?: VolumesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: VolumesScalarFieldEnum | VolumesScalarFieldEnum[]
  }

  /**
   * Comics.favorites
   */
  export type Comics$favoritesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Favorites
     */
    select?: FavoritesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Favorites
     */
    omit?: FavoritesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FavoritesInclude<ExtArgs> | null
    where?: FavoritesWhereInput
    orderBy?: FavoritesOrderByWithRelationInput | FavoritesOrderByWithRelationInput[]
    cursor?: FavoritesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FavoritesScalarFieldEnum | FavoritesScalarFieldEnum[]
  }

  /**
   * Comics.rates
   */
  export type Comics$ratesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Rates
     */
    select?: RatesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Rates
     */
    omit?: RatesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RatesInclude<ExtArgs> | null
    where?: RatesWhereInput
    orderBy?: RatesOrderByWithRelationInput | RatesOrderByWithRelationInput[]
    cursor?: RatesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RatesScalarFieldEnum | RatesScalarFieldEnum[]
  }

  /**
   * Comics.views
   */
  export type Comics$viewsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Views
     */
    select?: ViewsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Views
     */
    omit?: ViewsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ViewsInclude<ExtArgs> | null
    where?: ViewsWhereInput
    orderBy?: ViewsOrderByWithRelationInput | ViewsOrderByWithRelationInput[]
    cursor?: ViewsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ViewsScalarFieldEnum | ViewsScalarFieldEnum[]
  }

  /**
   * Comics.comment
   */
  export type Comics$commentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comments
     */
    select?: CommentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comments
     */
    omit?: CommentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentsInclude<ExtArgs> | null
    where?: CommentsWhereInput
    orderBy?: CommentsOrderByWithRelationInput | CommentsOrderByWithRelationInput[]
    cursor?: CommentsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CommentsScalarFieldEnum | CommentsScalarFieldEnum[]
  }

  /**
   * Comics.unlock_comic
   */
  export type Comics$unlock_comicArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Unlock_comic
     */
    select?: Unlock_comicSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Unlock_comic
     */
    omit?: Unlock_comicOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Unlock_comicInclude<ExtArgs> | null
    where?: Unlock_comicWhereInput
    orderBy?: Unlock_comicOrderByWithRelationInput | Unlock_comicOrderByWithRelationInput[]
    cursor?: Unlock_comicWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Unlock_comicScalarFieldEnum | Unlock_comicScalarFieldEnum[]
  }

  /**
   * Comics without action
   */
  export type ComicsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comics
     */
    select?: ComicsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comics
     */
    omit?: ComicsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComicsInclude<ExtArgs> | null
  }


  /**
   * Model Volumes
   */

  export type AggregateVolumes = {
    _count: VolumesCountAggregateOutputType | null
    _avg: VolumesAvgAggregateOutputType | null
    _sum: VolumesSumAggregateOutputType | null
    _min: VolumesMinAggregateOutputType | null
    _max: VolumesMaxAggregateOutputType | null
  }

  export type VolumesAvgAggregateOutputType = {
    id: number | null
    price: Decimal | null
    comicId: number | null
  }

  export type VolumesSumAggregateOutputType = {
    id: number | null
    price: Decimal | null
    comicId: number | null
  }

  export type VolumesMinAggregateOutputType = {
    id: number | null
    title: string | null
    description: string | null
    price: Decimal | null
    comicId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type VolumesMaxAggregateOutputType = {
    id: number | null
    title: string | null
    description: string | null
    price: Decimal | null
    comicId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type VolumesCountAggregateOutputType = {
    id: number
    title: number
    description: number
    price: number
    comicId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type VolumesAvgAggregateInputType = {
    id?: true
    price?: true
    comicId?: true
  }

  export type VolumesSumAggregateInputType = {
    id?: true
    price?: true
    comicId?: true
  }

  export type VolumesMinAggregateInputType = {
    id?: true
    title?: true
    description?: true
    price?: true
    comicId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type VolumesMaxAggregateInputType = {
    id?: true
    title?: true
    description?: true
    price?: true
    comicId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type VolumesCountAggregateInputType = {
    id?: true
    title?: true
    description?: true
    price?: true
    comicId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type VolumesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Volumes to aggregate.
     */
    where?: VolumesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Volumes to fetch.
     */
    orderBy?: VolumesOrderByWithRelationInput | VolumesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: VolumesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Volumes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Volumes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Volumes
    **/
    _count?: true | VolumesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: VolumesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: VolumesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VolumesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VolumesMaxAggregateInputType
  }

  export type GetVolumesAggregateType<T extends VolumesAggregateArgs> = {
        [P in keyof T & keyof AggregateVolumes]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVolumes[P]>
      : GetScalarType<T[P], AggregateVolumes[P]>
  }




  export type VolumesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VolumesWhereInput
    orderBy?: VolumesOrderByWithAggregationInput | VolumesOrderByWithAggregationInput[]
    by: VolumesScalarFieldEnum[] | VolumesScalarFieldEnum
    having?: VolumesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VolumesCountAggregateInputType | true
    _avg?: VolumesAvgAggregateInputType
    _sum?: VolumesSumAggregateInputType
    _min?: VolumesMinAggregateInputType
    _max?: VolumesMaxAggregateInputType
  }

  export type VolumesGroupByOutputType = {
    id: number
    title: string
    description: string
    price: Decimal
    comicId: number
    createdAt: Date
    updatedAt: Date
    _count: VolumesCountAggregateOutputType | null
    _avg: VolumesAvgAggregateOutputType | null
    _sum: VolumesSumAggregateOutputType | null
    _min: VolumesMinAggregateOutputType | null
    _max: VolumesMaxAggregateOutputType | null
  }

  type GetVolumesGroupByPayload<T extends VolumesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<VolumesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VolumesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VolumesGroupByOutputType[P]>
            : GetScalarType<T[P], VolumesGroupByOutputType[P]>
        }
      >
    >


  export type VolumesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    price?: boolean
    comicId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    comic?: boolean | ComicsDefaultArgs<ExtArgs>
    chapters?: boolean | Volumes$chaptersArgs<ExtArgs>
    unlock_volume?: boolean | Volumes$unlock_volumeArgs<ExtArgs>
    _count?: boolean | VolumesCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["volumes"]>



  export type VolumesSelectScalar = {
    id?: boolean
    title?: boolean
    description?: boolean
    price?: boolean
    comicId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type VolumesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "title" | "description" | "price" | "comicId" | "createdAt" | "updatedAt", ExtArgs["result"]["volumes"]>
  export type VolumesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    comic?: boolean | ComicsDefaultArgs<ExtArgs>
    chapters?: boolean | Volumes$chaptersArgs<ExtArgs>
    unlock_volume?: boolean | Volumes$unlock_volumeArgs<ExtArgs>
    _count?: boolean | VolumesCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $VolumesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Volumes"
    objects: {
      comic: Prisma.$ComicsPayload<ExtArgs>
      chapters: Prisma.$ChaptersPayload<ExtArgs>[]
      unlock_volume: Prisma.$Unlock_volumePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      title: string
      description: string
      price: Prisma.Decimal
      comicId: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["volumes"]>
    composites: {}
  }

  type VolumesGetPayload<S extends boolean | null | undefined | VolumesDefaultArgs> = $Result.GetResult<Prisma.$VolumesPayload, S>

  type VolumesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<VolumesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: VolumesCountAggregateInputType | true
    }

  export interface VolumesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Volumes'], meta: { name: 'Volumes' } }
    /**
     * Find zero or one Volumes that matches the filter.
     * @param {VolumesFindUniqueArgs} args - Arguments to find a Volumes
     * @example
     * // Get one Volumes
     * const volumes = await prisma.volumes.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends VolumesFindUniqueArgs>(args: SelectSubset<T, VolumesFindUniqueArgs<ExtArgs>>): Prisma__VolumesClient<$Result.GetResult<Prisma.$VolumesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Volumes that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {VolumesFindUniqueOrThrowArgs} args - Arguments to find a Volumes
     * @example
     * // Get one Volumes
     * const volumes = await prisma.volumes.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends VolumesFindUniqueOrThrowArgs>(args: SelectSubset<T, VolumesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__VolumesClient<$Result.GetResult<Prisma.$VolumesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Volumes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VolumesFindFirstArgs} args - Arguments to find a Volumes
     * @example
     * // Get one Volumes
     * const volumes = await prisma.volumes.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends VolumesFindFirstArgs>(args?: SelectSubset<T, VolumesFindFirstArgs<ExtArgs>>): Prisma__VolumesClient<$Result.GetResult<Prisma.$VolumesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Volumes that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VolumesFindFirstOrThrowArgs} args - Arguments to find a Volumes
     * @example
     * // Get one Volumes
     * const volumes = await prisma.volumes.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends VolumesFindFirstOrThrowArgs>(args?: SelectSubset<T, VolumesFindFirstOrThrowArgs<ExtArgs>>): Prisma__VolumesClient<$Result.GetResult<Prisma.$VolumesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Volumes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VolumesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Volumes
     * const volumes = await prisma.volumes.findMany()
     * 
     * // Get first 10 Volumes
     * const volumes = await prisma.volumes.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const volumesWithIdOnly = await prisma.volumes.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends VolumesFindManyArgs>(args?: SelectSubset<T, VolumesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VolumesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Volumes.
     * @param {VolumesCreateArgs} args - Arguments to create a Volumes.
     * @example
     * // Create one Volumes
     * const Volumes = await prisma.volumes.create({
     *   data: {
     *     // ... data to create a Volumes
     *   }
     * })
     * 
     */
    create<T extends VolumesCreateArgs>(args: SelectSubset<T, VolumesCreateArgs<ExtArgs>>): Prisma__VolumesClient<$Result.GetResult<Prisma.$VolumesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Volumes.
     * @param {VolumesCreateManyArgs} args - Arguments to create many Volumes.
     * @example
     * // Create many Volumes
     * const volumes = await prisma.volumes.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends VolumesCreateManyArgs>(args?: SelectSubset<T, VolumesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Volumes.
     * @param {VolumesDeleteArgs} args - Arguments to delete one Volumes.
     * @example
     * // Delete one Volumes
     * const Volumes = await prisma.volumes.delete({
     *   where: {
     *     // ... filter to delete one Volumes
     *   }
     * })
     * 
     */
    delete<T extends VolumesDeleteArgs>(args: SelectSubset<T, VolumesDeleteArgs<ExtArgs>>): Prisma__VolumesClient<$Result.GetResult<Prisma.$VolumesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Volumes.
     * @param {VolumesUpdateArgs} args - Arguments to update one Volumes.
     * @example
     * // Update one Volumes
     * const volumes = await prisma.volumes.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends VolumesUpdateArgs>(args: SelectSubset<T, VolumesUpdateArgs<ExtArgs>>): Prisma__VolumesClient<$Result.GetResult<Prisma.$VolumesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Volumes.
     * @param {VolumesDeleteManyArgs} args - Arguments to filter Volumes to delete.
     * @example
     * // Delete a few Volumes
     * const { count } = await prisma.volumes.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends VolumesDeleteManyArgs>(args?: SelectSubset<T, VolumesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Volumes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VolumesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Volumes
     * const volumes = await prisma.volumes.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends VolumesUpdateManyArgs>(args: SelectSubset<T, VolumesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Volumes.
     * @param {VolumesUpsertArgs} args - Arguments to update or create a Volumes.
     * @example
     * // Update or create a Volumes
     * const volumes = await prisma.volumes.upsert({
     *   create: {
     *     // ... data to create a Volumes
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Volumes we want to update
     *   }
     * })
     */
    upsert<T extends VolumesUpsertArgs>(args: SelectSubset<T, VolumesUpsertArgs<ExtArgs>>): Prisma__VolumesClient<$Result.GetResult<Prisma.$VolumesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Volumes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VolumesCountArgs} args - Arguments to filter Volumes to count.
     * @example
     * // Count the number of Volumes
     * const count = await prisma.volumes.count({
     *   where: {
     *     // ... the filter for the Volumes we want to count
     *   }
     * })
    **/
    count<T extends VolumesCountArgs>(
      args?: Subset<T, VolumesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VolumesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Volumes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VolumesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VolumesAggregateArgs>(args: Subset<T, VolumesAggregateArgs>): Prisma.PrismaPromise<GetVolumesAggregateType<T>>

    /**
     * Group by Volumes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VolumesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VolumesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VolumesGroupByArgs['orderBy'] }
        : { orderBy?: VolumesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VolumesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVolumesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Volumes model
   */
  readonly fields: VolumesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Volumes.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__VolumesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    comic<T extends ComicsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ComicsDefaultArgs<ExtArgs>>): Prisma__ComicsClient<$Result.GetResult<Prisma.$ComicsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    chapters<T extends Volumes$chaptersArgs<ExtArgs> = {}>(args?: Subset<T, Volumes$chaptersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChaptersPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    unlock_volume<T extends Volumes$unlock_volumeArgs<ExtArgs> = {}>(args?: Subset<T, Volumes$unlock_volumeArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$Unlock_volumePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Volumes model
   */
  interface VolumesFieldRefs {
    readonly id: FieldRef<"Volumes", 'Int'>
    readonly title: FieldRef<"Volumes", 'String'>
    readonly description: FieldRef<"Volumes", 'String'>
    readonly price: FieldRef<"Volumes", 'Decimal'>
    readonly comicId: FieldRef<"Volumes", 'Int'>
    readonly createdAt: FieldRef<"Volumes", 'DateTime'>
    readonly updatedAt: FieldRef<"Volumes", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Volumes findUnique
   */
  export type VolumesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Volumes
     */
    select?: VolumesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Volumes
     */
    omit?: VolumesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VolumesInclude<ExtArgs> | null
    /**
     * Filter, which Volumes to fetch.
     */
    where: VolumesWhereUniqueInput
  }

  /**
   * Volumes findUniqueOrThrow
   */
  export type VolumesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Volumes
     */
    select?: VolumesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Volumes
     */
    omit?: VolumesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VolumesInclude<ExtArgs> | null
    /**
     * Filter, which Volumes to fetch.
     */
    where: VolumesWhereUniqueInput
  }

  /**
   * Volumes findFirst
   */
  export type VolumesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Volumes
     */
    select?: VolumesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Volumes
     */
    omit?: VolumesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VolumesInclude<ExtArgs> | null
    /**
     * Filter, which Volumes to fetch.
     */
    where?: VolumesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Volumes to fetch.
     */
    orderBy?: VolumesOrderByWithRelationInput | VolumesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Volumes.
     */
    cursor?: VolumesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Volumes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Volumes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Volumes.
     */
    distinct?: VolumesScalarFieldEnum | VolumesScalarFieldEnum[]
  }

  /**
   * Volumes findFirstOrThrow
   */
  export type VolumesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Volumes
     */
    select?: VolumesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Volumes
     */
    omit?: VolumesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VolumesInclude<ExtArgs> | null
    /**
     * Filter, which Volumes to fetch.
     */
    where?: VolumesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Volumes to fetch.
     */
    orderBy?: VolumesOrderByWithRelationInput | VolumesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Volumes.
     */
    cursor?: VolumesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Volumes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Volumes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Volumes.
     */
    distinct?: VolumesScalarFieldEnum | VolumesScalarFieldEnum[]
  }

  /**
   * Volumes findMany
   */
  export type VolumesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Volumes
     */
    select?: VolumesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Volumes
     */
    omit?: VolumesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VolumesInclude<ExtArgs> | null
    /**
     * Filter, which Volumes to fetch.
     */
    where?: VolumesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Volumes to fetch.
     */
    orderBy?: VolumesOrderByWithRelationInput | VolumesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Volumes.
     */
    cursor?: VolumesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Volumes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Volumes.
     */
    skip?: number
    distinct?: VolumesScalarFieldEnum | VolumesScalarFieldEnum[]
  }

  /**
   * Volumes create
   */
  export type VolumesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Volumes
     */
    select?: VolumesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Volumes
     */
    omit?: VolumesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VolumesInclude<ExtArgs> | null
    /**
     * The data needed to create a Volumes.
     */
    data: XOR<VolumesCreateInput, VolumesUncheckedCreateInput>
  }

  /**
   * Volumes createMany
   */
  export type VolumesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Volumes.
     */
    data: VolumesCreateManyInput | VolumesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Volumes update
   */
  export type VolumesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Volumes
     */
    select?: VolumesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Volumes
     */
    omit?: VolumesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VolumesInclude<ExtArgs> | null
    /**
     * The data needed to update a Volumes.
     */
    data: XOR<VolumesUpdateInput, VolumesUncheckedUpdateInput>
    /**
     * Choose, which Volumes to update.
     */
    where: VolumesWhereUniqueInput
  }

  /**
   * Volumes updateMany
   */
  export type VolumesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Volumes.
     */
    data: XOR<VolumesUpdateManyMutationInput, VolumesUncheckedUpdateManyInput>
    /**
     * Filter which Volumes to update
     */
    where?: VolumesWhereInput
    /**
     * Limit how many Volumes to update.
     */
    limit?: number
  }

  /**
   * Volumes upsert
   */
  export type VolumesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Volumes
     */
    select?: VolumesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Volumes
     */
    omit?: VolumesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VolumesInclude<ExtArgs> | null
    /**
     * The filter to search for the Volumes to update in case it exists.
     */
    where: VolumesWhereUniqueInput
    /**
     * In case the Volumes found by the `where` argument doesn't exist, create a new Volumes with this data.
     */
    create: XOR<VolumesCreateInput, VolumesUncheckedCreateInput>
    /**
     * In case the Volumes was found with the provided `where` argument, update it with this data.
     */
    update: XOR<VolumesUpdateInput, VolumesUncheckedUpdateInput>
  }

  /**
   * Volumes delete
   */
  export type VolumesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Volumes
     */
    select?: VolumesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Volumes
     */
    omit?: VolumesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VolumesInclude<ExtArgs> | null
    /**
     * Filter which Volumes to delete.
     */
    where: VolumesWhereUniqueInput
  }

  /**
   * Volumes deleteMany
   */
  export type VolumesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Volumes to delete
     */
    where?: VolumesWhereInput
    /**
     * Limit how many Volumes to delete.
     */
    limit?: number
  }

  /**
   * Volumes.chapters
   */
  export type Volumes$chaptersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chapters
     */
    select?: ChaptersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Chapters
     */
    omit?: ChaptersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChaptersInclude<ExtArgs> | null
    where?: ChaptersWhereInput
    orderBy?: ChaptersOrderByWithRelationInput | ChaptersOrderByWithRelationInput[]
    cursor?: ChaptersWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ChaptersScalarFieldEnum | ChaptersScalarFieldEnum[]
  }

  /**
   * Volumes.unlock_volume
   */
  export type Volumes$unlock_volumeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Unlock_volume
     */
    select?: Unlock_volumeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Unlock_volume
     */
    omit?: Unlock_volumeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Unlock_volumeInclude<ExtArgs> | null
    where?: Unlock_volumeWhereInput
    orderBy?: Unlock_volumeOrderByWithRelationInput | Unlock_volumeOrderByWithRelationInput[]
    cursor?: Unlock_volumeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Unlock_volumeScalarFieldEnum | Unlock_volumeScalarFieldEnum[]
  }

  /**
   * Volumes without action
   */
  export type VolumesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Volumes
     */
    select?: VolumesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Volumes
     */
    omit?: VolumesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VolumesInclude<ExtArgs> | null
  }


  /**
   * Model Chapters
   */

  export type AggregateChapters = {
    _count: ChaptersCountAggregateOutputType | null
    _avg: ChaptersAvgAggregateOutputType | null
    _sum: ChaptersSumAggregateOutputType | null
    _min: ChaptersMinAggregateOutputType | null
    _max: ChaptersMaxAggregateOutputType | null
  }

  export type ChaptersAvgAggregateOutputType = {
    id: number | null
    price: Decimal | null
    volumeId: number | null
  }

  export type ChaptersSumAggregateOutputType = {
    id: number | null
    price: Decimal | null
    volumeId: number | null
  }

  export type ChaptersMinAggregateOutputType = {
    id: number | null
    title: string | null
    filePath: string | null
    content: string | null
    price: Decimal | null
    lock: boolean | null
    volumeId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ChaptersMaxAggregateOutputType = {
    id: number | null
    title: string | null
    filePath: string | null
    content: string | null
    price: Decimal | null
    lock: boolean | null
    volumeId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ChaptersCountAggregateOutputType = {
    id: number
    title: number
    filePath: number
    content: number
    price: number
    lock: number
    volumeId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ChaptersAvgAggregateInputType = {
    id?: true
    price?: true
    volumeId?: true
  }

  export type ChaptersSumAggregateInputType = {
    id?: true
    price?: true
    volumeId?: true
  }

  export type ChaptersMinAggregateInputType = {
    id?: true
    title?: true
    filePath?: true
    content?: true
    price?: true
    lock?: true
    volumeId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ChaptersMaxAggregateInputType = {
    id?: true
    title?: true
    filePath?: true
    content?: true
    price?: true
    lock?: true
    volumeId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ChaptersCountAggregateInputType = {
    id?: true
    title?: true
    filePath?: true
    content?: true
    price?: true
    lock?: true
    volumeId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ChaptersAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Chapters to aggregate.
     */
    where?: ChaptersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Chapters to fetch.
     */
    orderBy?: ChaptersOrderByWithRelationInput | ChaptersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ChaptersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Chapters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Chapters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Chapters
    **/
    _count?: true | ChaptersCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ChaptersAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ChaptersSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ChaptersMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ChaptersMaxAggregateInputType
  }

  export type GetChaptersAggregateType<T extends ChaptersAggregateArgs> = {
        [P in keyof T & keyof AggregateChapters]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateChapters[P]>
      : GetScalarType<T[P], AggregateChapters[P]>
  }




  export type ChaptersGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChaptersWhereInput
    orderBy?: ChaptersOrderByWithAggregationInput | ChaptersOrderByWithAggregationInput[]
    by: ChaptersScalarFieldEnum[] | ChaptersScalarFieldEnum
    having?: ChaptersScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ChaptersCountAggregateInputType | true
    _avg?: ChaptersAvgAggregateInputType
    _sum?: ChaptersSumAggregateInputType
    _min?: ChaptersMinAggregateInputType
    _max?: ChaptersMaxAggregateInputType
  }

  export type ChaptersGroupByOutputType = {
    id: number
    title: string
    filePath: string
    content: string
    price: Decimal
    lock: boolean
    volumeId: number
    createdAt: Date
    updatedAt: Date
    _count: ChaptersCountAggregateOutputType | null
    _avg: ChaptersAvgAggregateOutputType | null
    _sum: ChaptersSumAggregateOutputType | null
    _min: ChaptersMinAggregateOutputType | null
    _max: ChaptersMaxAggregateOutputType | null
  }

  type GetChaptersGroupByPayload<T extends ChaptersGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ChaptersGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ChaptersGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ChaptersGroupByOutputType[P]>
            : GetScalarType<T[P], ChaptersGroupByOutputType[P]>
        }
      >
    >


  export type ChaptersSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    filePath?: boolean
    content?: boolean
    price?: boolean
    lock?: boolean
    volumeId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    volume?: boolean | VolumesDefaultArgs<ExtArgs>
    errors?: boolean | Chapters$errorsArgs<ExtArgs>
    views?: boolean | Chapters$viewsArgs<ExtArgs>
    coments?: boolean | Chapters$comentsArgs<ExtArgs>
    unlock_chapter?: boolean | Chapters$unlock_chapterArgs<ExtArgs>
    _count?: boolean | ChaptersCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["chapters"]>



  export type ChaptersSelectScalar = {
    id?: boolean
    title?: boolean
    filePath?: boolean
    content?: boolean
    price?: boolean
    lock?: boolean
    volumeId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ChaptersOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "title" | "filePath" | "content" | "price" | "lock" | "volumeId" | "createdAt" | "updatedAt", ExtArgs["result"]["chapters"]>
  export type ChaptersInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    volume?: boolean | VolumesDefaultArgs<ExtArgs>
    errors?: boolean | Chapters$errorsArgs<ExtArgs>
    views?: boolean | Chapters$viewsArgs<ExtArgs>
    coments?: boolean | Chapters$comentsArgs<ExtArgs>
    unlock_chapter?: boolean | Chapters$unlock_chapterArgs<ExtArgs>
    _count?: boolean | ChaptersCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $ChaptersPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Chapters"
    objects: {
      volume: Prisma.$VolumesPayload<ExtArgs>
      errors: Prisma.$ErrorsPayload<ExtArgs>[]
      views: Prisma.$ViewsPayload<ExtArgs>[]
      coments: Prisma.$CommentsPayload<ExtArgs>[]
      unlock_chapter: Prisma.$Unlock_chapterPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      title: string
      filePath: string
      content: string
      price: Prisma.Decimal
      lock: boolean
      volumeId: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["chapters"]>
    composites: {}
  }

  type ChaptersGetPayload<S extends boolean | null | undefined | ChaptersDefaultArgs> = $Result.GetResult<Prisma.$ChaptersPayload, S>

  type ChaptersCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ChaptersFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ChaptersCountAggregateInputType | true
    }

  export interface ChaptersDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Chapters'], meta: { name: 'Chapters' } }
    /**
     * Find zero or one Chapters that matches the filter.
     * @param {ChaptersFindUniqueArgs} args - Arguments to find a Chapters
     * @example
     * // Get one Chapters
     * const chapters = await prisma.chapters.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ChaptersFindUniqueArgs>(args: SelectSubset<T, ChaptersFindUniqueArgs<ExtArgs>>): Prisma__ChaptersClient<$Result.GetResult<Prisma.$ChaptersPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Chapters that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ChaptersFindUniqueOrThrowArgs} args - Arguments to find a Chapters
     * @example
     * // Get one Chapters
     * const chapters = await prisma.chapters.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ChaptersFindUniqueOrThrowArgs>(args: SelectSubset<T, ChaptersFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ChaptersClient<$Result.GetResult<Prisma.$ChaptersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Chapters that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChaptersFindFirstArgs} args - Arguments to find a Chapters
     * @example
     * // Get one Chapters
     * const chapters = await prisma.chapters.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ChaptersFindFirstArgs>(args?: SelectSubset<T, ChaptersFindFirstArgs<ExtArgs>>): Prisma__ChaptersClient<$Result.GetResult<Prisma.$ChaptersPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Chapters that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChaptersFindFirstOrThrowArgs} args - Arguments to find a Chapters
     * @example
     * // Get one Chapters
     * const chapters = await prisma.chapters.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ChaptersFindFirstOrThrowArgs>(args?: SelectSubset<T, ChaptersFindFirstOrThrowArgs<ExtArgs>>): Prisma__ChaptersClient<$Result.GetResult<Prisma.$ChaptersPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Chapters that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChaptersFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Chapters
     * const chapters = await prisma.chapters.findMany()
     * 
     * // Get first 10 Chapters
     * const chapters = await prisma.chapters.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const chaptersWithIdOnly = await prisma.chapters.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ChaptersFindManyArgs>(args?: SelectSubset<T, ChaptersFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChaptersPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Chapters.
     * @param {ChaptersCreateArgs} args - Arguments to create a Chapters.
     * @example
     * // Create one Chapters
     * const Chapters = await prisma.chapters.create({
     *   data: {
     *     // ... data to create a Chapters
     *   }
     * })
     * 
     */
    create<T extends ChaptersCreateArgs>(args: SelectSubset<T, ChaptersCreateArgs<ExtArgs>>): Prisma__ChaptersClient<$Result.GetResult<Prisma.$ChaptersPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Chapters.
     * @param {ChaptersCreateManyArgs} args - Arguments to create many Chapters.
     * @example
     * // Create many Chapters
     * const chapters = await prisma.chapters.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ChaptersCreateManyArgs>(args?: SelectSubset<T, ChaptersCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Chapters.
     * @param {ChaptersDeleteArgs} args - Arguments to delete one Chapters.
     * @example
     * // Delete one Chapters
     * const Chapters = await prisma.chapters.delete({
     *   where: {
     *     // ... filter to delete one Chapters
     *   }
     * })
     * 
     */
    delete<T extends ChaptersDeleteArgs>(args: SelectSubset<T, ChaptersDeleteArgs<ExtArgs>>): Prisma__ChaptersClient<$Result.GetResult<Prisma.$ChaptersPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Chapters.
     * @param {ChaptersUpdateArgs} args - Arguments to update one Chapters.
     * @example
     * // Update one Chapters
     * const chapters = await prisma.chapters.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ChaptersUpdateArgs>(args: SelectSubset<T, ChaptersUpdateArgs<ExtArgs>>): Prisma__ChaptersClient<$Result.GetResult<Prisma.$ChaptersPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Chapters.
     * @param {ChaptersDeleteManyArgs} args - Arguments to filter Chapters to delete.
     * @example
     * // Delete a few Chapters
     * const { count } = await prisma.chapters.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ChaptersDeleteManyArgs>(args?: SelectSubset<T, ChaptersDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Chapters.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChaptersUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Chapters
     * const chapters = await prisma.chapters.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ChaptersUpdateManyArgs>(args: SelectSubset<T, ChaptersUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Chapters.
     * @param {ChaptersUpsertArgs} args - Arguments to update or create a Chapters.
     * @example
     * // Update or create a Chapters
     * const chapters = await prisma.chapters.upsert({
     *   create: {
     *     // ... data to create a Chapters
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Chapters we want to update
     *   }
     * })
     */
    upsert<T extends ChaptersUpsertArgs>(args: SelectSubset<T, ChaptersUpsertArgs<ExtArgs>>): Prisma__ChaptersClient<$Result.GetResult<Prisma.$ChaptersPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Chapters.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChaptersCountArgs} args - Arguments to filter Chapters to count.
     * @example
     * // Count the number of Chapters
     * const count = await prisma.chapters.count({
     *   where: {
     *     // ... the filter for the Chapters we want to count
     *   }
     * })
    **/
    count<T extends ChaptersCountArgs>(
      args?: Subset<T, ChaptersCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ChaptersCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Chapters.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChaptersAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ChaptersAggregateArgs>(args: Subset<T, ChaptersAggregateArgs>): Prisma.PrismaPromise<GetChaptersAggregateType<T>>

    /**
     * Group by Chapters.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChaptersGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ChaptersGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ChaptersGroupByArgs['orderBy'] }
        : { orderBy?: ChaptersGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ChaptersGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetChaptersGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Chapters model
   */
  readonly fields: ChaptersFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Chapters.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ChaptersClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    volume<T extends VolumesDefaultArgs<ExtArgs> = {}>(args?: Subset<T, VolumesDefaultArgs<ExtArgs>>): Prisma__VolumesClient<$Result.GetResult<Prisma.$VolumesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    errors<T extends Chapters$errorsArgs<ExtArgs> = {}>(args?: Subset<T, Chapters$errorsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ErrorsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    views<T extends Chapters$viewsArgs<ExtArgs> = {}>(args?: Subset<T, Chapters$viewsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ViewsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    coments<T extends Chapters$comentsArgs<ExtArgs> = {}>(args?: Subset<T, Chapters$comentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommentsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    unlock_chapter<T extends Chapters$unlock_chapterArgs<ExtArgs> = {}>(args?: Subset<T, Chapters$unlock_chapterArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$Unlock_chapterPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Chapters model
   */
  interface ChaptersFieldRefs {
    readonly id: FieldRef<"Chapters", 'Int'>
    readonly title: FieldRef<"Chapters", 'String'>
    readonly filePath: FieldRef<"Chapters", 'String'>
    readonly content: FieldRef<"Chapters", 'String'>
    readonly price: FieldRef<"Chapters", 'Decimal'>
    readonly lock: FieldRef<"Chapters", 'Boolean'>
    readonly volumeId: FieldRef<"Chapters", 'Int'>
    readonly createdAt: FieldRef<"Chapters", 'DateTime'>
    readonly updatedAt: FieldRef<"Chapters", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Chapters findUnique
   */
  export type ChaptersFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chapters
     */
    select?: ChaptersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Chapters
     */
    omit?: ChaptersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChaptersInclude<ExtArgs> | null
    /**
     * Filter, which Chapters to fetch.
     */
    where: ChaptersWhereUniqueInput
  }

  /**
   * Chapters findUniqueOrThrow
   */
  export type ChaptersFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chapters
     */
    select?: ChaptersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Chapters
     */
    omit?: ChaptersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChaptersInclude<ExtArgs> | null
    /**
     * Filter, which Chapters to fetch.
     */
    where: ChaptersWhereUniqueInput
  }

  /**
   * Chapters findFirst
   */
  export type ChaptersFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chapters
     */
    select?: ChaptersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Chapters
     */
    omit?: ChaptersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChaptersInclude<ExtArgs> | null
    /**
     * Filter, which Chapters to fetch.
     */
    where?: ChaptersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Chapters to fetch.
     */
    orderBy?: ChaptersOrderByWithRelationInput | ChaptersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Chapters.
     */
    cursor?: ChaptersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Chapters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Chapters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Chapters.
     */
    distinct?: ChaptersScalarFieldEnum | ChaptersScalarFieldEnum[]
  }

  /**
   * Chapters findFirstOrThrow
   */
  export type ChaptersFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chapters
     */
    select?: ChaptersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Chapters
     */
    omit?: ChaptersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChaptersInclude<ExtArgs> | null
    /**
     * Filter, which Chapters to fetch.
     */
    where?: ChaptersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Chapters to fetch.
     */
    orderBy?: ChaptersOrderByWithRelationInput | ChaptersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Chapters.
     */
    cursor?: ChaptersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Chapters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Chapters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Chapters.
     */
    distinct?: ChaptersScalarFieldEnum | ChaptersScalarFieldEnum[]
  }

  /**
   * Chapters findMany
   */
  export type ChaptersFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chapters
     */
    select?: ChaptersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Chapters
     */
    omit?: ChaptersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChaptersInclude<ExtArgs> | null
    /**
     * Filter, which Chapters to fetch.
     */
    where?: ChaptersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Chapters to fetch.
     */
    orderBy?: ChaptersOrderByWithRelationInput | ChaptersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Chapters.
     */
    cursor?: ChaptersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Chapters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Chapters.
     */
    skip?: number
    distinct?: ChaptersScalarFieldEnum | ChaptersScalarFieldEnum[]
  }

  /**
   * Chapters create
   */
  export type ChaptersCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chapters
     */
    select?: ChaptersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Chapters
     */
    omit?: ChaptersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChaptersInclude<ExtArgs> | null
    /**
     * The data needed to create a Chapters.
     */
    data: XOR<ChaptersCreateInput, ChaptersUncheckedCreateInput>
  }

  /**
   * Chapters createMany
   */
  export type ChaptersCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Chapters.
     */
    data: ChaptersCreateManyInput | ChaptersCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Chapters update
   */
  export type ChaptersUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chapters
     */
    select?: ChaptersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Chapters
     */
    omit?: ChaptersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChaptersInclude<ExtArgs> | null
    /**
     * The data needed to update a Chapters.
     */
    data: XOR<ChaptersUpdateInput, ChaptersUncheckedUpdateInput>
    /**
     * Choose, which Chapters to update.
     */
    where: ChaptersWhereUniqueInput
  }

  /**
   * Chapters updateMany
   */
  export type ChaptersUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Chapters.
     */
    data: XOR<ChaptersUpdateManyMutationInput, ChaptersUncheckedUpdateManyInput>
    /**
     * Filter which Chapters to update
     */
    where?: ChaptersWhereInput
    /**
     * Limit how many Chapters to update.
     */
    limit?: number
  }

  /**
   * Chapters upsert
   */
  export type ChaptersUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chapters
     */
    select?: ChaptersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Chapters
     */
    omit?: ChaptersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChaptersInclude<ExtArgs> | null
    /**
     * The filter to search for the Chapters to update in case it exists.
     */
    where: ChaptersWhereUniqueInput
    /**
     * In case the Chapters found by the `where` argument doesn't exist, create a new Chapters with this data.
     */
    create: XOR<ChaptersCreateInput, ChaptersUncheckedCreateInput>
    /**
     * In case the Chapters was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ChaptersUpdateInput, ChaptersUncheckedUpdateInput>
  }

  /**
   * Chapters delete
   */
  export type ChaptersDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chapters
     */
    select?: ChaptersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Chapters
     */
    omit?: ChaptersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChaptersInclude<ExtArgs> | null
    /**
     * Filter which Chapters to delete.
     */
    where: ChaptersWhereUniqueInput
  }

  /**
   * Chapters deleteMany
   */
  export type ChaptersDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Chapters to delete
     */
    where?: ChaptersWhereInput
    /**
     * Limit how many Chapters to delete.
     */
    limit?: number
  }

  /**
   * Chapters.errors
   */
  export type Chapters$errorsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Errors
     */
    select?: ErrorsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Errors
     */
    omit?: ErrorsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ErrorsInclude<ExtArgs> | null
    where?: ErrorsWhereInput
    orderBy?: ErrorsOrderByWithRelationInput | ErrorsOrderByWithRelationInput[]
    cursor?: ErrorsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ErrorsScalarFieldEnum | ErrorsScalarFieldEnum[]
  }

  /**
   * Chapters.views
   */
  export type Chapters$viewsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Views
     */
    select?: ViewsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Views
     */
    omit?: ViewsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ViewsInclude<ExtArgs> | null
    where?: ViewsWhereInput
    orderBy?: ViewsOrderByWithRelationInput | ViewsOrderByWithRelationInput[]
    cursor?: ViewsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ViewsScalarFieldEnum | ViewsScalarFieldEnum[]
  }

  /**
   * Chapters.coments
   */
  export type Chapters$comentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comments
     */
    select?: CommentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comments
     */
    omit?: CommentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentsInclude<ExtArgs> | null
    where?: CommentsWhereInput
    orderBy?: CommentsOrderByWithRelationInput | CommentsOrderByWithRelationInput[]
    cursor?: CommentsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CommentsScalarFieldEnum | CommentsScalarFieldEnum[]
  }

  /**
   * Chapters.unlock_chapter
   */
  export type Chapters$unlock_chapterArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Unlock_chapter
     */
    select?: Unlock_chapterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Unlock_chapter
     */
    omit?: Unlock_chapterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Unlock_chapterInclude<ExtArgs> | null
    where?: Unlock_chapterWhereInput
    orderBy?: Unlock_chapterOrderByWithRelationInput | Unlock_chapterOrderByWithRelationInput[]
    cursor?: Unlock_chapterWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Unlock_chapterScalarFieldEnum | Unlock_chapterScalarFieldEnum[]
  }

  /**
   * Chapters without action
   */
  export type ChaptersDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chapters
     */
    select?: ChaptersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Chapters
     */
    omit?: ChaptersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChaptersInclude<ExtArgs> | null
  }


  /**
   * Model Roles
   */

  export type AggregateRoles = {
    _count: RolesCountAggregateOutputType | null
    _avg: RolesAvgAggregateOutputType | null
    _sum: RolesSumAggregateOutputType | null
    _min: RolesMinAggregateOutputType | null
    _max: RolesMaxAggregateOutputType | null
  }

  export type RolesAvgAggregateOutputType = {
    id: number | null
  }

  export type RolesSumAggregateOutputType = {
    id: number | null
  }

  export type RolesMinAggregateOutputType = {
    id: number | null
    title: string | null
    description: string | null
  }

  export type RolesMaxAggregateOutputType = {
    id: number | null
    title: string | null
    description: string | null
  }

  export type RolesCountAggregateOutputType = {
    id: number
    title: number
    description: number
    _all: number
  }


  export type RolesAvgAggregateInputType = {
    id?: true
  }

  export type RolesSumAggregateInputType = {
    id?: true
  }

  export type RolesMinAggregateInputType = {
    id?: true
    title?: true
    description?: true
  }

  export type RolesMaxAggregateInputType = {
    id?: true
    title?: true
    description?: true
  }

  export type RolesCountAggregateInputType = {
    id?: true
    title?: true
    description?: true
    _all?: true
  }

  export type RolesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Roles to aggregate.
     */
    where?: RolesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Roles to fetch.
     */
    orderBy?: RolesOrderByWithRelationInput | RolesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RolesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Roles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Roles
    **/
    _count?: true | RolesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RolesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RolesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RolesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RolesMaxAggregateInputType
  }

  export type GetRolesAggregateType<T extends RolesAggregateArgs> = {
        [P in keyof T & keyof AggregateRoles]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRoles[P]>
      : GetScalarType<T[P], AggregateRoles[P]>
  }




  export type RolesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RolesWhereInput
    orderBy?: RolesOrderByWithAggregationInput | RolesOrderByWithAggregationInput[]
    by: RolesScalarFieldEnum[] | RolesScalarFieldEnum
    having?: RolesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RolesCountAggregateInputType | true
    _avg?: RolesAvgAggregateInputType
    _sum?: RolesSumAggregateInputType
    _min?: RolesMinAggregateInputType
    _max?: RolesMaxAggregateInputType
  }

  export type RolesGroupByOutputType = {
    id: number
    title: string
    description: string
    _count: RolesCountAggregateOutputType | null
    _avg: RolesAvgAggregateOutputType | null
    _sum: RolesSumAggregateOutputType | null
    _min: RolesMinAggregateOutputType | null
    _max: RolesMaxAggregateOutputType | null
  }

  type GetRolesGroupByPayload<T extends RolesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RolesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RolesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RolesGroupByOutputType[P]>
            : GetScalarType<T[P], RolesGroupByOutputType[P]>
        }
      >
    >


  export type RolesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    users?: boolean | Roles$usersArgs<ExtArgs>
    _count?: boolean | RolesCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["roles"]>



  export type RolesSelectScalar = {
    id?: boolean
    title?: boolean
    description?: boolean
  }

  export type RolesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "title" | "description", ExtArgs["result"]["roles"]>
  export type RolesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | Roles$usersArgs<ExtArgs>
    _count?: boolean | RolesCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $RolesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Roles"
    objects: {
      users: Prisma.$UsersPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      title: string
      description: string
    }, ExtArgs["result"]["roles"]>
    composites: {}
  }

  type RolesGetPayload<S extends boolean | null | undefined | RolesDefaultArgs> = $Result.GetResult<Prisma.$RolesPayload, S>

  type RolesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<RolesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RolesCountAggregateInputType | true
    }

  export interface RolesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Roles'], meta: { name: 'Roles' } }
    /**
     * Find zero or one Roles that matches the filter.
     * @param {RolesFindUniqueArgs} args - Arguments to find a Roles
     * @example
     * // Get one Roles
     * const roles = await prisma.roles.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RolesFindUniqueArgs>(args: SelectSubset<T, RolesFindUniqueArgs<ExtArgs>>): Prisma__RolesClient<$Result.GetResult<Prisma.$RolesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Roles that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RolesFindUniqueOrThrowArgs} args - Arguments to find a Roles
     * @example
     * // Get one Roles
     * const roles = await prisma.roles.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RolesFindUniqueOrThrowArgs>(args: SelectSubset<T, RolesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RolesClient<$Result.GetResult<Prisma.$RolesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Roles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolesFindFirstArgs} args - Arguments to find a Roles
     * @example
     * // Get one Roles
     * const roles = await prisma.roles.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RolesFindFirstArgs>(args?: SelectSubset<T, RolesFindFirstArgs<ExtArgs>>): Prisma__RolesClient<$Result.GetResult<Prisma.$RolesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Roles that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolesFindFirstOrThrowArgs} args - Arguments to find a Roles
     * @example
     * // Get one Roles
     * const roles = await prisma.roles.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RolesFindFirstOrThrowArgs>(args?: SelectSubset<T, RolesFindFirstOrThrowArgs<ExtArgs>>): Prisma__RolesClient<$Result.GetResult<Prisma.$RolesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Roles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Roles
     * const roles = await prisma.roles.findMany()
     * 
     * // Get first 10 Roles
     * const roles = await prisma.roles.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const rolesWithIdOnly = await prisma.roles.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RolesFindManyArgs>(args?: SelectSubset<T, RolesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RolesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Roles.
     * @param {RolesCreateArgs} args - Arguments to create a Roles.
     * @example
     * // Create one Roles
     * const Roles = await prisma.roles.create({
     *   data: {
     *     // ... data to create a Roles
     *   }
     * })
     * 
     */
    create<T extends RolesCreateArgs>(args: SelectSubset<T, RolesCreateArgs<ExtArgs>>): Prisma__RolesClient<$Result.GetResult<Prisma.$RolesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Roles.
     * @param {RolesCreateManyArgs} args - Arguments to create many Roles.
     * @example
     * // Create many Roles
     * const roles = await prisma.roles.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RolesCreateManyArgs>(args?: SelectSubset<T, RolesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Roles.
     * @param {RolesDeleteArgs} args - Arguments to delete one Roles.
     * @example
     * // Delete one Roles
     * const Roles = await prisma.roles.delete({
     *   where: {
     *     // ... filter to delete one Roles
     *   }
     * })
     * 
     */
    delete<T extends RolesDeleteArgs>(args: SelectSubset<T, RolesDeleteArgs<ExtArgs>>): Prisma__RolesClient<$Result.GetResult<Prisma.$RolesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Roles.
     * @param {RolesUpdateArgs} args - Arguments to update one Roles.
     * @example
     * // Update one Roles
     * const roles = await prisma.roles.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RolesUpdateArgs>(args: SelectSubset<T, RolesUpdateArgs<ExtArgs>>): Prisma__RolesClient<$Result.GetResult<Prisma.$RolesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Roles.
     * @param {RolesDeleteManyArgs} args - Arguments to filter Roles to delete.
     * @example
     * // Delete a few Roles
     * const { count } = await prisma.roles.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RolesDeleteManyArgs>(args?: SelectSubset<T, RolesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Roles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Roles
     * const roles = await prisma.roles.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RolesUpdateManyArgs>(args: SelectSubset<T, RolesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Roles.
     * @param {RolesUpsertArgs} args - Arguments to update or create a Roles.
     * @example
     * // Update or create a Roles
     * const roles = await prisma.roles.upsert({
     *   create: {
     *     // ... data to create a Roles
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Roles we want to update
     *   }
     * })
     */
    upsert<T extends RolesUpsertArgs>(args: SelectSubset<T, RolesUpsertArgs<ExtArgs>>): Prisma__RolesClient<$Result.GetResult<Prisma.$RolesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Roles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolesCountArgs} args - Arguments to filter Roles to count.
     * @example
     * // Count the number of Roles
     * const count = await prisma.roles.count({
     *   where: {
     *     // ... the filter for the Roles we want to count
     *   }
     * })
    **/
    count<T extends RolesCountArgs>(
      args?: Subset<T, RolesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RolesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Roles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RolesAggregateArgs>(args: Subset<T, RolesAggregateArgs>): Prisma.PrismaPromise<GetRolesAggregateType<T>>

    /**
     * Group by Roles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RolesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RolesGroupByArgs['orderBy'] }
        : { orderBy?: RolesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RolesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRolesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Roles model
   */
  readonly fields: RolesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Roles.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RolesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    users<T extends Roles$usersArgs<ExtArgs> = {}>(args?: Subset<T, Roles$usersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UsersPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Roles model
   */
  interface RolesFieldRefs {
    readonly id: FieldRef<"Roles", 'Int'>
    readonly title: FieldRef<"Roles", 'String'>
    readonly description: FieldRef<"Roles", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Roles findUnique
   */
  export type RolesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Roles
     */
    select?: RolesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Roles
     */
    omit?: RolesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolesInclude<ExtArgs> | null
    /**
     * Filter, which Roles to fetch.
     */
    where: RolesWhereUniqueInput
  }

  /**
   * Roles findUniqueOrThrow
   */
  export type RolesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Roles
     */
    select?: RolesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Roles
     */
    omit?: RolesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolesInclude<ExtArgs> | null
    /**
     * Filter, which Roles to fetch.
     */
    where: RolesWhereUniqueInput
  }

  /**
   * Roles findFirst
   */
  export type RolesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Roles
     */
    select?: RolesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Roles
     */
    omit?: RolesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolesInclude<ExtArgs> | null
    /**
     * Filter, which Roles to fetch.
     */
    where?: RolesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Roles to fetch.
     */
    orderBy?: RolesOrderByWithRelationInput | RolesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Roles.
     */
    cursor?: RolesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Roles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Roles.
     */
    distinct?: RolesScalarFieldEnum | RolesScalarFieldEnum[]
  }

  /**
   * Roles findFirstOrThrow
   */
  export type RolesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Roles
     */
    select?: RolesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Roles
     */
    omit?: RolesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolesInclude<ExtArgs> | null
    /**
     * Filter, which Roles to fetch.
     */
    where?: RolesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Roles to fetch.
     */
    orderBy?: RolesOrderByWithRelationInput | RolesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Roles.
     */
    cursor?: RolesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Roles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Roles.
     */
    distinct?: RolesScalarFieldEnum | RolesScalarFieldEnum[]
  }

  /**
   * Roles findMany
   */
  export type RolesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Roles
     */
    select?: RolesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Roles
     */
    omit?: RolesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolesInclude<ExtArgs> | null
    /**
     * Filter, which Roles to fetch.
     */
    where?: RolesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Roles to fetch.
     */
    orderBy?: RolesOrderByWithRelationInput | RolesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Roles.
     */
    cursor?: RolesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Roles.
     */
    skip?: number
    distinct?: RolesScalarFieldEnum | RolesScalarFieldEnum[]
  }

  /**
   * Roles create
   */
  export type RolesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Roles
     */
    select?: RolesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Roles
     */
    omit?: RolesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolesInclude<ExtArgs> | null
    /**
     * The data needed to create a Roles.
     */
    data: XOR<RolesCreateInput, RolesUncheckedCreateInput>
  }

  /**
   * Roles createMany
   */
  export type RolesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Roles.
     */
    data: RolesCreateManyInput | RolesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Roles update
   */
  export type RolesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Roles
     */
    select?: RolesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Roles
     */
    omit?: RolesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolesInclude<ExtArgs> | null
    /**
     * The data needed to update a Roles.
     */
    data: XOR<RolesUpdateInput, RolesUncheckedUpdateInput>
    /**
     * Choose, which Roles to update.
     */
    where: RolesWhereUniqueInput
  }

  /**
   * Roles updateMany
   */
  export type RolesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Roles.
     */
    data: XOR<RolesUpdateManyMutationInput, RolesUncheckedUpdateManyInput>
    /**
     * Filter which Roles to update
     */
    where?: RolesWhereInput
    /**
     * Limit how many Roles to update.
     */
    limit?: number
  }

  /**
   * Roles upsert
   */
  export type RolesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Roles
     */
    select?: RolesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Roles
     */
    omit?: RolesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolesInclude<ExtArgs> | null
    /**
     * The filter to search for the Roles to update in case it exists.
     */
    where: RolesWhereUniqueInput
    /**
     * In case the Roles found by the `where` argument doesn't exist, create a new Roles with this data.
     */
    create: XOR<RolesCreateInput, RolesUncheckedCreateInput>
    /**
     * In case the Roles was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RolesUpdateInput, RolesUncheckedUpdateInput>
  }

  /**
   * Roles delete
   */
  export type RolesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Roles
     */
    select?: RolesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Roles
     */
    omit?: RolesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolesInclude<ExtArgs> | null
    /**
     * Filter which Roles to delete.
     */
    where: RolesWhereUniqueInput
  }

  /**
   * Roles deleteMany
   */
  export type RolesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Roles to delete
     */
    where?: RolesWhereInput
    /**
     * Limit how many Roles to delete.
     */
    limit?: number
  }

  /**
   * Roles.users
   */
  export type Roles$usersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Users
     */
    select?: UsersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Users
     */
    omit?: UsersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsersInclude<ExtArgs> | null
    where?: UsersWhereInput
    orderBy?: UsersOrderByWithRelationInput | UsersOrderByWithRelationInput[]
    cursor?: UsersWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UsersScalarFieldEnum | UsersScalarFieldEnum[]
  }

  /**
   * Roles without action
   */
  export type RolesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Roles
     */
    select?: RolesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Roles
     */
    omit?: RolesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolesInclude<ExtArgs> | null
  }


  /**
   * Model Users
   */

  export type AggregateUsers = {
    _count: UsersCountAggregateOutputType | null
    _avg: UsersAvgAggregateOutputType | null
    _sum: UsersSumAggregateOutputType | null
    _min: UsersMinAggregateOutputType | null
    _max: UsersMaxAggregateOutputType | null
  }

  export type UsersAvgAggregateOutputType = {
    id: number | null
  }

  export type UsersSumAggregateOutputType = {
    id: number | null
  }

  export type UsersMinAggregateOutputType = {
    id: number | null
    name: string | null
    email: string | null
    password: string | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
    isDisabled: boolean | null
  }

  export type UsersMaxAggregateOutputType = {
    id: number | null
    name: string | null
    email: string | null
    password: string | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
    isDisabled: boolean | null
  }

  export type UsersCountAggregateOutputType = {
    id: number
    name: number
    email: number
    password: number
    description: number
    createdAt: number
    updatedAt: number
    isDisabled: number
    _all: number
  }


  export type UsersAvgAggregateInputType = {
    id?: true
  }

  export type UsersSumAggregateInputType = {
    id?: true
  }

  export type UsersMinAggregateInputType = {
    id?: true
    name?: true
    email?: true
    password?: true
    description?: true
    createdAt?: true
    updatedAt?: true
    isDisabled?: true
  }

  export type UsersMaxAggregateInputType = {
    id?: true
    name?: true
    email?: true
    password?: true
    description?: true
    createdAt?: true
    updatedAt?: true
    isDisabled?: true
  }

  export type UsersCountAggregateInputType = {
    id?: true
    name?: true
    email?: true
    password?: true
    description?: true
    createdAt?: true
    updatedAt?: true
    isDisabled?: true
    _all?: true
  }

  export type UsersAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to aggregate.
     */
    where?: UsersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UsersOrderByWithRelationInput | UsersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UsersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UsersCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UsersAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UsersSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UsersMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UsersMaxAggregateInputType
  }

  export type GetUsersAggregateType<T extends UsersAggregateArgs> = {
        [P in keyof T & keyof AggregateUsers]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUsers[P]>
      : GetScalarType<T[P], AggregateUsers[P]>
  }




  export type UsersGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UsersWhereInput
    orderBy?: UsersOrderByWithAggregationInput | UsersOrderByWithAggregationInput[]
    by: UsersScalarFieldEnum[] | UsersScalarFieldEnum
    having?: UsersScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UsersCountAggregateInputType | true
    _avg?: UsersAvgAggregateInputType
    _sum?: UsersSumAggregateInputType
    _min?: UsersMinAggregateInputType
    _max?: UsersMaxAggregateInputType
  }

  export type UsersGroupByOutputType = {
    id: number
    name: string
    email: string
    password: string
    description: string
    createdAt: Date
    updatedAt: Date
    isDisabled: boolean
    _count: UsersCountAggregateOutputType | null
    _avg: UsersAvgAggregateOutputType | null
    _sum: UsersSumAggregateOutputType | null
    _min: UsersMinAggregateOutputType | null
    _max: UsersMaxAggregateOutputType | null
  }

  type GetUsersGroupByPayload<T extends UsersGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UsersGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UsersGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UsersGroupByOutputType[P]>
            : GetScalarType<T[P], UsersGroupByOutputType[P]>
        }
      >
    >


  export type UsersSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    password?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    isDisabled?: boolean
    comics?: boolean | Users$comicsArgs<ExtArgs>
    userRole?: boolean | Users$userRoleArgs<ExtArgs>
    favorites?: boolean | Users$favoritesArgs<ExtArgs>
    rates?: boolean | Users$ratesArgs<ExtArgs>
    errors?: boolean | Users$errorsArgs<ExtArgs>
    views?: boolean | Users$viewsArgs<ExtArgs>
    coments?: boolean | Users$comentsArgs<ExtArgs>
    notifications?: boolean | Users$notificationsArgs<ExtArgs>
    wallets?: boolean | Users$walletsArgs<ExtArgs>
    unlock_comic?: boolean | Users$unlock_comicArgs<ExtArgs>
    unlock_volume?: boolean | Users$unlock_volumeArgs<ExtArgs>
    unlock_chapter?: boolean | Users$unlock_chapterArgs<ExtArgs>
    _count?: boolean | UsersCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["users"]>



  export type UsersSelectScalar = {
    id?: boolean
    name?: boolean
    email?: boolean
    password?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    isDisabled?: boolean
  }

  export type UsersOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "email" | "password" | "description" | "createdAt" | "updatedAt" | "isDisabled", ExtArgs["result"]["users"]>
  export type UsersInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    comics?: boolean | Users$comicsArgs<ExtArgs>
    userRole?: boolean | Users$userRoleArgs<ExtArgs>
    favorites?: boolean | Users$favoritesArgs<ExtArgs>
    rates?: boolean | Users$ratesArgs<ExtArgs>
    errors?: boolean | Users$errorsArgs<ExtArgs>
    views?: boolean | Users$viewsArgs<ExtArgs>
    coments?: boolean | Users$comentsArgs<ExtArgs>
    notifications?: boolean | Users$notificationsArgs<ExtArgs>
    wallets?: boolean | Users$walletsArgs<ExtArgs>
    unlock_comic?: boolean | Users$unlock_comicArgs<ExtArgs>
    unlock_volume?: boolean | Users$unlock_volumeArgs<ExtArgs>
    unlock_chapter?: boolean | Users$unlock_chapterArgs<ExtArgs>
    _count?: boolean | UsersCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $UsersPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Users"
    objects: {
      comics: Prisma.$ComicsPayload<ExtArgs>[]
      userRole: Prisma.$RolesPayload<ExtArgs>[]
      favorites: Prisma.$FavoritesPayload<ExtArgs>[]
      rates: Prisma.$RatesPayload<ExtArgs>[]
      errors: Prisma.$ErrorsPayload<ExtArgs>[]
      views: Prisma.$ViewsPayload<ExtArgs>[]
      coments: Prisma.$CommentsPayload<ExtArgs>[]
      notifications: Prisma.$NotificationsPayload<ExtArgs>[]
      wallets: Prisma.$WalletsPayload<ExtArgs> | null
      unlock_comic: Prisma.$Unlock_comicPayload<ExtArgs>[]
      unlock_volume: Prisma.$Unlock_volumePayload<ExtArgs>[]
      unlock_chapter: Prisma.$Unlock_chapterPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      email: string
      password: string
      description: string
      createdAt: Date
      updatedAt: Date
      isDisabled: boolean
    }, ExtArgs["result"]["users"]>
    composites: {}
  }

  type UsersGetPayload<S extends boolean | null | undefined | UsersDefaultArgs> = $Result.GetResult<Prisma.$UsersPayload, S>

  type UsersCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UsersFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UsersCountAggregateInputType | true
    }

  export interface UsersDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Users'], meta: { name: 'Users' } }
    /**
     * Find zero or one Users that matches the filter.
     * @param {UsersFindUniqueArgs} args - Arguments to find a Users
     * @example
     * // Get one Users
     * const users = await prisma.users.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UsersFindUniqueArgs>(args: SelectSubset<T, UsersFindUniqueArgs<ExtArgs>>): Prisma__UsersClient<$Result.GetResult<Prisma.$UsersPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Users that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UsersFindUniqueOrThrowArgs} args - Arguments to find a Users
     * @example
     * // Get one Users
     * const users = await prisma.users.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UsersFindUniqueOrThrowArgs>(args: SelectSubset<T, UsersFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UsersClient<$Result.GetResult<Prisma.$UsersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsersFindFirstArgs} args - Arguments to find a Users
     * @example
     * // Get one Users
     * const users = await prisma.users.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UsersFindFirstArgs>(args?: SelectSubset<T, UsersFindFirstArgs<ExtArgs>>): Prisma__UsersClient<$Result.GetResult<Prisma.$UsersPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Users that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsersFindFirstOrThrowArgs} args - Arguments to find a Users
     * @example
     * // Get one Users
     * const users = await prisma.users.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UsersFindFirstOrThrowArgs>(args?: SelectSubset<T, UsersFindFirstOrThrowArgs<ExtArgs>>): Prisma__UsersClient<$Result.GetResult<Prisma.$UsersPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsersFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.users.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.users.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const usersWithIdOnly = await prisma.users.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UsersFindManyArgs>(args?: SelectSubset<T, UsersFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UsersPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Users.
     * @param {UsersCreateArgs} args - Arguments to create a Users.
     * @example
     * // Create one Users
     * const Users = await prisma.users.create({
     *   data: {
     *     // ... data to create a Users
     *   }
     * })
     * 
     */
    create<T extends UsersCreateArgs>(args: SelectSubset<T, UsersCreateArgs<ExtArgs>>): Prisma__UsersClient<$Result.GetResult<Prisma.$UsersPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {UsersCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const users = await prisma.users.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UsersCreateManyArgs>(args?: SelectSubset<T, UsersCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Users.
     * @param {UsersDeleteArgs} args - Arguments to delete one Users.
     * @example
     * // Delete one Users
     * const Users = await prisma.users.delete({
     *   where: {
     *     // ... filter to delete one Users
     *   }
     * })
     * 
     */
    delete<T extends UsersDeleteArgs>(args: SelectSubset<T, UsersDeleteArgs<ExtArgs>>): Prisma__UsersClient<$Result.GetResult<Prisma.$UsersPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Users.
     * @param {UsersUpdateArgs} args - Arguments to update one Users.
     * @example
     * // Update one Users
     * const users = await prisma.users.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UsersUpdateArgs>(args: SelectSubset<T, UsersUpdateArgs<ExtArgs>>): Prisma__UsersClient<$Result.GetResult<Prisma.$UsersPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {UsersDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.users.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UsersDeleteManyArgs>(args?: SelectSubset<T, UsersDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsersUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const users = await prisma.users.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UsersUpdateManyArgs>(args: SelectSubset<T, UsersUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Users.
     * @param {UsersUpsertArgs} args - Arguments to update or create a Users.
     * @example
     * // Update or create a Users
     * const users = await prisma.users.upsert({
     *   create: {
     *     // ... data to create a Users
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Users we want to update
     *   }
     * })
     */
    upsert<T extends UsersUpsertArgs>(args: SelectSubset<T, UsersUpsertArgs<ExtArgs>>): Prisma__UsersClient<$Result.GetResult<Prisma.$UsersPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsersCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.users.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UsersCountArgs>(
      args?: Subset<T, UsersCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UsersCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsersAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UsersAggregateArgs>(args: Subset<T, UsersAggregateArgs>): Prisma.PrismaPromise<GetUsersAggregateType<T>>

    /**
     * Group by Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsersGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UsersGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UsersGroupByArgs['orderBy'] }
        : { orderBy?: UsersGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UsersGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUsersGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Users model
   */
  readonly fields: UsersFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Users.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UsersClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    comics<T extends Users$comicsArgs<ExtArgs> = {}>(args?: Subset<T, Users$comicsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ComicsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    userRole<T extends Users$userRoleArgs<ExtArgs> = {}>(args?: Subset<T, Users$userRoleArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RolesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    favorites<T extends Users$favoritesArgs<ExtArgs> = {}>(args?: Subset<T, Users$favoritesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FavoritesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    rates<T extends Users$ratesArgs<ExtArgs> = {}>(args?: Subset<T, Users$ratesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RatesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    errors<T extends Users$errorsArgs<ExtArgs> = {}>(args?: Subset<T, Users$errorsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ErrorsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    views<T extends Users$viewsArgs<ExtArgs> = {}>(args?: Subset<T, Users$viewsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ViewsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    coments<T extends Users$comentsArgs<ExtArgs> = {}>(args?: Subset<T, Users$comentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommentsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    notifications<T extends Users$notificationsArgs<ExtArgs> = {}>(args?: Subset<T, Users$notificationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    wallets<T extends Users$walletsArgs<ExtArgs> = {}>(args?: Subset<T, Users$walletsArgs<ExtArgs>>): Prisma__WalletsClient<$Result.GetResult<Prisma.$WalletsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    unlock_comic<T extends Users$unlock_comicArgs<ExtArgs> = {}>(args?: Subset<T, Users$unlock_comicArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$Unlock_comicPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    unlock_volume<T extends Users$unlock_volumeArgs<ExtArgs> = {}>(args?: Subset<T, Users$unlock_volumeArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$Unlock_volumePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    unlock_chapter<T extends Users$unlock_chapterArgs<ExtArgs> = {}>(args?: Subset<T, Users$unlock_chapterArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$Unlock_chapterPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Users model
   */
  interface UsersFieldRefs {
    readonly id: FieldRef<"Users", 'Int'>
    readonly name: FieldRef<"Users", 'String'>
    readonly email: FieldRef<"Users", 'String'>
    readonly password: FieldRef<"Users", 'String'>
    readonly description: FieldRef<"Users", 'String'>
    readonly createdAt: FieldRef<"Users", 'DateTime'>
    readonly updatedAt: FieldRef<"Users", 'DateTime'>
    readonly isDisabled: FieldRef<"Users", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * Users findUnique
   */
  export type UsersFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Users
     */
    select?: UsersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Users
     */
    omit?: UsersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsersInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where: UsersWhereUniqueInput
  }

  /**
   * Users findUniqueOrThrow
   */
  export type UsersFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Users
     */
    select?: UsersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Users
     */
    omit?: UsersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsersInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where: UsersWhereUniqueInput
  }

  /**
   * Users findFirst
   */
  export type UsersFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Users
     */
    select?: UsersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Users
     */
    omit?: UsersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsersInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UsersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UsersOrderByWithRelationInput | UsersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UsersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UsersScalarFieldEnum | UsersScalarFieldEnum[]
  }

  /**
   * Users findFirstOrThrow
   */
  export type UsersFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Users
     */
    select?: UsersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Users
     */
    omit?: UsersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsersInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UsersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UsersOrderByWithRelationInput | UsersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UsersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UsersScalarFieldEnum | UsersScalarFieldEnum[]
  }

  /**
   * Users findMany
   */
  export type UsersFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Users
     */
    select?: UsersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Users
     */
    omit?: UsersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsersInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UsersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UsersOrderByWithRelationInput | UsersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UsersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UsersScalarFieldEnum | UsersScalarFieldEnum[]
  }

  /**
   * Users create
   */
  export type UsersCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Users
     */
    select?: UsersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Users
     */
    omit?: UsersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsersInclude<ExtArgs> | null
    /**
     * The data needed to create a Users.
     */
    data: XOR<UsersCreateInput, UsersUncheckedCreateInput>
  }

  /**
   * Users createMany
   */
  export type UsersCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UsersCreateManyInput | UsersCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Users update
   */
  export type UsersUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Users
     */
    select?: UsersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Users
     */
    omit?: UsersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsersInclude<ExtArgs> | null
    /**
     * The data needed to update a Users.
     */
    data: XOR<UsersUpdateInput, UsersUncheckedUpdateInput>
    /**
     * Choose, which Users to update.
     */
    where: UsersWhereUniqueInput
  }

  /**
   * Users updateMany
   */
  export type UsersUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UsersUpdateManyMutationInput, UsersUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UsersWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * Users upsert
   */
  export type UsersUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Users
     */
    select?: UsersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Users
     */
    omit?: UsersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsersInclude<ExtArgs> | null
    /**
     * The filter to search for the Users to update in case it exists.
     */
    where: UsersWhereUniqueInput
    /**
     * In case the Users found by the `where` argument doesn't exist, create a new Users with this data.
     */
    create: XOR<UsersCreateInput, UsersUncheckedCreateInput>
    /**
     * In case the Users was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UsersUpdateInput, UsersUncheckedUpdateInput>
  }

  /**
   * Users delete
   */
  export type UsersDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Users
     */
    select?: UsersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Users
     */
    omit?: UsersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsersInclude<ExtArgs> | null
    /**
     * Filter which Users to delete.
     */
    where: UsersWhereUniqueInput
  }

  /**
   * Users deleteMany
   */
  export type UsersDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UsersWhereInput
    /**
     * Limit how many Users to delete.
     */
    limit?: number
  }

  /**
   * Users.comics
   */
  export type Users$comicsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comics
     */
    select?: ComicsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comics
     */
    omit?: ComicsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComicsInclude<ExtArgs> | null
    where?: ComicsWhereInput
    orderBy?: ComicsOrderByWithRelationInput | ComicsOrderByWithRelationInput[]
    cursor?: ComicsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ComicsScalarFieldEnum | ComicsScalarFieldEnum[]
  }

  /**
   * Users.userRole
   */
  export type Users$userRoleArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Roles
     */
    select?: RolesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Roles
     */
    omit?: RolesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolesInclude<ExtArgs> | null
    where?: RolesWhereInput
    orderBy?: RolesOrderByWithRelationInput | RolesOrderByWithRelationInput[]
    cursor?: RolesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RolesScalarFieldEnum | RolesScalarFieldEnum[]
  }

  /**
   * Users.favorites
   */
  export type Users$favoritesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Favorites
     */
    select?: FavoritesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Favorites
     */
    omit?: FavoritesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FavoritesInclude<ExtArgs> | null
    where?: FavoritesWhereInput
    orderBy?: FavoritesOrderByWithRelationInput | FavoritesOrderByWithRelationInput[]
    cursor?: FavoritesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FavoritesScalarFieldEnum | FavoritesScalarFieldEnum[]
  }

  /**
   * Users.rates
   */
  export type Users$ratesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Rates
     */
    select?: RatesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Rates
     */
    omit?: RatesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RatesInclude<ExtArgs> | null
    where?: RatesWhereInput
    orderBy?: RatesOrderByWithRelationInput | RatesOrderByWithRelationInput[]
    cursor?: RatesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RatesScalarFieldEnum | RatesScalarFieldEnum[]
  }

  /**
   * Users.errors
   */
  export type Users$errorsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Errors
     */
    select?: ErrorsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Errors
     */
    omit?: ErrorsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ErrorsInclude<ExtArgs> | null
    where?: ErrorsWhereInput
    orderBy?: ErrorsOrderByWithRelationInput | ErrorsOrderByWithRelationInput[]
    cursor?: ErrorsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ErrorsScalarFieldEnum | ErrorsScalarFieldEnum[]
  }

  /**
   * Users.views
   */
  export type Users$viewsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Views
     */
    select?: ViewsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Views
     */
    omit?: ViewsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ViewsInclude<ExtArgs> | null
    where?: ViewsWhereInput
    orderBy?: ViewsOrderByWithRelationInput | ViewsOrderByWithRelationInput[]
    cursor?: ViewsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ViewsScalarFieldEnum | ViewsScalarFieldEnum[]
  }

  /**
   * Users.coments
   */
  export type Users$comentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comments
     */
    select?: CommentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comments
     */
    omit?: CommentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentsInclude<ExtArgs> | null
    where?: CommentsWhereInput
    orderBy?: CommentsOrderByWithRelationInput | CommentsOrderByWithRelationInput[]
    cursor?: CommentsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CommentsScalarFieldEnum | CommentsScalarFieldEnum[]
  }

  /**
   * Users.notifications
   */
  export type Users$notificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notifications
     */
    select?: NotificationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notifications
     */
    omit?: NotificationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationsInclude<ExtArgs> | null
    where?: NotificationsWhereInput
    orderBy?: NotificationsOrderByWithRelationInput | NotificationsOrderByWithRelationInput[]
    cursor?: NotificationsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NotificationsScalarFieldEnum | NotificationsScalarFieldEnum[]
  }

  /**
   * Users.wallets
   */
  export type Users$walletsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Wallets
     */
    select?: WalletsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Wallets
     */
    omit?: WalletsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WalletsInclude<ExtArgs> | null
    where?: WalletsWhereInput
  }

  /**
   * Users.unlock_comic
   */
  export type Users$unlock_comicArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Unlock_comic
     */
    select?: Unlock_comicSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Unlock_comic
     */
    omit?: Unlock_comicOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Unlock_comicInclude<ExtArgs> | null
    where?: Unlock_comicWhereInput
    orderBy?: Unlock_comicOrderByWithRelationInput | Unlock_comicOrderByWithRelationInput[]
    cursor?: Unlock_comicWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Unlock_comicScalarFieldEnum | Unlock_comicScalarFieldEnum[]
  }

  /**
   * Users.unlock_volume
   */
  export type Users$unlock_volumeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Unlock_volume
     */
    select?: Unlock_volumeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Unlock_volume
     */
    omit?: Unlock_volumeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Unlock_volumeInclude<ExtArgs> | null
    where?: Unlock_volumeWhereInput
    orderBy?: Unlock_volumeOrderByWithRelationInput | Unlock_volumeOrderByWithRelationInput[]
    cursor?: Unlock_volumeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Unlock_volumeScalarFieldEnum | Unlock_volumeScalarFieldEnum[]
  }

  /**
   * Users.unlock_chapter
   */
  export type Users$unlock_chapterArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Unlock_chapter
     */
    select?: Unlock_chapterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Unlock_chapter
     */
    omit?: Unlock_chapterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Unlock_chapterInclude<ExtArgs> | null
    where?: Unlock_chapterWhereInput
    orderBy?: Unlock_chapterOrderByWithRelationInput | Unlock_chapterOrderByWithRelationInput[]
    cursor?: Unlock_chapterWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Unlock_chapterScalarFieldEnum | Unlock_chapterScalarFieldEnum[]
  }

  /**
   * Users without action
   */
  export type UsersDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Users
     */
    select?: UsersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Users
     */
    omit?: UsersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsersInclude<ExtArgs> | null
  }


  /**
   * Model Favorites
   */

  export type AggregateFavorites = {
    _count: FavoritesCountAggregateOutputType | null
    _avg: FavoritesAvgAggregateOutputType | null
    _sum: FavoritesSumAggregateOutputType | null
    _min: FavoritesMinAggregateOutputType | null
    _max: FavoritesMaxAggregateOutputType | null
  }

  export type FavoritesAvgAggregateOutputType = {
    userId: number | null
    comicId: number | null
  }

  export type FavoritesSumAggregateOutputType = {
    userId: number | null
    comicId: number | null
  }

  export type FavoritesMinAggregateOutputType = {
    userId: number | null
    comicId: number | null
    addedAt: Date | null
  }

  export type FavoritesMaxAggregateOutputType = {
    userId: number | null
    comicId: number | null
    addedAt: Date | null
  }

  export type FavoritesCountAggregateOutputType = {
    userId: number
    comicId: number
    addedAt: number
    _all: number
  }


  export type FavoritesAvgAggregateInputType = {
    userId?: true
    comicId?: true
  }

  export type FavoritesSumAggregateInputType = {
    userId?: true
    comicId?: true
  }

  export type FavoritesMinAggregateInputType = {
    userId?: true
    comicId?: true
    addedAt?: true
  }

  export type FavoritesMaxAggregateInputType = {
    userId?: true
    comicId?: true
    addedAt?: true
  }

  export type FavoritesCountAggregateInputType = {
    userId?: true
    comicId?: true
    addedAt?: true
    _all?: true
  }

  export type FavoritesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Favorites to aggregate.
     */
    where?: FavoritesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Favorites to fetch.
     */
    orderBy?: FavoritesOrderByWithRelationInput | FavoritesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FavoritesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Favorites from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Favorites.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Favorites
    **/
    _count?: true | FavoritesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: FavoritesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: FavoritesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FavoritesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FavoritesMaxAggregateInputType
  }

  export type GetFavoritesAggregateType<T extends FavoritesAggregateArgs> = {
        [P in keyof T & keyof AggregateFavorites]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFavorites[P]>
      : GetScalarType<T[P], AggregateFavorites[P]>
  }




  export type FavoritesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FavoritesWhereInput
    orderBy?: FavoritesOrderByWithAggregationInput | FavoritesOrderByWithAggregationInput[]
    by: FavoritesScalarFieldEnum[] | FavoritesScalarFieldEnum
    having?: FavoritesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FavoritesCountAggregateInputType | true
    _avg?: FavoritesAvgAggregateInputType
    _sum?: FavoritesSumAggregateInputType
    _min?: FavoritesMinAggregateInputType
    _max?: FavoritesMaxAggregateInputType
  }

  export type FavoritesGroupByOutputType = {
    userId: number
    comicId: number
    addedAt: Date
    _count: FavoritesCountAggregateOutputType | null
    _avg: FavoritesAvgAggregateOutputType | null
    _sum: FavoritesSumAggregateOutputType | null
    _min: FavoritesMinAggregateOutputType | null
    _max: FavoritesMaxAggregateOutputType | null
  }

  type GetFavoritesGroupByPayload<T extends FavoritesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FavoritesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FavoritesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FavoritesGroupByOutputType[P]>
            : GetScalarType<T[P], FavoritesGroupByOutputType[P]>
        }
      >
    >


  export type FavoritesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    userId?: boolean
    comicId?: boolean
    addedAt?: boolean
    user?: boolean | UsersDefaultArgs<ExtArgs>
    comic?: boolean | ComicsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["favorites"]>



  export type FavoritesSelectScalar = {
    userId?: boolean
    comicId?: boolean
    addedAt?: boolean
  }

  export type FavoritesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"userId" | "comicId" | "addedAt", ExtArgs["result"]["favorites"]>
  export type FavoritesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UsersDefaultArgs<ExtArgs>
    comic?: boolean | ComicsDefaultArgs<ExtArgs>
  }

  export type $FavoritesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Favorites"
    objects: {
      user: Prisma.$UsersPayload<ExtArgs>
      comic: Prisma.$ComicsPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      userId: number
      comicId: number
      addedAt: Date
    }, ExtArgs["result"]["favorites"]>
    composites: {}
  }

  type FavoritesGetPayload<S extends boolean | null | undefined | FavoritesDefaultArgs> = $Result.GetResult<Prisma.$FavoritesPayload, S>

  type FavoritesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<FavoritesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: FavoritesCountAggregateInputType | true
    }

  export interface FavoritesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Favorites'], meta: { name: 'Favorites' } }
    /**
     * Find zero or one Favorites that matches the filter.
     * @param {FavoritesFindUniqueArgs} args - Arguments to find a Favorites
     * @example
     * // Get one Favorites
     * const favorites = await prisma.favorites.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FavoritesFindUniqueArgs>(args: SelectSubset<T, FavoritesFindUniqueArgs<ExtArgs>>): Prisma__FavoritesClient<$Result.GetResult<Prisma.$FavoritesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Favorites that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {FavoritesFindUniqueOrThrowArgs} args - Arguments to find a Favorites
     * @example
     * // Get one Favorites
     * const favorites = await prisma.favorites.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FavoritesFindUniqueOrThrowArgs>(args: SelectSubset<T, FavoritesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FavoritesClient<$Result.GetResult<Prisma.$FavoritesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Favorites that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FavoritesFindFirstArgs} args - Arguments to find a Favorites
     * @example
     * // Get one Favorites
     * const favorites = await prisma.favorites.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FavoritesFindFirstArgs>(args?: SelectSubset<T, FavoritesFindFirstArgs<ExtArgs>>): Prisma__FavoritesClient<$Result.GetResult<Prisma.$FavoritesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Favorites that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FavoritesFindFirstOrThrowArgs} args - Arguments to find a Favorites
     * @example
     * // Get one Favorites
     * const favorites = await prisma.favorites.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FavoritesFindFirstOrThrowArgs>(args?: SelectSubset<T, FavoritesFindFirstOrThrowArgs<ExtArgs>>): Prisma__FavoritesClient<$Result.GetResult<Prisma.$FavoritesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Favorites that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FavoritesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Favorites
     * const favorites = await prisma.favorites.findMany()
     * 
     * // Get first 10 Favorites
     * const favorites = await prisma.favorites.findMany({ take: 10 })
     * 
     * // Only select the `userId`
     * const favoritesWithUserIdOnly = await prisma.favorites.findMany({ select: { userId: true } })
     * 
     */
    findMany<T extends FavoritesFindManyArgs>(args?: SelectSubset<T, FavoritesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FavoritesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Favorites.
     * @param {FavoritesCreateArgs} args - Arguments to create a Favorites.
     * @example
     * // Create one Favorites
     * const Favorites = await prisma.favorites.create({
     *   data: {
     *     // ... data to create a Favorites
     *   }
     * })
     * 
     */
    create<T extends FavoritesCreateArgs>(args: SelectSubset<T, FavoritesCreateArgs<ExtArgs>>): Prisma__FavoritesClient<$Result.GetResult<Prisma.$FavoritesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Favorites.
     * @param {FavoritesCreateManyArgs} args - Arguments to create many Favorites.
     * @example
     * // Create many Favorites
     * const favorites = await prisma.favorites.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FavoritesCreateManyArgs>(args?: SelectSubset<T, FavoritesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Favorites.
     * @param {FavoritesDeleteArgs} args - Arguments to delete one Favorites.
     * @example
     * // Delete one Favorites
     * const Favorites = await prisma.favorites.delete({
     *   where: {
     *     // ... filter to delete one Favorites
     *   }
     * })
     * 
     */
    delete<T extends FavoritesDeleteArgs>(args: SelectSubset<T, FavoritesDeleteArgs<ExtArgs>>): Prisma__FavoritesClient<$Result.GetResult<Prisma.$FavoritesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Favorites.
     * @param {FavoritesUpdateArgs} args - Arguments to update one Favorites.
     * @example
     * // Update one Favorites
     * const favorites = await prisma.favorites.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FavoritesUpdateArgs>(args: SelectSubset<T, FavoritesUpdateArgs<ExtArgs>>): Prisma__FavoritesClient<$Result.GetResult<Prisma.$FavoritesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Favorites.
     * @param {FavoritesDeleteManyArgs} args - Arguments to filter Favorites to delete.
     * @example
     * // Delete a few Favorites
     * const { count } = await prisma.favorites.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FavoritesDeleteManyArgs>(args?: SelectSubset<T, FavoritesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Favorites.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FavoritesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Favorites
     * const favorites = await prisma.favorites.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FavoritesUpdateManyArgs>(args: SelectSubset<T, FavoritesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Favorites.
     * @param {FavoritesUpsertArgs} args - Arguments to update or create a Favorites.
     * @example
     * // Update or create a Favorites
     * const favorites = await prisma.favorites.upsert({
     *   create: {
     *     // ... data to create a Favorites
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Favorites we want to update
     *   }
     * })
     */
    upsert<T extends FavoritesUpsertArgs>(args: SelectSubset<T, FavoritesUpsertArgs<ExtArgs>>): Prisma__FavoritesClient<$Result.GetResult<Prisma.$FavoritesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Favorites.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FavoritesCountArgs} args - Arguments to filter Favorites to count.
     * @example
     * // Count the number of Favorites
     * const count = await prisma.favorites.count({
     *   where: {
     *     // ... the filter for the Favorites we want to count
     *   }
     * })
    **/
    count<T extends FavoritesCountArgs>(
      args?: Subset<T, FavoritesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FavoritesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Favorites.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FavoritesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FavoritesAggregateArgs>(args: Subset<T, FavoritesAggregateArgs>): Prisma.PrismaPromise<GetFavoritesAggregateType<T>>

    /**
     * Group by Favorites.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FavoritesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FavoritesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FavoritesGroupByArgs['orderBy'] }
        : { orderBy?: FavoritesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FavoritesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFavoritesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Favorites model
   */
  readonly fields: FavoritesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Favorites.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FavoritesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UsersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UsersDefaultArgs<ExtArgs>>): Prisma__UsersClient<$Result.GetResult<Prisma.$UsersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    comic<T extends ComicsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ComicsDefaultArgs<ExtArgs>>): Prisma__ComicsClient<$Result.GetResult<Prisma.$ComicsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Favorites model
   */
  interface FavoritesFieldRefs {
    readonly userId: FieldRef<"Favorites", 'Int'>
    readonly comicId: FieldRef<"Favorites", 'Int'>
    readonly addedAt: FieldRef<"Favorites", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Favorites findUnique
   */
  export type FavoritesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Favorites
     */
    select?: FavoritesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Favorites
     */
    omit?: FavoritesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FavoritesInclude<ExtArgs> | null
    /**
     * Filter, which Favorites to fetch.
     */
    where: FavoritesWhereUniqueInput
  }

  /**
   * Favorites findUniqueOrThrow
   */
  export type FavoritesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Favorites
     */
    select?: FavoritesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Favorites
     */
    omit?: FavoritesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FavoritesInclude<ExtArgs> | null
    /**
     * Filter, which Favorites to fetch.
     */
    where: FavoritesWhereUniqueInput
  }

  /**
   * Favorites findFirst
   */
  export type FavoritesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Favorites
     */
    select?: FavoritesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Favorites
     */
    omit?: FavoritesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FavoritesInclude<ExtArgs> | null
    /**
     * Filter, which Favorites to fetch.
     */
    where?: FavoritesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Favorites to fetch.
     */
    orderBy?: FavoritesOrderByWithRelationInput | FavoritesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Favorites.
     */
    cursor?: FavoritesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Favorites from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Favorites.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Favorites.
     */
    distinct?: FavoritesScalarFieldEnum | FavoritesScalarFieldEnum[]
  }

  /**
   * Favorites findFirstOrThrow
   */
  export type FavoritesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Favorites
     */
    select?: FavoritesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Favorites
     */
    omit?: FavoritesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FavoritesInclude<ExtArgs> | null
    /**
     * Filter, which Favorites to fetch.
     */
    where?: FavoritesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Favorites to fetch.
     */
    orderBy?: FavoritesOrderByWithRelationInput | FavoritesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Favorites.
     */
    cursor?: FavoritesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Favorites from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Favorites.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Favorites.
     */
    distinct?: FavoritesScalarFieldEnum | FavoritesScalarFieldEnum[]
  }

  /**
   * Favorites findMany
   */
  export type FavoritesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Favorites
     */
    select?: FavoritesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Favorites
     */
    omit?: FavoritesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FavoritesInclude<ExtArgs> | null
    /**
     * Filter, which Favorites to fetch.
     */
    where?: FavoritesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Favorites to fetch.
     */
    orderBy?: FavoritesOrderByWithRelationInput | FavoritesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Favorites.
     */
    cursor?: FavoritesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Favorites from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Favorites.
     */
    skip?: number
    distinct?: FavoritesScalarFieldEnum | FavoritesScalarFieldEnum[]
  }

  /**
   * Favorites create
   */
  export type FavoritesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Favorites
     */
    select?: FavoritesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Favorites
     */
    omit?: FavoritesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FavoritesInclude<ExtArgs> | null
    /**
     * The data needed to create a Favorites.
     */
    data: XOR<FavoritesCreateInput, FavoritesUncheckedCreateInput>
  }

  /**
   * Favorites createMany
   */
  export type FavoritesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Favorites.
     */
    data: FavoritesCreateManyInput | FavoritesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Favorites update
   */
  export type FavoritesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Favorites
     */
    select?: FavoritesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Favorites
     */
    omit?: FavoritesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FavoritesInclude<ExtArgs> | null
    /**
     * The data needed to update a Favorites.
     */
    data: XOR<FavoritesUpdateInput, FavoritesUncheckedUpdateInput>
    /**
     * Choose, which Favorites to update.
     */
    where: FavoritesWhereUniqueInput
  }

  /**
   * Favorites updateMany
   */
  export type FavoritesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Favorites.
     */
    data: XOR<FavoritesUpdateManyMutationInput, FavoritesUncheckedUpdateManyInput>
    /**
     * Filter which Favorites to update
     */
    where?: FavoritesWhereInput
    /**
     * Limit how many Favorites to update.
     */
    limit?: number
  }

  /**
   * Favorites upsert
   */
  export type FavoritesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Favorites
     */
    select?: FavoritesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Favorites
     */
    omit?: FavoritesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FavoritesInclude<ExtArgs> | null
    /**
     * The filter to search for the Favorites to update in case it exists.
     */
    where: FavoritesWhereUniqueInput
    /**
     * In case the Favorites found by the `where` argument doesn't exist, create a new Favorites with this data.
     */
    create: XOR<FavoritesCreateInput, FavoritesUncheckedCreateInput>
    /**
     * In case the Favorites was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FavoritesUpdateInput, FavoritesUncheckedUpdateInput>
  }

  /**
   * Favorites delete
   */
  export type FavoritesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Favorites
     */
    select?: FavoritesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Favorites
     */
    omit?: FavoritesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FavoritesInclude<ExtArgs> | null
    /**
     * Filter which Favorites to delete.
     */
    where: FavoritesWhereUniqueInput
  }

  /**
   * Favorites deleteMany
   */
  export type FavoritesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Favorites to delete
     */
    where?: FavoritesWhereInput
    /**
     * Limit how many Favorites to delete.
     */
    limit?: number
  }

  /**
   * Favorites without action
   */
  export type FavoritesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Favorites
     */
    select?: FavoritesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Favorites
     */
    omit?: FavoritesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FavoritesInclude<ExtArgs> | null
  }


  /**
   * Model Rates
   */

  export type AggregateRates = {
    _count: RatesCountAggregateOutputType | null
    _avg: RatesAvgAggregateOutputType | null
    _sum: RatesSumAggregateOutputType | null
    _min: RatesMinAggregateOutputType | null
    _max: RatesMaxAggregateOutputType | null
  }

  export type RatesAvgAggregateOutputType = {
    userId: number | null
    comicId: number | null
    score: number | null
  }

  export type RatesSumAggregateOutputType = {
    userId: number | null
    comicId: number | null
    score: number | null
  }

  export type RatesMinAggregateOutputType = {
    userId: number | null
    comicId: number | null
    score: number | null
    content: string | null
    createdAt: Date | null
  }

  export type RatesMaxAggregateOutputType = {
    userId: number | null
    comicId: number | null
    score: number | null
    content: string | null
    createdAt: Date | null
  }

  export type RatesCountAggregateOutputType = {
    userId: number
    comicId: number
    score: number
    content: number
    createdAt: number
    _all: number
  }


  export type RatesAvgAggregateInputType = {
    userId?: true
    comicId?: true
    score?: true
  }

  export type RatesSumAggregateInputType = {
    userId?: true
    comicId?: true
    score?: true
  }

  export type RatesMinAggregateInputType = {
    userId?: true
    comicId?: true
    score?: true
    content?: true
    createdAt?: true
  }

  export type RatesMaxAggregateInputType = {
    userId?: true
    comicId?: true
    score?: true
    content?: true
    createdAt?: true
  }

  export type RatesCountAggregateInputType = {
    userId?: true
    comicId?: true
    score?: true
    content?: true
    createdAt?: true
    _all?: true
  }

  export type RatesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Rates to aggregate.
     */
    where?: RatesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Rates to fetch.
     */
    orderBy?: RatesOrderByWithRelationInput | RatesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RatesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Rates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Rates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Rates
    **/
    _count?: true | RatesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RatesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RatesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RatesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RatesMaxAggregateInputType
  }

  export type GetRatesAggregateType<T extends RatesAggregateArgs> = {
        [P in keyof T & keyof AggregateRates]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRates[P]>
      : GetScalarType<T[P], AggregateRates[P]>
  }




  export type RatesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RatesWhereInput
    orderBy?: RatesOrderByWithAggregationInput | RatesOrderByWithAggregationInput[]
    by: RatesScalarFieldEnum[] | RatesScalarFieldEnum
    having?: RatesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RatesCountAggregateInputType | true
    _avg?: RatesAvgAggregateInputType
    _sum?: RatesSumAggregateInputType
    _min?: RatesMinAggregateInputType
    _max?: RatesMaxAggregateInputType
  }

  export type RatesGroupByOutputType = {
    userId: number
    comicId: number
    score: number
    content: string
    createdAt: Date
    _count: RatesCountAggregateOutputType | null
    _avg: RatesAvgAggregateOutputType | null
    _sum: RatesSumAggregateOutputType | null
    _min: RatesMinAggregateOutputType | null
    _max: RatesMaxAggregateOutputType | null
  }

  type GetRatesGroupByPayload<T extends RatesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RatesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RatesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RatesGroupByOutputType[P]>
            : GetScalarType<T[P], RatesGroupByOutputType[P]>
        }
      >
    >


  export type RatesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    userId?: boolean
    comicId?: boolean
    score?: boolean
    content?: boolean
    createdAt?: boolean
    user?: boolean | UsersDefaultArgs<ExtArgs>
    comic?: boolean | ComicsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["rates"]>



  export type RatesSelectScalar = {
    userId?: boolean
    comicId?: boolean
    score?: boolean
    content?: boolean
    createdAt?: boolean
  }

  export type RatesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"userId" | "comicId" | "score" | "content" | "createdAt", ExtArgs["result"]["rates"]>
  export type RatesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UsersDefaultArgs<ExtArgs>
    comic?: boolean | ComicsDefaultArgs<ExtArgs>
  }

  export type $RatesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Rates"
    objects: {
      user: Prisma.$UsersPayload<ExtArgs>
      comic: Prisma.$ComicsPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      userId: number
      comicId: number
      score: number
      content: string
      createdAt: Date
    }, ExtArgs["result"]["rates"]>
    composites: {}
  }

  type RatesGetPayload<S extends boolean | null | undefined | RatesDefaultArgs> = $Result.GetResult<Prisma.$RatesPayload, S>

  type RatesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<RatesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RatesCountAggregateInputType | true
    }

  export interface RatesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Rates'], meta: { name: 'Rates' } }
    /**
     * Find zero or one Rates that matches the filter.
     * @param {RatesFindUniqueArgs} args - Arguments to find a Rates
     * @example
     * // Get one Rates
     * const rates = await prisma.rates.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RatesFindUniqueArgs>(args: SelectSubset<T, RatesFindUniqueArgs<ExtArgs>>): Prisma__RatesClient<$Result.GetResult<Prisma.$RatesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Rates that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RatesFindUniqueOrThrowArgs} args - Arguments to find a Rates
     * @example
     * // Get one Rates
     * const rates = await prisma.rates.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RatesFindUniqueOrThrowArgs>(args: SelectSubset<T, RatesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RatesClient<$Result.GetResult<Prisma.$RatesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Rates that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RatesFindFirstArgs} args - Arguments to find a Rates
     * @example
     * // Get one Rates
     * const rates = await prisma.rates.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RatesFindFirstArgs>(args?: SelectSubset<T, RatesFindFirstArgs<ExtArgs>>): Prisma__RatesClient<$Result.GetResult<Prisma.$RatesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Rates that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RatesFindFirstOrThrowArgs} args - Arguments to find a Rates
     * @example
     * // Get one Rates
     * const rates = await prisma.rates.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RatesFindFirstOrThrowArgs>(args?: SelectSubset<T, RatesFindFirstOrThrowArgs<ExtArgs>>): Prisma__RatesClient<$Result.GetResult<Prisma.$RatesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Rates that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RatesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Rates
     * const rates = await prisma.rates.findMany()
     * 
     * // Get first 10 Rates
     * const rates = await prisma.rates.findMany({ take: 10 })
     * 
     * // Only select the `userId`
     * const ratesWithUserIdOnly = await prisma.rates.findMany({ select: { userId: true } })
     * 
     */
    findMany<T extends RatesFindManyArgs>(args?: SelectSubset<T, RatesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RatesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Rates.
     * @param {RatesCreateArgs} args - Arguments to create a Rates.
     * @example
     * // Create one Rates
     * const Rates = await prisma.rates.create({
     *   data: {
     *     // ... data to create a Rates
     *   }
     * })
     * 
     */
    create<T extends RatesCreateArgs>(args: SelectSubset<T, RatesCreateArgs<ExtArgs>>): Prisma__RatesClient<$Result.GetResult<Prisma.$RatesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Rates.
     * @param {RatesCreateManyArgs} args - Arguments to create many Rates.
     * @example
     * // Create many Rates
     * const rates = await prisma.rates.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RatesCreateManyArgs>(args?: SelectSubset<T, RatesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Rates.
     * @param {RatesDeleteArgs} args - Arguments to delete one Rates.
     * @example
     * // Delete one Rates
     * const Rates = await prisma.rates.delete({
     *   where: {
     *     // ... filter to delete one Rates
     *   }
     * })
     * 
     */
    delete<T extends RatesDeleteArgs>(args: SelectSubset<T, RatesDeleteArgs<ExtArgs>>): Prisma__RatesClient<$Result.GetResult<Prisma.$RatesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Rates.
     * @param {RatesUpdateArgs} args - Arguments to update one Rates.
     * @example
     * // Update one Rates
     * const rates = await prisma.rates.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RatesUpdateArgs>(args: SelectSubset<T, RatesUpdateArgs<ExtArgs>>): Prisma__RatesClient<$Result.GetResult<Prisma.$RatesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Rates.
     * @param {RatesDeleteManyArgs} args - Arguments to filter Rates to delete.
     * @example
     * // Delete a few Rates
     * const { count } = await prisma.rates.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RatesDeleteManyArgs>(args?: SelectSubset<T, RatesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Rates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RatesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Rates
     * const rates = await prisma.rates.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RatesUpdateManyArgs>(args: SelectSubset<T, RatesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Rates.
     * @param {RatesUpsertArgs} args - Arguments to update or create a Rates.
     * @example
     * // Update or create a Rates
     * const rates = await prisma.rates.upsert({
     *   create: {
     *     // ... data to create a Rates
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Rates we want to update
     *   }
     * })
     */
    upsert<T extends RatesUpsertArgs>(args: SelectSubset<T, RatesUpsertArgs<ExtArgs>>): Prisma__RatesClient<$Result.GetResult<Prisma.$RatesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Rates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RatesCountArgs} args - Arguments to filter Rates to count.
     * @example
     * // Count the number of Rates
     * const count = await prisma.rates.count({
     *   where: {
     *     // ... the filter for the Rates we want to count
     *   }
     * })
    **/
    count<T extends RatesCountArgs>(
      args?: Subset<T, RatesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RatesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Rates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RatesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RatesAggregateArgs>(args: Subset<T, RatesAggregateArgs>): Prisma.PrismaPromise<GetRatesAggregateType<T>>

    /**
     * Group by Rates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RatesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RatesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RatesGroupByArgs['orderBy'] }
        : { orderBy?: RatesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RatesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRatesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Rates model
   */
  readonly fields: RatesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Rates.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RatesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UsersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UsersDefaultArgs<ExtArgs>>): Prisma__UsersClient<$Result.GetResult<Prisma.$UsersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    comic<T extends ComicsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ComicsDefaultArgs<ExtArgs>>): Prisma__ComicsClient<$Result.GetResult<Prisma.$ComicsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Rates model
   */
  interface RatesFieldRefs {
    readonly userId: FieldRef<"Rates", 'Int'>
    readonly comicId: FieldRef<"Rates", 'Int'>
    readonly score: FieldRef<"Rates", 'Float'>
    readonly content: FieldRef<"Rates", 'String'>
    readonly createdAt: FieldRef<"Rates", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Rates findUnique
   */
  export type RatesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Rates
     */
    select?: RatesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Rates
     */
    omit?: RatesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RatesInclude<ExtArgs> | null
    /**
     * Filter, which Rates to fetch.
     */
    where: RatesWhereUniqueInput
  }

  /**
   * Rates findUniqueOrThrow
   */
  export type RatesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Rates
     */
    select?: RatesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Rates
     */
    omit?: RatesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RatesInclude<ExtArgs> | null
    /**
     * Filter, which Rates to fetch.
     */
    where: RatesWhereUniqueInput
  }

  /**
   * Rates findFirst
   */
  export type RatesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Rates
     */
    select?: RatesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Rates
     */
    omit?: RatesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RatesInclude<ExtArgs> | null
    /**
     * Filter, which Rates to fetch.
     */
    where?: RatesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Rates to fetch.
     */
    orderBy?: RatesOrderByWithRelationInput | RatesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Rates.
     */
    cursor?: RatesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Rates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Rates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Rates.
     */
    distinct?: RatesScalarFieldEnum | RatesScalarFieldEnum[]
  }

  /**
   * Rates findFirstOrThrow
   */
  export type RatesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Rates
     */
    select?: RatesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Rates
     */
    omit?: RatesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RatesInclude<ExtArgs> | null
    /**
     * Filter, which Rates to fetch.
     */
    where?: RatesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Rates to fetch.
     */
    orderBy?: RatesOrderByWithRelationInput | RatesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Rates.
     */
    cursor?: RatesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Rates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Rates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Rates.
     */
    distinct?: RatesScalarFieldEnum | RatesScalarFieldEnum[]
  }

  /**
   * Rates findMany
   */
  export type RatesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Rates
     */
    select?: RatesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Rates
     */
    omit?: RatesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RatesInclude<ExtArgs> | null
    /**
     * Filter, which Rates to fetch.
     */
    where?: RatesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Rates to fetch.
     */
    orderBy?: RatesOrderByWithRelationInput | RatesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Rates.
     */
    cursor?: RatesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Rates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Rates.
     */
    skip?: number
    distinct?: RatesScalarFieldEnum | RatesScalarFieldEnum[]
  }

  /**
   * Rates create
   */
  export type RatesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Rates
     */
    select?: RatesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Rates
     */
    omit?: RatesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RatesInclude<ExtArgs> | null
    /**
     * The data needed to create a Rates.
     */
    data: XOR<RatesCreateInput, RatesUncheckedCreateInput>
  }

  /**
   * Rates createMany
   */
  export type RatesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Rates.
     */
    data: RatesCreateManyInput | RatesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Rates update
   */
  export type RatesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Rates
     */
    select?: RatesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Rates
     */
    omit?: RatesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RatesInclude<ExtArgs> | null
    /**
     * The data needed to update a Rates.
     */
    data: XOR<RatesUpdateInput, RatesUncheckedUpdateInput>
    /**
     * Choose, which Rates to update.
     */
    where: RatesWhereUniqueInput
  }

  /**
   * Rates updateMany
   */
  export type RatesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Rates.
     */
    data: XOR<RatesUpdateManyMutationInput, RatesUncheckedUpdateManyInput>
    /**
     * Filter which Rates to update
     */
    where?: RatesWhereInput
    /**
     * Limit how many Rates to update.
     */
    limit?: number
  }

  /**
   * Rates upsert
   */
  export type RatesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Rates
     */
    select?: RatesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Rates
     */
    omit?: RatesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RatesInclude<ExtArgs> | null
    /**
     * The filter to search for the Rates to update in case it exists.
     */
    where: RatesWhereUniqueInput
    /**
     * In case the Rates found by the `where` argument doesn't exist, create a new Rates with this data.
     */
    create: XOR<RatesCreateInput, RatesUncheckedCreateInput>
    /**
     * In case the Rates was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RatesUpdateInput, RatesUncheckedUpdateInput>
  }

  /**
   * Rates delete
   */
  export type RatesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Rates
     */
    select?: RatesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Rates
     */
    omit?: RatesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RatesInclude<ExtArgs> | null
    /**
     * Filter which Rates to delete.
     */
    where: RatesWhereUniqueInput
  }

  /**
   * Rates deleteMany
   */
  export type RatesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Rates to delete
     */
    where?: RatesWhereInput
    /**
     * Limit how many Rates to delete.
     */
    limit?: number
  }

  /**
   * Rates without action
   */
  export type RatesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Rates
     */
    select?: RatesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Rates
     */
    omit?: RatesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RatesInclude<ExtArgs> | null
  }


  /**
   * Model Errors
   */

  export type AggregateErrors = {
    _count: ErrorsCountAggregateOutputType | null
    _avg: ErrorsAvgAggregateOutputType | null
    _sum: ErrorsSumAggregateOutputType | null
    _min: ErrorsMinAggregateOutputType | null
    _max: ErrorsMaxAggregateOutputType | null
  }

  export type ErrorsAvgAggregateOutputType = {
    userId: number | null
    chapterId: number | null
  }

  export type ErrorsSumAggregateOutputType = {
    userId: number | null
    chapterId: number | null
  }

  export type ErrorsMinAggregateOutputType = {
    userId: number | null
    chapterId: number | null
    content: string | null
    status: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ErrorsMaxAggregateOutputType = {
    userId: number | null
    chapterId: number | null
    content: string | null
    status: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ErrorsCountAggregateOutputType = {
    userId: number
    chapterId: number
    content: number
    status: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ErrorsAvgAggregateInputType = {
    userId?: true
    chapterId?: true
  }

  export type ErrorsSumAggregateInputType = {
    userId?: true
    chapterId?: true
  }

  export type ErrorsMinAggregateInputType = {
    userId?: true
    chapterId?: true
    content?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ErrorsMaxAggregateInputType = {
    userId?: true
    chapterId?: true
    content?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ErrorsCountAggregateInputType = {
    userId?: true
    chapterId?: true
    content?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ErrorsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Errors to aggregate.
     */
    where?: ErrorsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Errors to fetch.
     */
    orderBy?: ErrorsOrderByWithRelationInput | ErrorsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ErrorsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Errors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Errors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Errors
    **/
    _count?: true | ErrorsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ErrorsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ErrorsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ErrorsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ErrorsMaxAggregateInputType
  }

  export type GetErrorsAggregateType<T extends ErrorsAggregateArgs> = {
        [P in keyof T & keyof AggregateErrors]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateErrors[P]>
      : GetScalarType<T[P], AggregateErrors[P]>
  }




  export type ErrorsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ErrorsWhereInput
    orderBy?: ErrorsOrderByWithAggregationInput | ErrorsOrderByWithAggregationInput[]
    by: ErrorsScalarFieldEnum[] | ErrorsScalarFieldEnum
    having?: ErrorsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ErrorsCountAggregateInputType | true
    _avg?: ErrorsAvgAggregateInputType
    _sum?: ErrorsSumAggregateInputType
    _min?: ErrorsMinAggregateInputType
    _max?: ErrorsMaxAggregateInputType
  }

  export type ErrorsGroupByOutputType = {
    userId: number
    chapterId: number
    content: string
    status: string
    createdAt: Date
    updatedAt: Date
    _count: ErrorsCountAggregateOutputType | null
    _avg: ErrorsAvgAggregateOutputType | null
    _sum: ErrorsSumAggregateOutputType | null
    _min: ErrorsMinAggregateOutputType | null
    _max: ErrorsMaxAggregateOutputType | null
  }

  type GetErrorsGroupByPayload<T extends ErrorsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ErrorsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ErrorsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ErrorsGroupByOutputType[P]>
            : GetScalarType<T[P], ErrorsGroupByOutputType[P]>
        }
      >
    >


  export type ErrorsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    userId?: boolean
    chapterId?: boolean
    content?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UsersDefaultArgs<ExtArgs>
    chapter?: boolean | ChaptersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["errors"]>



  export type ErrorsSelectScalar = {
    userId?: boolean
    chapterId?: boolean
    content?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ErrorsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"userId" | "chapterId" | "content" | "status" | "createdAt" | "updatedAt", ExtArgs["result"]["errors"]>
  export type ErrorsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UsersDefaultArgs<ExtArgs>
    chapter?: boolean | ChaptersDefaultArgs<ExtArgs>
  }

  export type $ErrorsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Errors"
    objects: {
      user: Prisma.$UsersPayload<ExtArgs>
      chapter: Prisma.$ChaptersPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      userId: number
      chapterId: number
      content: string
      status: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["errors"]>
    composites: {}
  }

  type ErrorsGetPayload<S extends boolean | null | undefined | ErrorsDefaultArgs> = $Result.GetResult<Prisma.$ErrorsPayload, S>

  type ErrorsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ErrorsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ErrorsCountAggregateInputType | true
    }

  export interface ErrorsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Errors'], meta: { name: 'Errors' } }
    /**
     * Find zero or one Errors that matches the filter.
     * @param {ErrorsFindUniqueArgs} args - Arguments to find a Errors
     * @example
     * // Get one Errors
     * const errors = await prisma.errors.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ErrorsFindUniqueArgs>(args: SelectSubset<T, ErrorsFindUniqueArgs<ExtArgs>>): Prisma__ErrorsClient<$Result.GetResult<Prisma.$ErrorsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Errors that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ErrorsFindUniqueOrThrowArgs} args - Arguments to find a Errors
     * @example
     * // Get one Errors
     * const errors = await prisma.errors.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ErrorsFindUniqueOrThrowArgs>(args: SelectSubset<T, ErrorsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ErrorsClient<$Result.GetResult<Prisma.$ErrorsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Errors that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ErrorsFindFirstArgs} args - Arguments to find a Errors
     * @example
     * // Get one Errors
     * const errors = await prisma.errors.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ErrorsFindFirstArgs>(args?: SelectSubset<T, ErrorsFindFirstArgs<ExtArgs>>): Prisma__ErrorsClient<$Result.GetResult<Prisma.$ErrorsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Errors that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ErrorsFindFirstOrThrowArgs} args - Arguments to find a Errors
     * @example
     * // Get one Errors
     * const errors = await prisma.errors.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ErrorsFindFirstOrThrowArgs>(args?: SelectSubset<T, ErrorsFindFirstOrThrowArgs<ExtArgs>>): Prisma__ErrorsClient<$Result.GetResult<Prisma.$ErrorsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Errors that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ErrorsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Errors
     * const errors = await prisma.errors.findMany()
     * 
     * // Get first 10 Errors
     * const errors = await prisma.errors.findMany({ take: 10 })
     * 
     * // Only select the `userId`
     * const errorsWithUserIdOnly = await prisma.errors.findMany({ select: { userId: true } })
     * 
     */
    findMany<T extends ErrorsFindManyArgs>(args?: SelectSubset<T, ErrorsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ErrorsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Errors.
     * @param {ErrorsCreateArgs} args - Arguments to create a Errors.
     * @example
     * // Create one Errors
     * const Errors = await prisma.errors.create({
     *   data: {
     *     // ... data to create a Errors
     *   }
     * })
     * 
     */
    create<T extends ErrorsCreateArgs>(args: SelectSubset<T, ErrorsCreateArgs<ExtArgs>>): Prisma__ErrorsClient<$Result.GetResult<Prisma.$ErrorsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Errors.
     * @param {ErrorsCreateManyArgs} args - Arguments to create many Errors.
     * @example
     * // Create many Errors
     * const errors = await prisma.errors.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ErrorsCreateManyArgs>(args?: SelectSubset<T, ErrorsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Errors.
     * @param {ErrorsDeleteArgs} args - Arguments to delete one Errors.
     * @example
     * // Delete one Errors
     * const Errors = await prisma.errors.delete({
     *   where: {
     *     // ... filter to delete one Errors
     *   }
     * })
     * 
     */
    delete<T extends ErrorsDeleteArgs>(args: SelectSubset<T, ErrorsDeleteArgs<ExtArgs>>): Prisma__ErrorsClient<$Result.GetResult<Prisma.$ErrorsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Errors.
     * @param {ErrorsUpdateArgs} args - Arguments to update one Errors.
     * @example
     * // Update one Errors
     * const errors = await prisma.errors.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ErrorsUpdateArgs>(args: SelectSubset<T, ErrorsUpdateArgs<ExtArgs>>): Prisma__ErrorsClient<$Result.GetResult<Prisma.$ErrorsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Errors.
     * @param {ErrorsDeleteManyArgs} args - Arguments to filter Errors to delete.
     * @example
     * // Delete a few Errors
     * const { count } = await prisma.errors.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ErrorsDeleteManyArgs>(args?: SelectSubset<T, ErrorsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Errors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ErrorsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Errors
     * const errors = await prisma.errors.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ErrorsUpdateManyArgs>(args: SelectSubset<T, ErrorsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Errors.
     * @param {ErrorsUpsertArgs} args - Arguments to update or create a Errors.
     * @example
     * // Update or create a Errors
     * const errors = await prisma.errors.upsert({
     *   create: {
     *     // ... data to create a Errors
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Errors we want to update
     *   }
     * })
     */
    upsert<T extends ErrorsUpsertArgs>(args: SelectSubset<T, ErrorsUpsertArgs<ExtArgs>>): Prisma__ErrorsClient<$Result.GetResult<Prisma.$ErrorsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Errors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ErrorsCountArgs} args - Arguments to filter Errors to count.
     * @example
     * // Count the number of Errors
     * const count = await prisma.errors.count({
     *   where: {
     *     // ... the filter for the Errors we want to count
     *   }
     * })
    **/
    count<T extends ErrorsCountArgs>(
      args?: Subset<T, ErrorsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ErrorsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Errors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ErrorsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ErrorsAggregateArgs>(args: Subset<T, ErrorsAggregateArgs>): Prisma.PrismaPromise<GetErrorsAggregateType<T>>

    /**
     * Group by Errors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ErrorsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ErrorsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ErrorsGroupByArgs['orderBy'] }
        : { orderBy?: ErrorsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ErrorsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetErrorsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Errors model
   */
  readonly fields: ErrorsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Errors.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ErrorsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UsersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UsersDefaultArgs<ExtArgs>>): Prisma__UsersClient<$Result.GetResult<Prisma.$UsersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    chapter<T extends ChaptersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ChaptersDefaultArgs<ExtArgs>>): Prisma__ChaptersClient<$Result.GetResult<Prisma.$ChaptersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Errors model
   */
  interface ErrorsFieldRefs {
    readonly userId: FieldRef<"Errors", 'Int'>
    readonly chapterId: FieldRef<"Errors", 'Int'>
    readonly content: FieldRef<"Errors", 'String'>
    readonly status: FieldRef<"Errors", 'String'>
    readonly createdAt: FieldRef<"Errors", 'DateTime'>
    readonly updatedAt: FieldRef<"Errors", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Errors findUnique
   */
  export type ErrorsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Errors
     */
    select?: ErrorsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Errors
     */
    omit?: ErrorsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ErrorsInclude<ExtArgs> | null
    /**
     * Filter, which Errors to fetch.
     */
    where: ErrorsWhereUniqueInput
  }

  /**
   * Errors findUniqueOrThrow
   */
  export type ErrorsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Errors
     */
    select?: ErrorsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Errors
     */
    omit?: ErrorsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ErrorsInclude<ExtArgs> | null
    /**
     * Filter, which Errors to fetch.
     */
    where: ErrorsWhereUniqueInput
  }

  /**
   * Errors findFirst
   */
  export type ErrorsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Errors
     */
    select?: ErrorsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Errors
     */
    omit?: ErrorsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ErrorsInclude<ExtArgs> | null
    /**
     * Filter, which Errors to fetch.
     */
    where?: ErrorsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Errors to fetch.
     */
    orderBy?: ErrorsOrderByWithRelationInput | ErrorsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Errors.
     */
    cursor?: ErrorsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Errors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Errors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Errors.
     */
    distinct?: ErrorsScalarFieldEnum | ErrorsScalarFieldEnum[]
  }

  /**
   * Errors findFirstOrThrow
   */
  export type ErrorsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Errors
     */
    select?: ErrorsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Errors
     */
    omit?: ErrorsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ErrorsInclude<ExtArgs> | null
    /**
     * Filter, which Errors to fetch.
     */
    where?: ErrorsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Errors to fetch.
     */
    orderBy?: ErrorsOrderByWithRelationInput | ErrorsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Errors.
     */
    cursor?: ErrorsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Errors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Errors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Errors.
     */
    distinct?: ErrorsScalarFieldEnum | ErrorsScalarFieldEnum[]
  }

  /**
   * Errors findMany
   */
  export type ErrorsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Errors
     */
    select?: ErrorsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Errors
     */
    omit?: ErrorsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ErrorsInclude<ExtArgs> | null
    /**
     * Filter, which Errors to fetch.
     */
    where?: ErrorsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Errors to fetch.
     */
    orderBy?: ErrorsOrderByWithRelationInput | ErrorsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Errors.
     */
    cursor?: ErrorsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Errors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Errors.
     */
    skip?: number
    distinct?: ErrorsScalarFieldEnum | ErrorsScalarFieldEnum[]
  }

  /**
   * Errors create
   */
  export type ErrorsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Errors
     */
    select?: ErrorsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Errors
     */
    omit?: ErrorsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ErrorsInclude<ExtArgs> | null
    /**
     * The data needed to create a Errors.
     */
    data: XOR<ErrorsCreateInput, ErrorsUncheckedCreateInput>
  }

  /**
   * Errors createMany
   */
  export type ErrorsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Errors.
     */
    data: ErrorsCreateManyInput | ErrorsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Errors update
   */
  export type ErrorsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Errors
     */
    select?: ErrorsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Errors
     */
    omit?: ErrorsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ErrorsInclude<ExtArgs> | null
    /**
     * The data needed to update a Errors.
     */
    data: XOR<ErrorsUpdateInput, ErrorsUncheckedUpdateInput>
    /**
     * Choose, which Errors to update.
     */
    where: ErrorsWhereUniqueInput
  }

  /**
   * Errors updateMany
   */
  export type ErrorsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Errors.
     */
    data: XOR<ErrorsUpdateManyMutationInput, ErrorsUncheckedUpdateManyInput>
    /**
     * Filter which Errors to update
     */
    where?: ErrorsWhereInput
    /**
     * Limit how many Errors to update.
     */
    limit?: number
  }

  /**
   * Errors upsert
   */
  export type ErrorsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Errors
     */
    select?: ErrorsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Errors
     */
    omit?: ErrorsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ErrorsInclude<ExtArgs> | null
    /**
     * The filter to search for the Errors to update in case it exists.
     */
    where: ErrorsWhereUniqueInput
    /**
     * In case the Errors found by the `where` argument doesn't exist, create a new Errors with this data.
     */
    create: XOR<ErrorsCreateInput, ErrorsUncheckedCreateInput>
    /**
     * In case the Errors was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ErrorsUpdateInput, ErrorsUncheckedUpdateInput>
  }

  /**
   * Errors delete
   */
  export type ErrorsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Errors
     */
    select?: ErrorsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Errors
     */
    omit?: ErrorsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ErrorsInclude<ExtArgs> | null
    /**
     * Filter which Errors to delete.
     */
    where: ErrorsWhereUniqueInput
  }

  /**
   * Errors deleteMany
   */
  export type ErrorsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Errors to delete
     */
    where?: ErrorsWhereInput
    /**
     * Limit how many Errors to delete.
     */
    limit?: number
  }

  /**
   * Errors without action
   */
  export type ErrorsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Errors
     */
    select?: ErrorsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Errors
     */
    omit?: ErrorsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ErrorsInclude<ExtArgs> | null
  }


  /**
   * Model Views
   */

  export type AggregateViews = {
    _count: ViewsCountAggregateOutputType | null
    _avg: ViewsAvgAggregateOutputType | null
    _sum: ViewsSumAggregateOutputType | null
    _min: ViewsMinAggregateOutputType | null
    _max: ViewsMaxAggregateOutputType | null
  }

  export type ViewsAvgAggregateOutputType = {
    userId: number | null
    comicId: number | null
    chapterId: number | null
  }

  export type ViewsSumAggregateOutputType = {
    userId: number | null
    comicId: number | null
    chapterId: number | null
  }

  export type ViewsMinAggregateOutputType = {
    userId: number | null
    comicId: number | null
    chapterId: number | null
    lastedAt: Date | null
  }

  export type ViewsMaxAggregateOutputType = {
    userId: number | null
    comicId: number | null
    chapterId: number | null
    lastedAt: Date | null
  }

  export type ViewsCountAggregateOutputType = {
    userId: number
    comicId: number
    chapterId: number
    lastedAt: number
    _all: number
  }


  export type ViewsAvgAggregateInputType = {
    userId?: true
    comicId?: true
    chapterId?: true
  }

  export type ViewsSumAggregateInputType = {
    userId?: true
    comicId?: true
    chapterId?: true
  }

  export type ViewsMinAggregateInputType = {
    userId?: true
    comicId?: true
    chapterId?: true
    lastedAt?: true
  }

  export type ViewsMaxAggregateInputType = {
    userId?: true
    comicId?: true
    chapterId?: true
    lastedAt?: true
  }

  export type ViewsCountAggregateInputType = {
    userId?: true
    comicId?: true
    chapterId?: true
    lastedAt?: true
    _all?: true
  }

  export type ViewsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Views to aggregate.
     */
    where?: ViewsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Views to fetch.
     */
    orderBy?: ViewsOrderByWithRelationInput | ViewsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ViewsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Views from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Views.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Views
    **/
    _count?: true | ViewsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ViewsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ViewsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ViewsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ViewsMaxAggregateInputType
  }

  export type GetViewsAggregateType<T extends ViewsAggregateArgs> = {
        [P in keyof T & keyof AggregateViews]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateViews[P]>
      : GetScalarType<T[P], AggregateViews[P]>
  }




  export type ViewsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ViewsWhereInput
    orderBy?: ViewsOrderByWithAggregationInput | ViewsOrderByWithAggregationInput[]
    by: ViewsScalarFieldEnum[] | ViewsScalarFieldEnum
    having?: ViewsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ViewsCountAggregateInputType | true
    _avg?: ViewsAvgAggregateInputType
    _sum?: ViewsSumAggregateInputType
    _min?: ViewsMinAggregateInputType
    _max?: ViewsMaxAggregateInputType
  }

  export type ViewsGroupByOutputType = {
    userId: number
    comicId: number
    chapterId: number
    lastedAt: Date
    _count: ViewsCountAggregateOutputType | null
    _avg: ViewsAvgAggregateOutputType | null
    _sum: ViewsSumAggregateOutputType | null
    _min: ViewsMinAggregateOutputType | null
    _max: ViewsMaxAggregateOutputType | null
  }

  type GetViewsGroupByPayload<T extends ViewsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ViewsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ViewsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ViewsGroupByOutputType[P]>
            : GetScalarType<T[P], ViewsGroupByOutputType[P]>
        }
      >
    >


  export type ViewsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    userId?: boolean
    comicId?: boolean
    chapterId?: boolean
    lastedAt?: boolean
    user?: boolean | UsersDefaultArgs<ExtArgs>
    comic?: boolean | ComicsDefaultArgs<ExtArgs>
    chapter?: boolean | ChaptersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["views"]>



  export type ViewsSelectScalar = {
    userId?: boolean
    comicId?: boolean
    chapterId?: boolean
    lastedAt?: boolean
  }

  export type ViewsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"userId" | "comicId" | "chapterId" | "lastedAt", ExtArgs["result"]["views"]>
  export type ViewsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UsersDefaultArgs<ExtArgs>
    comic?: boolean | ComicsDefaultArgs<ExtArgs>
    chapter?: boolean | ChaptersDefaultArgs<ExtArgs>
  }

  export type $ViewsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Views"
    objects: {
      user: Prisma.$UsersPayload<ExtArgs>
      comic: Prisma.$ComicsPayload<ExtArgs>
      chapter: Prisma.$ChaptersPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      userId: number
      comicId: number
      chapterId: number
      lastedAt: Date
    }, ExtArgs["result"]["views"]>
    composites: {}
  }

  type ViewsGetPayload<S extends boolean | null | undefined | ViewsDefaultArgs> = $Result.GetResult<Prisma.$ViewsPayload, S>

  type ViewsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ViewsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ViewsCountAggregateInputType | true
    }

  export interface ViewsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Views'], meta: { name: 'Views' } }
    /**
     * Find zero or one Views that matches the filter.
     * @param {ViewsFindUniqueArgs} args - Arguments to find a Views
     * @example
     * // Get one Views
     * const views = await prisma.views.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ViewsFindUniqueArgs>(args: SelectSubset<T, ViewsFindUniqueArgs<ExtArgs>>): Prisma__ViewsClient<$Result.GetResult<Prisma.$ViewsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Views that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ViewsFindUniqueOrThrowArgs} args - Arguments to find a Views
     * @example
     * // Get one Views
     * const views = await prisma.views.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ViewsFindUniqueOrThrowArgs>(args: SelectSubset<T, ViewsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ViewsClient<$Result.GetResult<Prisma.$ViewsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Views that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ViewsFindFirstArgs} args - Arguments to find a Views
     * @example
     * // Get one Views
     * const views = await prisma.views.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ViewsFindFirstArgs>(args?: SelectSubset<T, ViewsFindFirstArgs<ExtArgs>>): Prisma__ViewsClient<$Result.GetResult<Prisma.$ViewsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Views that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ViewsFindFirstOrThrowArgs} args - Arguments to find a Views
     * @example
     * // Get one Views
     * const views = await prisma.views.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ViewsFindFirstOrThrowArgs>(args?: SelectSubset<T, ViewsFindFirstOrThrowArgs<ExtArgs>>): Prisma__ViewsClient<$Result.GetResult<Prisma.$ViewsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Views that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ViewsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Views
     * const views = await prisma.views.findMany()
     * 
     * // Get first 10 Views
     * const views = await prisma.views.findMany({ take: 10 })
     * 
     * // Only select the `userId`
     * const viewsWithUserIdOnly = await prisma.views.findMany({ select: { userId: true } })
     * 
     */
    findMany<T extends ViewsFindManyArgs>(args?: SelectSubset<T, ViewsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ViewsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Views.
     * @param {ViewsCreateArgs} args - Arguments to create a Views.
     * @example
     * // Create one Views
     * const Views = await prisma.views.create({
     *   data: {
     *     // ... data to create a Views
     *   }
     * })
     * 
     */
    create<T extends ViewsCreateArgs>(args: SelectSubset<T, ViewsCreateArgs<ExtArgs>>): Prisma__ViewsClient<$Result.GetResult<Prisma.$ViewsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Views.
     * @param {ViewsCreateManyArgs} args - Arguments to create many Views.
     * @example
     * // Create many Views
     * const views = await prisma.views.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ViewsCreateManyArgs>(args?: SelectSubset<T, ViewsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Views.
     * @param {ViewsDeleteArgs} args - Arguments to delete one Views.
     * @example
     * // Delete one Views
     * const Views = await prisma.views.delete({
     *   where: {
     *     // ... filter to delete one Views
     *   }
     * })
     * 
     */
    delete<T extends ViewsDeleteArgs>(args: SelectSubset<T, ViewsDeleteArgs<ExtArgs>>): Prisma__ViewsClient<$Result.GetResult<Prisma.$ViewsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Views.
     * @param {ViewsUpdateArgs} args - Arguments to update one Views.
     * @example
     * // Update one Views
     * const views = await prisma.views.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ViewsUpdateArgs>(args: SelectSubset<T, ViewsUpdateArgs<ExtArgs>>): Prisma__ViewsClient<$Result.GetResult<Prisma.$ViewsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Views.
     * @param {ViewsDeleteManyArgs} args - Arguments to filter Views to delete.
     * @example
     * // Delete a few Views
     * const { count } = await prisma.views.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ViewsDeleteManyArgs>(args?: SelectSubset<T, ViewsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Views.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ViewsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Views
     * const views = await prisma.views.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ViewsUpdateManyArgs>(args: SelectSubset<T, ViewsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Views.
     * @param {ViewsUpsertArgs} args - Arguments to update or create a Views.
     * @example
     * // Update or create a Views
     * const views = await prisma.views.upsert({
     *   create: {
     *     // ... data to create a Views
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Views we want to update
     *   }
     * })
     */
    upsert<T extends ViewsUpsertArgs>(args: SelectSubset<T, ViewsUpsertArgs<ExtArgs>>): Prisma__ViewsClient<$Result.GetResult<Prisma.$ViewsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Views.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ViewsCountArgs} args - Arguments to filter Views to count.
     * @example
     * // Count the number of Views
     * const count = await prisma.views.count({
     *   where: {
     *     // ... the filter for the Views we want to count
     *   }
     * })
    **/
    count<T extends ViewsCountArgs>(
      args?: Subset<T, ViewsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ViewsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Views.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ViewsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ViewsAggregateArgs>(args: Subset<T, ViewsAggregateArgs>): Prisma.PrismaPromise<GetViewsAggregateType<T>>

    /**
     * Group by Views.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ViewsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ViewsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ViewsGroupByArgs['orderBy'] }
        : { orderBy?: ViewsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ViewsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetViewsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Views model
   */
  readonly fields: ViewsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Views.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ViewsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UsersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UsersDefaultArgs<ExtArgs>>): Prisma__UsersClient<$Result.GetResult<Prisma.$UsersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    comic<T extends ComicsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ComicsDefaultArgs<ExtArgs>>): Prisma__ComicsClient<$Result.GetResult<Prisma.$ComicsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    chapter<T extends ChaptersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ChaptersDefaultArgs<ExtArgs>>): Prisma__ChaptersClient<$Result.GetResult<Prisma.$ChaptersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Views model
   */
  interface ViewsFieldRefs {
    readonly userId: FieldRef<"Views", 'Int'>
    readonly comicId: FieldRef<"Views", 'Int'>
    readonly chapterId: FieldRef<"Views", 'Int'>
    readonly lastedAt: FieldRef<"Views", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Views findUnique
   */
  export type ViewsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Views
     */
    select?: ViewsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Views
     */
    omit?: ViewsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ViewsInclude<ExtArgs> | null
    /**
     * Filter, which Views to fetch.
     */
    where: ViewsWhereUniqueInput
  }

  /**
   * Views findUniqueOrThrow
   */
  export type ViewsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Views
     */
    select?: ViewsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Views
     */
    omit?: ViewsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ViewsInclude<ExtArgs> | null
    /**
     * Filter, which Views to fetch.
     */
    where: ViewsWhereUniqueInput
  }

  /**
   * Views findFirst
   */
  export type ViewsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Views
     */
    select?: ViewsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Views
     */
    omit?: ViewsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ViewsInclude<ExtArgs> | null
    /**
     * Filter, which Views to fetch.
     */
    where?: ViewsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Views to fetch.
     */
    orderBy?: ViewsOrderByWithRelationInput | ViewsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Views.
     */
    cursor?: ViewsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Views from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Views.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Views.
     */
    distinct?: ViewsScalarFieldEnum | ViewsScalarFieldEnum[]
  }

  /**
   * Views findFirstOrThrow
   */
  export type ViewsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Views
     */
    select?: ViewsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Views
     */
    omit?: ViewsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ViewsInclude<ExtArgs> | null
    /**
     * Filter, which Views to fetch.
     */
    where?: ViewsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Views to fetch.
     */
    orderBy?: ViewsOrderByWithRelationInput | ViewsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Views.
     */
    cursor?: ViewsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Views from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Views.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Views.
     */
    distinct?: ViewsScalarFieldEnum | ViewsScalarFieldEnum[]
  }

  /**
   * Views findMany
   */
  export type ViewsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Views
     */
    select?: ViewsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Views
     */
    omit?: ViewsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ViewsInclude<ExtArgs> | null
    /**
     * Filter, which Views to fetch.
     */
    where?: ViewsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Views to fetch.
     */
    orderBy?: ViewsOrderByWithRelationInput | ViewsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Views.
     */
    cursor?: ViewsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Views from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Views.
     */
    skip?: number
    distinct?: ViewsScalarFieldEnum | ViewsScalarFieldEnum[]
  }

  /**
   * Views create
   */
  export type ViewsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Views
     */
    select?: ViewsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Views
     */
    omit?: ViewsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ViewsInclude<ExtArgs> | null
    /**
     * The data needed to create a Views.
     */
    data: XOR<ViewsCreateInput, ViewsUncheckedCreateInput>
  }

  /**
   * Views createMany
   */
  export type ViewsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Views.
     */
    data: ViewsCreateManyInput | ViewsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Views update
   */
  export type ViewsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Views
     */
    select?: ViewsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Views
     */
    omit?: ViewsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ViewsInclude<ExtArgs> | null
    /**
     * The data needed to update a Views.
     */
    data: XOR<ViewsUpdateInput, ViewsUncheckedUpdateInput>
    /**
     * Choose, which Views to update.
     */
    where: ViewsWhereUniqueInput
  }

  /**
   * Views updateMany
   */
  export type ViewsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Views.
     */
    data: XOR<ViewsUpdateManyMutationInput, ViewsUncheckedUpdateManyInput>
    /**
     * Filter which Views to update
     */
    where?: ViewsWhereInput
    /**
     * Limit how many Views to update.
     */
    limit?: number
  }

  /**
   * Views upsert
   */
  export type ViewsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Views
     */
    select?: ViewsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Views
     */
    omit?: ViewsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ViewsInclude<ExtArgs> | null
    /**
     * The filter to search for the Views to update in case it exists.
     */
    where: ViewsWhereUniqueInput
    /**
     * In case the Views found by the `where` argument doesn't exist, create a new Views with this data.
     */
    create: XOR<ViewsCreateInput, ViewsUncheckedCreateInput>
    /**
     * In case the Views was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ViewsUpdateInput, ViewsUncheckedUpdateInput>
  }

  /**
   * Views delete
   */
  export type ViewsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Views
     */
    select?: ViewsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Views
     */
    omit?: ViewsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ViewsInclude<ExtArgs> | null
    /**
     * Filter which Views to delete.
     */
    where: ViewsWhereUniqueInput
  }

  /**
   * Views deleteMany
   */
  export type ViewsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Views to delete
     */
    where?: ViewsWhereInput
    /**
     * Limit how many Views to delete.
     */
    limit?: number
  }

  /**
   * Views without action
   */
  export type ViewsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Views
     */
    select?: ViewsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Views
     */
    omit?: ViewsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ViewsInclude<ExtArgs> | null
  }


  /**
   * Model Comments
   */

  export type AggregateComments = {
    _count: CommentsCountAggregateOutputType | null
    _avg: CommentsAvgAggregateOutputType | null
    _sum: CommentsSumAggregateOutputType | null
    _min: CommentsMinAggregateOutputType | null
    _max: CommentsMaxAggregateOutputType | null
  }

  export type CommentsAvgAggregateOutputType = {
    id: number | null
    userId: number | null
    chapterId: number | null
    comicId: number | null
  }

  export type CommentsSumAggregateOutputType = {
    id: number | null
    userId: number | null
    chapterId: number | null
    comicId: number | null
  }

  export type CommentsMinAggregateOutputType = {
    id: number | null
    content: string | null
    userId: number | null
    chapterId: number | null
    comicId: number | null
    createdAt: Date | null
  }

  export type CommentsMaxAggregateOutputType = {
    id: number | null
    content: string | null
    userId: number | null
    chapterId: number | null
    comicId: number | null
    createdAt: Date | null
  }

  export type CommentsCountAggregateOutputType = {
    id: number
    content: number
    userId: number
    chapterId: number
    comicId: number
    createdAt: number
    _all: number
  }


  export type CommentsAvgAggregateInputType = {
    id?: true
    userId?: true
    chapterId?: true
    comicId?: true
  }

  export type CommentsSumAggregateInputType = {
    id?: true
    userId?: true
    chapterId?: true
    comicId?: true
  }

  export type CommentsMinAggregateInputType = {
    id?: true
    content?: true
    userId?: true
    chapterId?: true
    comicId?: true
    createdAt?: true
  }

  export type CommentsMaxAggregateInputType = {
    id?: true
    content?: true
    userId?: true
    chapterId?: true
    comicId?: true
    createdAt?: true
  }

  export type CommentsCountAggregateInputType = {
    id?: true
    content?: true
    userId?: true
    chapterId?: true
    comicId?: true
    createdAt?: true
    _all?: true
  }

  export type CommentsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Comments to aggregate.
     */
    where?: CommentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Comments to fetch.
     */
    orderBy?: CommentsOrderByWithRelationInput | CommentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CommentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Comments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Comments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Comments
    **/
    _count?: true | CommentsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CommentsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CommentsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CommentsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CommentsMaxAggregateInputType
  }

  export type GetCommentsAggregateType<T extends CommentsAggregateArgs> = {
        [P in keyof T & keyof AggregateComments]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateComments[P]>
      : GetScalarType<T[P], AggregateComments[P]>
  }




  export type CommentsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CommentsWhereInput
    orderBy?: CommentsOrderByWithAggregationInput | CommentsOrderByWithAggregationInput[]
    by: CommentsScalarFieldEnum[] | CommentsScalarFieldEnum
    having?: CommentsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CommentsCountAggregateInputType | true
    _avg?: CommentsAvgAggregateInputType
    _sum?: CommentsSumAggregateInputType
    _min?: CommentsMinAggregateInputType
    _max?: CommentsMaxAggregateInputType
  }

  export type CommentsGroupByOutputType = {
    id: number
    content: string
    userId: number
    chapterId: number | null
    comicId: number
    createdAt: Date
    _count: CommentsCountAggregateOutputType | null
    _avg: CommentsAvgAggregateOutputType | null
    _sum: CommentsSumAggregateOutputType | null
    _min: CommentsMinAggregateOutputType | null
    _max: CommentsMaxAggregateOutputType | null
  }

  type GetCommentsGroupByPayload<T extends CommentsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CommentsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CommentsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CommentsGroupByOutputType[P]>
            : GetScalarType<T[P], CommentsGroupByOutputType[P]>
        }
      >
    >


  export type CommentsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    content?: boolean
    userId?: boolean
    chapterId?: boolean
    comicId?: boolean
    createdAt?: boolean
    user?: boolean | UsersDefaultArgs<ExtArgs>
    chapter?: boolean | Comments$chapterArgs<ExtArgs>
    comic?: boolean | ComicsDefaultArgs<ExtArgs>
    notification?: boolean | Comments$notificationArgs<ExtArgs>
    _count?: boolean | CommentsCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["comments"]>



  export type CommentsSelectScalar = {
    id?: boolean
    content?: boolean
    userId?: boolean
    chapterId?: boolean
    comicId?: boolean
    createdAt?: boolean
  }

  export type CommentsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "content" | "userId" | "chapterId" | "comicId" | "createdAt", ExtArgs["result"]["comments"]>
  export type CommentsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UsersDefaultArgs<ExtArgs>
    chapter?: boolean | Comments$chapterArgs<ExtArgs>
    comic?: boolean | ComicsDefaultArgs<ExtArgs>
    notification?: boolean | Comments$notificationArgs<ExtArgs>
    _count?: boolean | CommentsCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $CommentsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Comments"
    objects: {
      user: Prisma.$UsersPayload<ExtArgs>
      chapter: Prisma.$ChaptersPayload<ExtArgs> | null
      comic: Prisma.$ComicsPayload<ExtArgs>
      notification: Prisma.$NotificationsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      content: string
      userId: number
      chapterId: number | null
      comicId: number
      createdAt: Date
    }, ExtArgs["result"]["comments"]>
    composites: {}
  }

  type CommentsGetPayload<S extends boolean | null | undefined | CommentsDefaultArgs> = $Result.GetResult<Prisma.$CommentsPayload, S>

  type CommentsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CommentsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CommentsCountAggregateInputType | true
    }

  export interface CommentsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Comments'], meta: { name: 'Comments' } }
    /**
     * Find zero or one Comments that matches the filter.
     * @param {CommentsFindUniqueArgs} args - Arguments to find a Comments
     * @example
     * // Get one Comments
     * const comments = await prisma.comments.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CommentsFindUniqueArgs>(args: SelectSubset<T, CommentsFindUniqueArgs<ExtArgs>>): Prisma__CommentsClient<$Result.GetResult<Prisma.$CommentsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Comments that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CommentsFindUniqueOrThrowArgs} args - Arguments to find a Comments
     * @example
     * // Get one Comments
     * const comments = await prisma.comments.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CommentsFindUniqueOrThrowArgs>(args: SelectSubset<T, CommentsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CommentsClient<$Result.GetResult<Prisma.$CommentsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Comments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentsFindFirstArgs} args - Arguments to find a Comments
     * @example
     * // Get one Comments
     * const comments = await prisma.comments.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CommentsFindFirstArgs>(args?: SelectSubset<T, CommentsFindFirstArgs<ExtArgs>>): Prisma__CommentsClient<$Result.GetResult<Prisma.$CommentsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Comments that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentsFindFirstOrThrowArgs} args - Arguments to find a Comments
     * @example
     * // Get one Comments
     * const comments = await prisma.comments.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CommentsFindFirstOrThrowArgs>(args?: SelectSubset<T, CommentsFindFirstOrThrowArgs<ExtArgs>>): Prisma__CommentsClient<$Result.GetResult<Prisma.$CommentsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Comments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Comments
     * const comments = await prisma.comments.findMany()
     * 
     * // Get first 10 Comments
     * const comments = await prisma.comments.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const commentsWithIdOnly = await prisma.comments.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CommentsFindManyArgs>(args?: SelectSubset<T, CommentsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommentsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Comments.
     * @param {CommentsCreateArgs} args - Arguments to create a Comments.
     * @example
     * // Create one Comments
     * const Comments = await prisma.comments.create({
     *   data: {
     *     // ... data to create a Comments
     *   }
     * })
     * 
     */
    create<T extends CommentsCreateArgs>(args: SelectSubset<T, CommentsCreateArgs<ExtArgs>>): Prisma__CommentsClient<$Result.GetResult<Prisma.$CommentsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Comments.
     * @param {CommentsCreateManyArgs} args - Arguments to create many Comments.
     * @example
     * // Create many Comments
     * const comments = await prisma.comments.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CommentsCreateManyArgs>(args?: SelectSubset<T, CommentsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Comments.
     * @param {CommentsDeleteArgs} args - Arguments to delete one Comments.
     * @example
     * // Delete one Comments
     * const Comments = await prisma.comments.delete({
     *   where: {
     *     // ... filter to delete one Comments
     *   }
     * })
     * 
     */
    delete<T extends CommentsDeleteArgs>(args: SelectSubset<T, CommentsDeleteArgs<ExtArgs>>): Prisma__CommentsClient<$Result.GetResult<Prisma.$CommentsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Comments.
     * @param {CommentsUpdateArgs} args - Arguments to update one Comments.
     * @example
     * // Update one Comments
     * const comments = await prisma.comments.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CommentsUpdateArgs>(args: SelectSubset<T, CommentsUpdateArgs<ExtArgs>>): Prisma__CommentsClient<$Result.GetResult<Prisma.$CommentsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Comments.
     * @param {CommentsDeleteManyArgs} args - Arguments to filter Comments to delete.
     * @example
     * // Delete a few Comments
     * const { count } = await prisma.comments.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CommentsDeleteManyArgs>(args?: SelectSubset<T, CommentsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Comments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Comments
     * const comments = await prisma.comments.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CommentsUpdateManyArgs>(args: SelectSubset<T, CommentsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Comments.
     * @param {CommentsUpsertArgs} args - Arguments to update or create a Comments.
     * @example
     * // Update or create a Comments
     * const comments = await prisma.comments.upsert({
     *   create: {
     *     // ... data to create a Comments
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Comments we want to update
     *   }
     * })
     */
    upsert<T extends CommentsUpsertArgs>(args: SelectSubset<T, CommentsUpsertArgs<ExtArgs>>): Prisma__CommentsClient<$Result.GetResult<Prisma.$CommentsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Comments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentsCountArgs} args - Arguments to filter Comments to count.
     * @example
     * // Count the number of Comments
     * const count = await prisma.comments.count({
     *   where: {
     *     // ... the filter for the Comments we want to count
     *   }
     * })
    **/
    count<T extends CommentsCountArgs>(
      args?: Subset<T, CommentsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CommentsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Comments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CommentsAggregateArgs>(args: Subset<T, CommentsAggregateArgs>): Prisma.PrismaPromise<GetCommentsAggregateType<T>>

    /**
     * Group by Comments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CommentsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CommentsGroupByArgs['orderBy'] }
        : { orderBy?: CommentsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CommentsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCommentsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Comments model
   */
  readonly fields: CommentsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Comments.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CommentsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UsersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UsersDefaultArgs<ExtArgs>>): Prisma__UsersClient<$Result.GetResult<Prisma.$UsersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    chapter<T extends Comments$chapterArgs<ExtArgs> = {}>(args?: Subset<T, Comments$chapterArgs<ExtArgs>>): Prisma__ChaptersClient<$Result.GetResult<Prisma.$ChaptersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    comic<T extends ComicsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ComicsDefaultArgs<ExtArgs>>): Prisma__ComicsClient<$Result.GetResult<Prisma.$ComicsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    notification<T extends Comments$notificationArgs<ExtArgs> = {}>(args?: Subset<T, Comments$notificationArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Comments model
   */
  interface CommentsFieldRefs {
    readonly id: FieldRef<"Comments", 'Int'>
    readonly content: FieldRef<"Comments", 'String'>
    readonly userId: FieldRef<"Comments", 'Int'>
    readonly chapterId: FieldRef<"Comments", 'Int'>
    readonly comicId: FieldRef<"Comments", 'Int'>
    readonly createdAt: FieldRef<"Comments", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Comments findUnique
   */
  export type CommentsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comments
     */
    select?: CommentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comments
     */
    omit?: CommentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentsInclude<ExtArgs> | null
    /**
     * Filter, which Comments to fetch.
     */
    where: CommentsWhereUniqueInput
  }

  /**
   * Comments findUniqueOrThrow
   */
  export type CommentsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comments
     */
    select?: CommentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comments
     */
    omit?: CommentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentsInclude<ExtArgs> | null
    /**
     * Filter, which Comments to fetch.
     */
    where: CommentsWhereUniqueInput
  }

  /**
   * Comments findFirst
   */
  export type CommentsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comments
     */
    select?: CommentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comments
     */
    omit?: CommentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentsInclude<ExtArgs> | null
    /**
     * Filter, which Comments to fetch.
     */
    where?: CommentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Comments to fetch.
     */
    orderBy?: CommentsOrderByWithRelationInput | CommentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Comments.
     */
    cursor?: CommentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Comments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Comments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Comments.
     */
    distinct?: CommentsScalarFieldEnum | CommentsScalarFieldEnum[]
  }

  /**
   * Comments findFirstOrThrow
   */
  export type CommentsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comments
     */
    select?: CommentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comments
     */
    omit?: CommentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentsInclude<ExtArgs> | null
    /**
     * Filter, which Comments to fetch.
     */
    where?: CommentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Comments to fetch.
     */
    orderBy?: CommentsOrderByWithRelationInput | CommentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Comments.
     */
    cursor?: CommentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Comments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Comments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Comments.
     */
    distinct?: CommentsScalarFieldEnum | CommentsScalarFieldEnum[]
  }

  /**
   * Comments findMany
   */
  export type CommentsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comments
     */
    select?: CommentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comments
     */
    omit?: CommentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentsInclude<ExtArgs> | null
    /**
     * Filter, which Comments to fetch.
     */
    where?: CommentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Comments to fetch.
     */
    orderBy?: CommentsOrderByWithRelationInput | CommentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Comments.
     */
    cursor?: CommentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Comments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Comments.
     */
    skip?: number
    distinct?: CommentsScalarFieldEnum | CommentsScalarFieldEnum[]
  }

  /**
   * Comments create
   */
  export type CommentsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comments
     */
    select?: CommentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comments
     */
    omit?: CommentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentsInclude<ExtArgs> | null
    /**
     * The data needed to create a Comments.
     */
    data: XOR<CommentsCreateInput, CommentsUncheckedCreateInput>
  }

  /**
   * Comments createMany
   */
  export type CommentsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Comments.
     */
    data: CommentsCreateManyInput | CommentsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Comments update
   */
  export type CommentsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comments
     */
    select?: CommentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comments
     */
    omit?: CommentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentsInclude<ExtArgs> | null
    /**
     * The data needed to update a Comments.
     */
    data: XOR<CommentsUpdateInput, CommentsUncheckedUpdateInput>
    /**
     * Choose, which Comments to update.
     */
    where: CommentsWhereUniqueInput
  }

  /**
   * Comments updateMany
   */
  export type CommentsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Comments.
     */
    data: XOR<CommentsUpdateManyMutationInput, CommentsUncheckedUpdateManyInput>
    /**
     * Filter which Comments to update
     */
    where?: CommentsWhereInput
    /**
     * Limit how many Comments to update.
     */
    limit?: number
  }

  /**
   * Comments upsert
   */
  export type CommentsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comments
     */
    select?: CommentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comments
     */
    omit?: CommentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentsInclude<ExtArgs> | null
    /**
     * The filter to search for the Comments to update in case it exists.
     */
    where: CommentsWhereUniqueInput
    /**
     * In case the Comments found by the `where` argument doesn't exist, create a new Comments with this data.
     */
    create: XOR<CommentsCreateInput, CommentsUncheckedCreateInput>
    /**
     * In case the Comments was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CommentsUpdateInput, CommentsUncheckedUpdateInput>
  }

  /**
   * Comments delete
   */
  export type CommentsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comments
     */
    select?: CommentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comments
     */
    omit?: CommentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentsInclude<ExtArgs> | null
    /**
     * Filter which Comments to delete.
     */
    where: CommentsWhereUniqueInput
  }

  /**
   * Comments deleteMany
   */
  export type CommentsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Comments to delete
     */
    where?: CommentsWhereInput
    /**
     * Limit how many Comments to delete.
     */
    limit?: number
  }

  /**
   * Comments.chapter
   */
  export type Comments$chapterArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chapters
     */
    select?: ChaptersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Chapters
     */
    omit?: ChaptersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChaptersInclude<ExtArgs> | null
    where?: ChaptersWhereInput
  }

  /**
   * Comments.notification
   */
  export type Comments$notificationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notifications
     */
    select?: NotificationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notifications
     */
    omit?: NotificationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationsInclude<ExtArgs> | null
    where?: NotificationsWhereInput
    orderBy?: NotificationsOrderByWithRelationInput | NotificationsOrderByWithRelationInput[]
    cursor?: NotificationsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NotificationsScalarFieldEnum | NotificationsScalarFieldEnum[]
  }

  /**
   * Comments without action
   */
  export type CommentsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comments
     */
    select?: CommentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comments
     */
    omit?: CommentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentsInclude<ExtArgs> | null
  }


  /**
   * Model Notifications
   */

  export type AggregateNotifications = {
    _count: NotificationsCountAggregateOutputType | null
    _avg: NotificationsAvgAggregateOutputType | null
    _sum: NotificationsSumAggregateOutputType | null
    _min: NotificationsMinAggregateOutputType | null
    _max: NotificationsMaxAggregateOutputType | null
  }

  export type NotificationsAvgAggregateOutputType = {
    id: number | null
    userId: number | null
    commentId: number | null
  }

  export type NotificationsSumAggregateOutputType = {
    id: number | null
    userId: number | null
    commentId: number | null
  }

  export type NotificationsMinAggregateOutputType = {
    id: number | null
    userId: number | null
    commentId: number | null
    content: string | null
    isRead: boolean | null
    createdAt: Date | null
  }

  export type NotificationsMaxAggregateOutputType = {
    id: number | null
    userId: number | null
    commentId: number | null
    content: string | null
    isRead: boolean | null
    createdAt: Date | null
  }

  export type NotificationsCountAggregateOutputType = {
    id: number
    userId: number
    commentId: number
    content: number
    isRead: number
    createdAt: number
    _all: number
  }


  export type NotificationsAvgAggregateInputType = {
    id?: true
    userId?: true
    commentId?: true
  }

  export type NotificationsSumAggregateInputType = {
    id?: true
    userId?: true
    commentId?: true
  }

  export type NotificationsMinAggregateInputType = {
    id?: true
    userId?: true
    commentId?: true
    content?: true
    isRead?: true
    createdAt?: true
  }

  export type NotificationsMaxAggregateInputType = {
    id?: true
    userId?: true
    commentId?: true
    content?: true
    isRead?: true
    createdAt?: true
  }

  export type NotificationsCountAggregateInputType = {
    id?: true
    userId?: true
    commentId?: true
    content?: true
    isRead?: true
    createdAt?: true
    _all?: true
  }

  export type NotificationsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Notifications to aggregate.
     */
    where?: NotificationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationsOrderByWithRelationInput | NotificationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NotificationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Notifications
    **/
    _count?: true | NotificationsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: NotificationsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: NotificationsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NotificationsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NotificationsMaxAggregateInputType
  }

  export type GetNotificationsAggregateType<T extends NotificationsAggregateArgs> = {
        [P in keyof T & keyof AggregateNotifications]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNotifications[P]>
      : GetScalarType<T[P], AggregateNotifications[P]>
  }




  export type NotificationsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationsWhereInput
    orderBy?: NotificationsOrderByWithAggregationInput | NotificationsOrderByWithAggregationInput[]
    by: NotificationsScalarFieldEnum[] | NotificationsScalarFieldEnum
    having?: NotificationsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NotificationsCountAggregateInputType | true
    _avg?: NotificationsAvgAggregateInputType
    _sum?: NotificationsSumAggregateInputType
    _min?: NotificationsMinAggregateInputType
    _max?: NotificationsMaxAggregateInputType
  }

  export type NotificationsGroupByOutputType = {
    id: number
    userId: number
    commentId: number | null
    content: string
    isRead: boolean
    createdAt: Date
    _count: NotificationsCountAggregateOutputType | null
    _avg: NotificationsAvgAggregateOutputType | null
    _sum: NotificationsSumAggregateOutputType | null
    _min: NotificationsMinAggregateOutputType | null
    _max: NotificationsMaxAggregateOutputType | null
  }

  type GetNotificationsGroupByPayload<T extends NotificationsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NotificationsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NotificationsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NotificationsGroupByOutputType[P]>
            : GetScalarType<T[P], NotificationsGroupByOutputType[P]>
        }
      >
    >


  export type NotificationsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    commentId?: boolean
    content?: boolean
    isRead?: boolean
    createdAt?: boolean
    user?: boolean | UsersDefaultArgs<ExtArgs>
    comment?: boolean | Notifications$commentArgs<ExtArgs>
  }, ExtArgs["result"]["notifications"]>



  export type NotificationsSelectScalar = {
    id?: boolean
    userId?: boolean
    commentId?: boolean
    content?: boolean
    isRead?: boolean
    createdAt?: boolean
  }

  export type NotificationsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "commentId" | "content" | "isRead" | "createdAt", ExtArgs["result"]["notifications"]>
  export type NotificationsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UsersDefaultArgs<ExtArgs>
    comment?: boolean | Notifications$commentArgs<ExtArgs>
  }

  export type $NotificationsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Notifications"
    objects: {
      user: Prisma.$UsersPayload<ExtArgs>
      comment: Prisma.$CommentsPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      userId: number
      commentId: number | null
      content: string
      isRead: boolean
      createdAt: Date
    }, ExtArgs["result"]["notifications"]>
    composites: {}
  }

  type NotificationsGetPayload<S extends boolean | null | undefined | NotificationsDefaultArgs> = $Result.GetResult<Prisma.$NotificationsPayload, S>

  type NotificationsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<NotificationsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: NotificationsCountAggregateInputType | true
    }

  export interface NotificationsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Notifications'], meta: { name: 'Notifications' } }
    /**
     * Find zero or one Notifications that matches the filter.
     * @param {NotificationsFindUniqueArgs} args - Arguments to find a Notifications
     * @example
     * // Get one Notifications
     * const notifications = await prisma.notifications.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends NotificationsFindUniqueArgs>(args: SelectSubset<T, NotificationsFindUniqueArgs<ExtArgs>>): Prisma__NotificationsClient<$Result.GetResult<Prisma.$NotificationsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Notifications that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {NotificationsFindUniqueOrThrowArgs} args - Arguments to find a Notifications
     * @example
     * // Get one Notifications
     * const notifications = await prisma.notifications.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends NotificationsFindUniqueOrThrowArgs>(args: SelectSubset<T, NotificationsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__NotificationsClient<$Result.GetResult<Prisma.$NotificationsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Notifications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationsFindFirstArgs} args - Arguments to find a Notifications
     * @example
     * // Get one Notifications
     * const notifications = await prisma.notifications.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends NotificationsFindFirstArgs>(args?: SelectSubset<T, NotificationsFindFirstArgs<ExtArgs>>): Prisma__NotificationsClient<$Result.GetResult<Prisma.$NotificationsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Notifications that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationsFindFirstOrThrowArgs} args - Arguments to find a Notifications
     * @example
     * // Get one Notifications
     * const notifications = await prisma.notifications.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends NotificationsFindFirstOrThrowArgs>(args?: SelectSubset<T, NotificationsFindFirstOrThrowArgs<ExtArgs>>): Prisma__NotificationsClient<$Result.GetResult<Prisma.$NotificationsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Notifications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Notifications
     * const notifications = await prisma.notifications.findMany()
     * 
     * // Get first 10 Notifications
     * const notifications = await prisma.notifications.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const notificationsWithIdOnly = await prisma.notifications.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends NotificationsFindManyArgs>(args?: SelectSubset<T, NotificationsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Notifications.
     * @param {NotificationsCreateArgs} args - Arguments to create a Notifications.
     * @example
     * // Create one Notifications
     * const Notifications = await prisma.notifications.create({
     *   data: {
     *     // ... data to create a Notifications
     *   }
     * })
     * 
     */
    create<T extends NotificationsCreateArgs>(args: SelectSubset<T, NotificationsCreateArgs<ExtArgs>>): Prisma__NotificationsClient<$Result.GetResult<Prisma.$NotificationsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Notifications.
     * @param {NotificationsCreateManyArgs} args - Arguments to create many Notifications.
     * @example
     * // Create many Notifications
     * const notifications = await prisma.notifications.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends NotificationsCreateManyArgs>(args?: SelectSubset<T, NotificationsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Notifications.
     * @param {NotificationsDeleteArgs} args - Arguments to delete one Notifications.
     * @example
     * // Delete one Notifications
     * const Notifications = await prisma.notifications.delete({
     *   where: {
     *     // ... filter to delete one Notifications
     *   }
     * })
     * 
     */
    delete<T extends NotificationsDeleteArgs>(args: SelectSubset<T, NotificationsDeleteArgs<ExtArgs>>): Prisma__NotificationsClient<$Result.GetResult<Prisma.$NotificationsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Notifications.
     * @param {NotificationsUpdateArgs} args - Arguments to update one Notifications.
     * @example
     * // Update one Notifications
     * const notifications = await prisma.notifications.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends NotificationsUpdateArgs>(args: SelectSubset<T, NotificationsUpdateArgs<ExtArgs>>): Prisma__NotificationsClient<$Result.GetResult<Prisma.$NotificationsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Notifications.
     * @param {NotificationsDeleteManyArgs} args - Arguments to filter Notifications to delete.
     * @example
     * // Delete a few Notifications
     * const { count } = await prisma.notifications.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends NotificationsDeleteManyArgs>(args?: SelectSubset<T, NotificationsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Notifications
     * const notifications = await prisma.notifications.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends NotificationsUpdateManyArgs>(args: SelectSubset<T, NotificationsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Notifications.
     * @param {NotificationsUpsertArgs} args - Arguments to update or create a Notifications.
     * @example
     * // Update or create a Notifications
     * const notifications = await prisma.notifications.upsert({
     *   create: {
     *     // ... data to create a Notifications
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Notifications we want to update
     *   }
     * })
     */
    upsert<T extends NotificationsUpsertArgs>(args: SelectSubset<T, NotificationsUpsertArgs<ExtArgs>>): Prisma__NotificationsClient<$Result.GetResult<Prisma.$NotificationsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationsCountArgs} args - Arguments to filter Notifications to count.
     * @example
     * // Count the number of Notifications
     * const count = await prisma.notifications.count({
     *   where: {
     *     // ... the filter for the Notifications we want to count
     *   }
     * })
    **/
    count<T extends NotificationsCountArgs>(
      args?: Subset<T, NotificationsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NotificationsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NotificationsAggregateArgs>(args: Subset<T, NotificationsAggregateArgs>): Prisma.PrismaPromise<GetNotificationsAggregateType<T>>

    /**
     * Group by Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NotificationsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NotificationsGroupByArgs['orderBy'] }
        : { orderBy?: NotificationsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NotificationsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNotificationsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Notifications model
   */
  readonly fields: NotificationsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Notifications.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NotificationsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UsersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UsersDefaultArgs<ExtArgs>>): Prisma__UsersClient<$Result.GetResult<Prisma.$UsersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    comment<T extends Notifications$commentArgs<ExtArgs> = {}>(args?: Subset<T, Notifications$commentArgs<ExtArgs>>): Prisma__CommentsClient<$Result.GetResult<Prisma.$CommentsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Notifications model
   */
  interface NotificationsFieldRefs {
    readonly id: FieldRef<"Notifications", 'Int'>
    readonly userId: FieldRef<"Notifications", 'Int'>
    readonly commentId: FieldRef<"Notifications", 'Int'>
    readonly content: FieldRef<"Notifications", 'String'>
    readonly isRead: FieldRef<"Notifications", 'Boolean'>
    readonly createdAt: FieldRef<"Notifications", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Notifications findUnique
   */
  export type NotificationsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notifications
     */
    select?: NotificationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notifications
     */
    omit?: NotificationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationsInclude<ExtArgs> | null
    /**
     * Filter, which Notifications to fetch.
     */
    where: NotificationsWhereUniqueInput
  }

  /**
   * Notifications findUniqueOrThrow
   */
  export type NotificationsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notifications
     */
    select?: NotificationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notifications
     */
    omit?: NotificationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationsInclude<ExtArgs> | null
    /**
     * Filter, which Notifications to fetch.
     */
    where: NotificationsWhereUniqueInput
  }

  /**
   * Notifications findFirst
   */
  export type NotificationsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notifications
     */
    select?: NotificationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notifications
     */
    omit?: NotificationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationsInclude<ExtArgs> | null
    /**
     * Filter, which Notifications to fetch.
     */
    where?: NotificationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationsOrderByWithRelationInput | NotificationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notifications.
     */
    cursor?: NotificationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notifications.
     */
    distinct?: NotificationsScalarFieldEnum | NotificationsScalarFieldEnum[]
  }

  /**
   * Notifications findFirstOrThrow
   */
  export type NotificationsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notifications
     */
    select?: NotificationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notifications
     */
    omit?: NotificationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationsInclude<ExtArgs> | null
    /**
     * Filter, which Notifications to fetch.
     */
    where?: NotificationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationsOrderByWithRelationInput | NotificationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notifications.
     */
    cursor?: NotificationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notifications.
     */
    distinct?: NotificationsScalarFieldEnum | NotificationsScalarFieldEnum[]
  }

  /**
   * Notifications findMany
   */
  export type NotificationsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notifications
     */
    select?: NotificationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notifications
     */
    omit?: NotificationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationsInclude<ExtArgs> | null
    /**
     * Filter, which Notifications to fetch.
     */
    where?: NotificationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationsOrderByWithRelationInput | NotificationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Notifications.
     */
    cursor?: NotificationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    distinct?: NotificationsScalarFieldEnum | NotificationsScalarFieldEnum[]
  }

  /**
   * Notifications create
   */
  export type NotificationsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notifications
     */
    select?: NotificationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notifications
     */
    omit?: NotificationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationsInclude<ExtArgs> | null
    /**
     * The data needed to create a Notifications.
     */
    data: XOR<NotificationsCreateInput, NotificationsUncheckedCreateInput>
  }

  /**
   * Notifications createMany
   */
  export type NotificationsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Notifications.
     */
    data: NotificationsCreateManyInput | NotificationsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Notifications update
   */
  export type NotificationsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notifications
     */
    select?: NotificationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notifications
     */
    omit?: NotificationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationsInclude<ExtArgs> | null
    /**
     * The data needed to update a Notifications.
     */
    data: XOR<NotificationsUpdateInput, NotificationsUncheckedUpdateInput>
    /**
     * Choose, which Notifications to update.
     */
    where: NotificationsWhereUniqueInput
  }

  /**
   * Notifications updateMany
   */
  export type NotificationsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Notifications.
     */
    data: XOR<NotificationsUpdateManyMutationInput, NotificationsUncheckedUpdateManyInput>
    /**
     * Filter which Notifications to update
     */
    where?: NotificationsWhereInput
    /**
     * Limit how many Notifications to update.
     */
    limit?: number
  }

  /**
   * Notifications upsert
   */
  export type NotificationsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notifications
     */
    select?: NotificationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notifications
     */
    omit?: NotificationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationsInclude<ExtArgs> | null
    /**
     * The filter to search for the Notifications to update in case it exists.
     */
    where: NotificationsWhereUniqueInput
    /**
     * In case the Notifications found by the `where` argument doesn't exist, create a new Notifications with this data.
     */
    create: XOR<NotificationsCreateInput, NotificationsUncheckedCreateInput>
    /**
     * In case the Notifications was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NotificationsUpdateInput, NotificationsUncheckedUpdateInput>
  }

  /**
   * Notifications delete
   */
  export type NotificationsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notifications
     */
    select?: NotificationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notifications
     */
    omit?: NotificationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationsInclude<ExtArgs> | null
    /**
     * Filter which Notifications to delete.
     */
    where: NotificationsWhereUniqueInput
  }

  /**
   * Notifications deleteMany
   */
  export type NotificationsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Notifications to delete
     */
    where?: NotificationsWhereInput
    /**
     * Limit how many Notifications to delete.
     */
    limit?: number
  }

  /**
   * Notifications.comment
   */
  export type Notifications$commentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comments
     */
    select?: CommentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comments
     */
    omit?: CommentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentsInclude<ExtArgs> | null
    where?: CommentsWhereInput
  }

  /**
   * Notifications without action
   */
  export type NotificationsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notifications
     */
    select?: NotificationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notifications
     */
    omit?: NotificationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationsInclude<ExtArgs> | null
  }


  /**
   * Model Wallets
   */

  export type AggregateWallets = {
    _count: WalletsCountAggregateOutputType | null
    _avg: WalletsAvgAggregateOutputType | null
    _sum: WalletsSumAggregateOutputType | null
    _min: WalletsMinAggregateOutputType | null
    _max: WalletsMaxAggregateOutputType | null
  }

  export type WalletsAvgAggregateOutputType = {
    id: number | null
    userId: number | null
    value: Decimal | null
  }

  export type WalletsSumAggregateOutputType = {
    id: number | null
    userId: number | null
    value: Decimal | null
  }

  export type WalletsMinAggregateOutputType = {
    id: number | null
    userId: number | null
    value: Decimal | null
    updatedAt: Date | null
  }

  export type WalletsMaxAggregateOutputType = {
    id: number | null
    userId: number | null
    value: Decimal | null
    updatedAt: Date | null
  }

  export type WalletsCountAggregateOutputType = {
    id: number
    userId: number
    value: number
    updatedAt: number
    _all: number
  }


  export type WalletsAvgAggregateInputType = {
    id?: true
    userId?: true
    value?: true
  }

  export type WalletsSumAggregateInputType = {
    id?: true
    userId?: true
    value?: true
  }

  export type WalletsMinAggregateInputType = {
    id?: true
    userId?: true
    value?: true
    updatedAt?: true
  }

  export type WalletsMaxAggregateInputType = {
    id?: true
    userId?: true
    value?: true
    updatedAt?: true
  }

  export type WalletsCountAggregateInputType = {
    id?: true
    userId?: true
    value?: true
    updatedAt?: true
    _all?: true
  }

  export type WalletsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Wallets to aggregate.
     */
    where?: WalletsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Wallets to fetch.
     */
    orderBy?: WalletsOrderByWithRelationInput | WalletsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WalletsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Wallets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Wallets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Wallets
    **/
    _count?: true | WalletsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: WalletsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: WalletsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WalletsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WalletsMaxAggregateInputType
  }

  export type GetWalletsAggregateType<T extends WalletsAggregateArgs> = {
        [P in keyof T & keyof AggregateWallets]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWallets[P]>
      : GetScalarType<T[P], AggregateWallets[P]>
  }




  export type WalletsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WalletsWhereInput
    orderBy?: WalletsOrderByWithAggregationInput | WalletsOrderByWithAggregationInput[]
    by: WalletsScalarFieldEnum[] | WalletsScalarFieldEnum
    having?: WalletsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WalletsCountAggregateInputType | true
    _avg?: WalletsAvgAggregateInputType
    _sum?: WalletsSumAggregateInputType
    _min?: WalletsMinAggregateInputType
    _max?: WalletsMaxAggregateInputType
  }

  export type WalletsGroupByOutputType = {
    id: number
    userId: number
    value: Decimal
    updatedAt: Date
    _count: WalletsCountAggregateOutputType | null
    _avg: WalletsAvgAggregateOutputType | null
    _sum: WalletsSumAggregateOutputType | null
    _min: WalletsMinAggregateOutputType | null
    _max: WalletsMaxAggregateOutputType | null
  }

  type GetWalletsGroupByPayload<T extends WalletsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WalletsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WalletsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WalletsGroupByOutputType[P]>
            : GetScalarType<T[P], WalletsGroupByOutputType[P]>
        }
      >
    >


  export type WalletsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    value?: boolean
    updatedAt?: boolean
    user?: boolean | UsersDefaultArgs<ExtArgs>
    transactions?: boolean | Wallets$transactionsArgs<ExtArgs>
    _count?: boolean | WalletsCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["wallets"]>



  export type WalletsSelectScalar = {
    id?: boolean
    userId?: boolean
    value?: boolean
    updatedAt?: boolean
  }

  export type WalletsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "value" | "updatedAt", ExtArgs["result"]["wallets"]>
  export type WalletsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UsersDefaultArgs<ExtArgs>
    transactions?: boolean | Wallets$transactionsArgs<ExtArgs>
    _count?: boolean | WalletsCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $WalletsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Wallets"
    objects: {
      user: Prisma.$UsersPayload<ExtArgs>
      transactions: Prisma.$TransactionsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      userId: number
      value: Prisma.Decimal
      updatedAt: Date
    }, ExtArgs["result"]["wallets"]>
    composites: {}
  }

  type WalletsGetPayload<S extends boolean | null | undefined | WalletsDefaultArgs> = $Result.GetResult<Prisma.$WalletsPayload, S>

  type WalletsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<WalletsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: WalletsCountAggregateInputType | true
    }

  export interface WalletsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Wallets'], meta: { name: 'Wallets' } }
    /**
     * Find zero or one Wallets that matches the filter.
     * @param {WalletsFindUniqueArgs} args - Arguments to find a Wallets
     * @example
     * // Get one Wallets
     * const wallets = await prisma.wallets.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends WalletsFindUniqueArgs>(args: SelectSubset<T, WalletsFindUniqueArgs<ExtArgs>>): Prisma__WalletsClient<$Result.GetResult<Prisma.$WalletsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Wallets that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {WalletsFindUniqueOrThrowArgs} args - Arguments to find a Wallets
     * @example
     * // Get one Wallets
     * const wallets = await prisma.wallets.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends WalletsFindUniqueOrThrowArgs>(args: SelectSubset<T, WalletsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__WalletsClient<$Result.GetResult<Prisma.$WalletsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Wallets that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WalletsFindFirstArgs} args - Arguments to find a Wallets
     * @example
     * // Get one Wallets
     * const wallets = await prisma.wallets.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends WalletsFindFirstArgs>(args?: SelectSubset<T, WalletsFindFirstArgs<ExtArgs>>): Prisma__WalletsClient<$Result.GetResult<Prisma.$WalletsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Wallets that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WalletsFindFirstOrThrowArgs} args - Arguments to find a Wallets
     * @example
     * // Get one Wallets
     * const wallets = await prisma.wallets.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends WalletsFindFirstOrThrowArgs>(args?: SelectSubset<T, WalletsFindFirstOrThrowArgs<ExtArgs>>): Prisma__WalletsClient<$Result.GetResult<Prisma.$WalletsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Wallets that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WalletsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Wallets
     * const wallets = await prisma.wallets.findMany()
     * 
     * // Get first 10 Wallets
     * const wallets = await prisma.wallets.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const walletsWithIdOnly = await prisma.wallets.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends WalletsFindManyArgs>(args?: SelectSubset<T, WalletsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WalletsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Wallets.
     * @param {WalletsCreateArgs} args - Arguments to create a Wallets.
     * @example
     * // Create one Wallets
     * const Wallets = await prisma.wallets.create({
     *   data: {
     *     // ... data to create a Wallets
     *   }
     * })
     * 
     */
    create<T extends WalletsCreateArgs>(args: SelectSubset<T, WalletsCreateArgs<ExtArgs>>): Prisma__WalletsClient<$Result.GetResult<Prisma.$WalletsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Wallets.
     * @param {WalletsCreateManyArgs} args - Arguments to create many Wallets.
     * @example
     * // Create many Wallets
     * const wallets = await prisma.wallets.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends WalletsCreateManyArgs>(args?: SelectSubset<T, WalletsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Wallets.
     * @param {WalletsDeleteArgs} args - Arguments to delete one Wallets.
     * @example
     * // Delete one Wallets
     * const Wallets = await prisma.wallets.delete({
     *   where: {
     *     // ... filter to delete one Wallets
     *   }
     * })
     * 
     */
    delete<T extends WalletsDeleteArgs>(args: SelectSubset<T, WalletsDeleteArgs<ExtArgs>>): Prisma__WalletsClient<$Result.GetResult<Prisma.$WalletsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Wallets.
     * @param {WalletsUpdateArgs} args - Arguments to update one Wallets.
     * @example
     * // Update one Wallets
     * const wallets = await prisma.wallets.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends WalletsUpdateArgs>(args: SelectSubset<T, WalletsUpdateArgs<ExtArgs>>): Prisma__WalletsClient<$Result.GetResult<Prisma.$WalletsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Wallets.
     * @param {WalletsDeleteManyArgs} args - Arguments to filter Wallets to delete.
     * @example
     * // Delete a few Wallets
     * const { count } = await prisma.wallets.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends WalletsDeleteManyArgs>(args?: SelectSubset<T, WalletsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Wallets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WalletsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Wallets
     * const wallets = await prisma.wallets.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends WalletsUpdateManyArgs>(args: SelectSubset<T, WalletsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Wallets.
     * @param {WalletsUpsertArgs} args - Arguments to update or create a Wallets.
     * @example
     * // Update or create a Wallets
     * const wallets = await prisma.wallets.upsert({
     *   create: {
     *     // ... data to create a Wallets
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Wallets we want to update
     *   }
     * })
     */
    upsert<T extends WalletsUpsertArgs>(args: SelectSubset<T, WalletsUpsertArgs<ExtArgs>>): Prisma__WalletsClient<$Result.GetResult<Prisma.$WalletsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Wallets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WalletsCountArgs} args - Arguments to filter Wallets to count.
     * @example
     * // Count the number of Wallets
     * const count = await prisma.wallets.count({
     *   where: {
     *     // ... the filter for the Wallets we want to count
     *   }
     * })
    **/
    count<T extends WalletsCountArgs>(
      args?: Subset<T, WalletsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WalletsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Wallets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WalletsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WalletsAggregateArgs>(args: Subset<T, WalletsAggregateArgs>): Prisma.PrismaPromise<GetWalletsAggregateType<T>>

    /**
     * Group by Wallets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WalletsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WalletsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WalletsGroupByArgs['orderBy'] }
        : { orderBy?: WalletsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WalletsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWalletsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Wallets model
   */
  readonly fields: WalletsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Wallets.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__WalletsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UsersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UsersDefaultArgs<ExtArgs>>): Prisma__UsersClient<$Result.GetResult<Prisma.$UsersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    transactions<T extends Wallets$transactionsArgs<ExtArgs> = {}>(args?: Subset<T, Wallets$transactionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransactionsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Wallets model
   */
  interface WalletsFieldRefs {
    readonly id: FieldRef<"Wallets", 'Int'>
    readonly userId: FieldRef<"Wallets", 'Int'>
    readonly value: FieldRef<"Wallets", 'Decimal'>
    readonly updatedAt: FieldRef<"Wallets", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Wallets findUnique
   */
  export type WalletsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Wallets
     */
    select?: WalletsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Wallets
     */
    omit?: WalletsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WalletsInclude<ExtArgs> | null
    /**
     * Filter, which Wallets to fetch.
     */
    where: WalletsWhereUniqueInput
  }

  /**
   * Wallets findUniqueOrThrow
   */
  export type WalletsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Wallets
     */
    select?: WalletsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Wallets
     */
    omit?: WalletsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WalletsInclude<ExtArgs> | null
    /**
     * Filter, which Wallets to fetch.
     */
    where: WalletsWhereUniqueInput
  }

  /**
   * Wallets findFirst
   */
  export type WalletsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Wallets
     */
    select?: WalletsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Wallets
     */
    omit?: WalletsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WalletsInclude<ExtArgs> | null
    /**
     * Filter, which Wallets to fetch.
     */
    where?: WalletsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Wallets to fetch.
     */
    orderBy?: WalletsOrderByWithRelationInput | WalletsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Wallets.
     */
    cursor?: WalletsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Wallets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Wallets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Wallets.
     */
    distinct?: WalletsScalarFieldEnum | WalletsScalarFieldEnum[]
  }

  /**
   * Wallets findFirstOrThrow
   */
  export type WalletsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Wallets
     */
    select?: WalletsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Wallets
     */
    omit?: WalletsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WalletsInclude<ExtArgs> | null
    /**
     * Filter, which Wallets to fetch.
     */
    where?: WalletsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Wallets to fetch.
     */
    orderBy?: WalletsOrderByWithRelationInput | WalletsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Wallets.
     */
    cursor?: WalletsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Wallets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Wallets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Wallets.
     */
    distinct?: WalletsScalarFieldEnum | WalletsScalarFieldEnum[]
  }

  /**
   * Wallets findMany
   */
  export type WalletsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Wallets
     */
    select?: WalletsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Wallets
     */
    omit?: WalletsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WalletsInclude<ExtArgs> | null
    /**
     * Filter, which Wallets to fetch.
     */
    where?: WalletsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Wallets to fetch.
     */
    orderBy?: WalletsOrderByWithRelationInput | WalletsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Wallets.
     */
    cursor?: WalletsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Wallets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Wallets.
     */
    skip?: number
    distinct?: WalletsScalarFieldEnum | WalletsScalarFieldEnum[]
  }

  /**
   * Wallets create
   */
  export type WalletsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Wallets
     */
    select?: WalletsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Wallets
     */
    omit?: WalletsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WalletsInclude<ExtArgs> | null
    /**
     * The data needed to create a Wallets.
     */
    data: XOR<WalletsCreateInput, WalletsUncheckedCreateInput>
  }

  /**
   * Wallets createMany
   */
  export type WalletsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Wallets.
     */
    data: WalletsCreateManyInput | WalletsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Wallets update
   */
  export type WalletsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Wallets
     */
    select?: WalletsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Wallets
     */
    omit?: WalletsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WalletsInclude<ExtArgs> | null
    /**
     * The data needed to update a Wallets.
     */
    data: XOR<WalletsUpdateInput, WalletsUncheckedUpdateInput>
    /**
     * Choose, which Wallets to update.
     */
    where: WalletsWhereUniqueInput
  }

  /**
   * Wallets updateMany
   */
  export type WalletsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Wallets.
     */
    data: XOR<WalletsUpdateManyMutationInput, WalletsUncheckedUpdateManyInput>
    /**
     * Filter which Wallets to update
     */
    where?: WalletsWhereInput
    /**
     * Limit how many Wallets to update.
     */
    limit?: number
  }

  /**
   * Wallets upsert
   */
  export type WalletsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Wallets
     */
    select?: WalletsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Wallets
     */
    omit?: WalletsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WalletsInclude<ExtArgs> | null
    /**
     * The filter to search for the Wallets to update in case it exists.
     */
    where: WalletsWhereUniqueInput
    /**
     * In case the Wallets found by the `where` argument doesn't exist, create a new Wallets with this data.
     */
    create: XOR<WalletsCreateInput, WalletsUncheckedCreateInput>
    /**
     * In case the Wallets was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WalletsUpdateInput, WalletsUncheckedUpdateInput>
  }

  /**
   * Wallets delete
   */
  export type WalletsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Wallets
     */
    select?: WalletsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Wallets
     */
    omit?: WalletsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WalletsInclude<ExtArgs> | null
    /**
     * Filter which Wallets to delete.
     */
    where: WalletsWhereUniqueInput
  }

  /**
   * Wallets deleteMany
   */
  export type WalletsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Wallets to delete
     */
    where?: WalletsWhereInput
    /**
     * Limit how many Wallets to delete.
     */
    limit?: number
  }

  /**
   * Wallets.transactions
   */
  export type Wallets$transactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transactions
     */
    select?: TransactionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transactions
     */
    omit?: TransactionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionsInclude<ExtArgs> | null
    where?: TransactionsWhereInput
    orderBy?: TransactionsOrderByWithRelationInput | TransactionsOrderByWithRelationInput[]
    cursor?: TransactionsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TransactionsScalarFieldEnum | TransactionsScalarFieldEnum[]
  }

  /**
   * Wallets without action
   */
  export type WalletsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Wallets
     */
    select?: WalletsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Wallets
     */
    omit?: WalletsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WalletsInclude<ExtArgs> | null
  }


  /**
   * Model Transactions
   */

  export type AggregateTransactions = {
    _count: TransactionsCountAggregateOutputType | null
    _avg: TransactionsAvgAggregateOutputType | null
    _sum: TransactionsSumAggregateOutputType | null
    _min: TransactionsMinAggregateOutputType | null
    _max: TransactionsMaxAggregateOutputType | null
  }

  export type TransactionsAvgAggregateOutputType = {
    id: number | null
    walletId: number | null
    amount: Decimal | null
  }

  export type TransactionsSumAggregateOutputType = {
    id: number | null
    walletId: number | null
    amount: Decimal | null
  }

  export type TransactionsMinAggregateOutputType = {
    id: number | null
    walletId: number | null
    amount: Decimal | null
    description: string | null
    status: string | null
    createdAt: Date | null
  }

  export type TransactionsMaxAggregateOutputType = {
    id: number | null
    walletId: number | null
    amount: Decimal | null
    description: string | null
    status: string | null
    createdAt: Date | null
  }

  export type TransactionsCountAggregateOutputType = {
    id: number
    walletId: number
    amount: number
    description: number
    status: number
    createdAt: number
    _all: number
  }


  export type TransactionsAvgAggregateInputType = {
    id?: true
    walletId?: true
    amount?: true
  }

  export type TransactionsSumAggregateInputType = {
    id?: true
    walletId?: true
    amount?: true
  }

  export type TransactionsMinAggregateInputType = {
    id?: true
    walletId?: true
    amount?: true
    description?: true
    status?: true
    createdAt?: true
  }

  export type TransactionsMaxAggregateInputType = {
    id?: true
    walletId?: true
    amount?: true
    description?: true
    status?: true
    createdAt?: true
  }

  export type TransactionsCountAggregateInputType = {
    id?: true
    walletId?: true
    amount?: true
    description?: true
    status?: true
    createdAt?: true
    _all?: true
  }

  export type TransactionsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Transactions to aggregate.
     */
    where?: TransactionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Transactions to fetch.
     */
    orderBy?: TransactionsOrderByWithRelationInput | TransactionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TransactionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Transactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Transactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Transactions
    **/
    _count?: true | TransactionsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TransactionsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TransactionsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TransactionsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TransactionsMaxAggregateInputType
  }

  export type GetTransactionsAggregateType<T extends TransactionsAggregateArgs> = {
        [P in keyof T & keyof AggregateTransactions]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTransactions[P]>
      : GetScalarType<T[P], AggregateTransactions[P]>
  }




  export type TransactionsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TransactionsWhereInput
    orderBy?: TransactionsOrderByWithAggregationInput | TransactionsOrderByWithAggregationInput[]
    by: TransactionsScalarFieldEnum[] | TransactionsScalarFieldEnum
    having?: TransactionsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TransactionsCountAggregateInputType | true
    _avg?: TransactionsAvgAggregateInputType
    _sum?: TransactionsSumAggregateInputType
    _min?: TransactionsMinAggregateInputType
    _max?: TransactionsMaxAggregateInputType
  }

  export type TransactionsGroupByOutputType = {
    id: number
    walletId: number
    amount: Decimal
    description: string
    status: string
    createdAt: Date
    _count: TransactionsCountAggregateOutputType | null
    _avg: TransactionsAvgAggregateOutputType | null
    _sum: TransactionsSumAggregateOutputType | null
    _min: TransactionsMinAggregateOutputType | null
    _max: TransactionsMaxAggregateOutputType | null
  }

  type GetTransactionsGroupByPayload<T extends TransactionsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TransactionsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TransactionsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TransactionsGroupByOutputType[P]>
            : GetScalarType<T[P], TransactionsGroupByOutputType[P]>
        }
      >
    >


  export type TransactionsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    walletId?: boolean
    amount?: boolean
    description?: boolean
    status?: boolean
    createdAt?: boolean
    wallet?: boolean | WalletsDefaultArgs<ExtArgs>
    unlock_comic?: boolean | Transactions$unlock_comicArgs<ExtArgs>
    unlock_volume?: boolean | Transactions$unlock_volumeArgs<ExtArgs>
    unlock_chapter?: boolean | Transactions$unlock_chapterArgs<ExtArgs>
    _count?: boolean | TransactionsCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["transactions"]>



  export type TransactionsSelectScalar = {
    id?: boolean
    walletId?: boolean
    amount?: boolean
    description?: boolean
    status?: boolean
    createdAt?: boolean
  }

  export type TransactionsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "walletId" | "amount" | "description" | "status" | "createdAt", ExtArgs["result"]["transactions"]>
  export type TransactionsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    wallet?: boolean | WalletsDefaultArgs<ExtArgs>
    unlock_comic?: boolean | Transactions$unlock_comicArgs<ExtArgs>
    unlock_volume?: boolean | Transactions$unlock_volumeArgs<ExtArgs>
    unlock_chapter?: boolean | Transactions$unlock_chapterArgs<ExtArgs>
    _count?: boolean | TransactionsCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $TransactionsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Transactions"
    objects: {
      wallet: Prisma.$WalletsPayload<ExtArgs>
      unlock_comic: Prisma.$Unlock_comicPayload<ExtArgs>[]
      unlock_volume: Prisma.$Unlock_volumePayload<ExtArgs>[]
      unlock_chapter: Prisma.$Unlock_chapterPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      walletId: number
      amount: Prisma.Decimal
      description: string
      status: string
      createdAt: Date
    }, ExtArgs["result"]["transactions"]>
    composites: {}
  }

  type TransactionsGetPayload<S extends boolean | null | undefined | TransactionsDefaultArgs> = $Result.GetResult<Prisma.$TransactionsPayload, S>

  type TransactionsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TransactionsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TransactionsCountAggregateInputType | true
    }

  export interface TransactionsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Transactions'], meta: { name: 'Transactions' } }
    /**
     * Find zero or one Transactions that matches the filter.
     * @param {TransactionsFindUniqueArgs} args - Arguments to find a Transactions
     * @example
     * // Get one Transactions
     * const transactions = await prisma.transactions.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TransactionsFindUniqueArgs>(args: SelectSubset<T, TransactionsFindUniqueArgs<ExtArgs>>): Prisma__TransactionsClient<$Result.GetResult<Prisma.$TransactionsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Transactions that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TransactionsFindUniqueOrThrowArgs} args - Arguments to find a Transactions
     * @example
     * // Get one Transactions
     * const transactions = await prisma.transactions.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TransactionsFindUniqueOrThrowArgs>(args: SelectSubset<T, TransactionsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TransactionsClient<$Result.GetResult<Prisma.$TransactionsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Transactions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionsFindFirstArgs} args - Arguments to find a Transactions
     * @example
     * // Get one Transactions
     * const transactions = await prisma.transactions.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TransactionsFindFirstArgs>(args?: SelectSubset<T, TransactionsFindFirstArgs<ExtArgs>>): Prisma__TransactionsClient<$Result.GetResult<Prisma.$TransactionsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Transactions that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionsFindFirstOrThrowArgs} args - Arguments to find a Transactions
     * @example
     * // Get one Transactions
     * const transactions = await prisma.transactions.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TransactionsFindFirstOrThrowArgs>(args?: SelectSubset<T, TransactionsFindFirstOrThrowArgs<ExtArgs>>): Prisma__TransactionsClient<$Result.GetResult<Prisma.$TransactionsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Transactions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Transactions
     * const transactions = await prisma.transactions.findMany()
     * 
     * // Get first 10 Transactions
     * const transactions = await prisma.transactions.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const transactionsWithIdOnly = await prisma.transactions.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TransactionsFindManyArgs>(args?: SelectSubset<T, TransactionsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransactionsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Transactions.
     * @param {TransactionsCreateArgs} args - Arguments to create a Transactions.
     * @example
     * // Create one Transactions
     * const Transactions = await prisma.transactions.create({
     *   data: {
     *     // ... data to create a Transactions
     *   }
     * })
     * 
     */
    create<T extends TransactionsCreateArgs>(args: SelectSubset<T, TransactionsCreateArgs<ExtArgs>>): Prisma__TransactionsClient<$Result.GetResult<Prisma.$TransactionsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Transactions.
     * @param {TransactionsCreateManyArgs} args - Arguments to create many Transactions.
     * @example
     * // Create many Transactions
     * const transactions = await prisma.transactions.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TransactionsCreateManyArgs>(args?: SelectSubset<T, TransactionsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Transactions.
     * @param {TransactionsDeleteArgs} args - Arguments to delete one Transactions.
     * @example
     * // Delete one Transactions
     * const Transactions = await prisma.transactions.delete({
     *   where: {
     *     // ... filter to delete one Transactions
     *   }
     * })
     * 
     */
    delete<T extends TransactionsDeleteArgs>(args: SelectSubset<T, TransactionsDeleteArgs<ExtArgs>>): Prisma__TransactionsClient<$Result.GetResult<Prisma.$TransactionsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Transactions.
     * @param {TransactionsUpdateArgs} args - Arguments to update one Transactions.
     * @example
     * // Update one Transactions
     * const transactions = await prisma.transactions.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TransactionsUpdateArgs>(args: SelectSubset<T, TransactionsUpdateArgs<ExtArgs>>): Prisma__TransactionsClient<$Result.GetResult<Prisma.$TransactionsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Transactions.
     * @param {TransactionsDeleteManyArgs} args - Arguments to filter Transactions to delete.
     * @example
     * // Delete a few Transactions
     * const { count } = await prisma.transactions.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TransactionsDeleteManyArgs>(args?: SelectSubset<T, TransactionsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Transactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Transactions
     * const transactions = await prisma.transactions.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TransactionsUpdateManyArgs>(args: SelectSubset<T, TransactionsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Transactions.
     * @param {TransactionsUpsertArgs} args - Arguments to update or create a Transactions.
     * @example
     * // Update or create a Transactions
     * const transactions = await prisma.transactions.upsert({
     *   create: {
     *     // ... data to create a Transactions
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Transactions we want to update
     *   }
     * })
     */
    upsert<T extends TransactionsUpsertArgs>(args: SelectSubset<T, TransactionsUpsertArgs<ExtArgs>>): Prisma__TransactionsClient<$Result.GetResult<Prisma.$TransactionsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Transactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionsCountArgs} args - Arguments to filter Transactions to count.
     * @example
     * // Count the number of Transactions
     * const count = await prisma.transactions.count({
     *   where: {
     *     // ... the filter for the Transactions we want to count
     *   }
     * })
    **/
    count<T extends TransactionsCountArgs>(
      args?: Subset<T, TransactionsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TransactionsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Transactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TransactionsAggregateArgs>(args: Subset<T, TransactionsAggregateArgs>): Prisma.PrismaPromise<GetTransactionsAggregateType<T>>

    /**
     * Group by Transactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TransactionsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TransactionsGroupByArgs['orderBy'] }
        : { orderBy?: TransactionsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TransactionsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTransactionsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Transactions model
   */
  readonly fields: TransactionsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Transactions.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TransactionsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    wallet<T extends WalletsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, WalletsDefaultArgs<ExtArgs>>): Prisma__WalletsClient<$Result.GetResult<Prisma.$WalletsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    unlock_comic<T extends Transactions$unlock_comicArgs<ExtArgs> = {}>(args?: Subset<T, Transactions$unlock_comicArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$Unlock_comicPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    unlock_volume<T extends Transactions$unlock_volumeArgs<ExtArgs> = {}>(args?: Subset<T, Transactions$unlock_volumeArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$Unlock_volumePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    unlock_chapter<T extends Transactions$unlock_chapterArgs<ExtArgs> = {}>(args?: Subset<T, Transactions$unlock_chapterArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$Unlock_chapterPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Transactions model
   */
  interface TransactionsFieldRefs {
    readonly id: FieldRef<"Transactions", 'Int'>
    readonly walletId: FieldRef<"Transactions", 'Int'>
    readonly amount: FieldRef<"Transactions", 'Decimal'>
    readonly description: FieldRef<"Transactions", 'String'>
    readonly status: FieldRef<"Transactions", 'String'>
    readonly createdAt: FieldRef<"Transactions", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Transactions findUnique
   */
  export type TransactionsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transactions
     */
    select?: TransactionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transactions
     */
    omit?: TransactionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionsInclude<ExtArgs> | null
    /**
     * Filter, which Transactions to fetch.
     */
    where: TransactionsWhereUniqueInput
  }

  /**
   * Transactions findUniqueOrThrow
   */
  export type TransactionsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transactions
     */
    select?: TransactionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transactions
     */
    omit?: TransactionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionsInclude<ExtArgs> | null
    /**
     * Filter, which Transactions to fetch.
     */
    where: TransactionsWhereUniqueInput
  }

  /**
   * Transactions findFirst
   */
  export type TransactionsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transactions
     */
    select?: TransactionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transactions
     */
    omit?: TransactionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionsInclude<ExtArgs> | null
    /**
     * Filter, which Transactions to fetch.
     */
    where?: TransactionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Transactions to fetch.
     */
    orderBy?: TransactionsOrderByWithRelationInput | TransactionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Transactions.
     */
    cursor?: TransactionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Transactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Transactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Transactions.
     */
    distinct?: TransactionsScalarFieldEnum | TransactionsScalarFieldEnum[]
  }

  /**
   * Transactions findFirstOrThrow
   */
  export type TransactionsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transactions
     */
    select?: TransactionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transactions
     */
    omit?: TransactionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionsInclude<ExtArgs> | null
    /**
     * Filter, which Transactions to fetch.
     */
    where?: TransactionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Transactions to fetch.
     */
    orderBy?: TransactionsOrderByWithRelationInput | TransactionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Transactions.
     */
    cursor?: TransactionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Transactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Transactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Transactions.
     */
    distinct?: TransactionsScalarFieldEnum | TransactionsScalarFieldEnum[]
  }

  /**
   * Transactions findMany
   */
  export type TransactionsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transactions
     */
    select?: TransactionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transactions
     */
    omit?: TransactionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionsInclude<ExtArgs> | null
    /**
     * Filter, which Transactions to fetch.
     */
    where?: TransactionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Transactions to fetch.
     */
    orderBy?: TransactionsOrderByWithRelationInput | TransactionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Transactions.
     */
    cursor?: TransactionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Transactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Transactions.
     */
    skip?: number
    distinct?: TransactionsScalarFieldEnum | TransactionsScalarFieldEnum[]
  }

  /**
   * Transactions create
   */
  export type TransactionsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transactions
     */
    select?: TransactionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transactions
     */
    omit?: TransactionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionsInclude<ExtArgs> | null
    /**
     * The data needed to create a Transactions.
     */
    data: XOR<TransactionsCreateInput, TransactionsUncheckedCreateInput>
  }

  /**
   * Transactions createMany
   */
  export type TransactionsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Transactions.
     */
    data: TransactionsCreateManyInput | TransactionsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Transactions update
   */
  export type TransactionsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transactions
     */
    select?: TransactionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transactions
     */
    omit?: TransactionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionsInclude<ExtArgs> | null
    /**
     * The data needed to update a Transactions.
     */
    data: XOR<TransactionsUpdateInput, TransactionsUncheckedUpdateInput>
    /**
     * Choose, which Transactions to update.
     */
    where: TransactionsWhereUniqueInput
  }

  /**
   * Transactions updateMany
   */
  export type TransactionsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Transactions.
     */
    data: XOR<TransactionsUpdateManyMutationInput, TransactionsUncheckedUpdateManyInput>
    /**
     * Filter which Transactions to update
     */
    where?: TransactionsWhereInput
    /**
     * Limit how many Transactions to update.
     */
    limit?: number
  }

  /**
   * Transactions upsert
   */
  export type TransactionsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transactions
     */
    select?: TransactionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transactions
     */
    omit?: TransactionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionsInclude<ExtArgs> | null
    /**
     * The filter to search for the Transactions to update in case it exists.
     */
    where: TransactionsWhereUniqueInput
    /**
     * In case the Transactions found by the `where` argument doesn't exist, create a new Transactions with this data.
     */
    create: XOR<TransactionsCreateInput, TransactionsUncheckedCreateInput>
    /**
     * In case the Transactions was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TransactionsUpdateInput, TransactionsUncheckedUpdateInput>
  }

  /**
   * Transactions delete
   */
  export type TransactionsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transactions
     */
    select?: TransactionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transactions
     */
    omit?: TransactionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionsInclude<ExtArgs> | null
    /**
     * Filter which Transactions to delete.
     */
    where: TransactionsWhereUniqueInput
  }

  /**
   * Transactions deleteMany
   */
  export type TransactionsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Transactions to delete
     */
    where?: TransactionsWhereInput
    /**
     * Limit how many Transactions to delete.
     */
    limit?: number
  }

  /**
   * Transactions.unlock_comic
   */
  export type Transactions$unlock_comicArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Unlock_comic
     */
    select?: Unlock_comicSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Unlock_comic
     */
    omit?: Unlock_comicOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Unlock_comicInclude<ExtArgs> | null
    where?: Unlock_comicWhereInput
    orderBy?: Unlock_comicOrderByWithRelationInput | Unlock_comicOrderByWithRelationInput[]
    cursor?: Unlock_comicWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Unlock_comicScalarFieldEnum | Unlock_comicScalarFieldEnum[]
  }

  /**
   * Transactions.unlock_volume
   */
  export type Transactions$unlock_volumeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Unlock_volume
     */
    select?: Unlock_volumeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Unlock_volume
     */
    omit?: Unlock_volumeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Unlock_volumeInclude<ExtArgs> | null
    where?: Unlock_volumeWhereInput
    orderBy?: Unlock_volumeOrderByWithRelationInput | Unlock_volumeOrderByWithRelationInput[]
    cursor?: Unlock_volumeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Unlock_volumeScalarFieldEnum | Unlock_volumeScalarFieldEnum[]
  }

  /**
   * Transactions.unlock_chapter
   */
  export type Transactions$unlock_chapterArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Unlock_chapter
     */
    select?: Unlock_chapterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Unlock_chapter
     */
    omit?: Unlock_chapterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Unlock_chapterInclude<ExtArgs> | null
    where?: Unlock_chapterWhereInput
    orderBy?: Unlock_chapterOrderByWithRelationInput | Unlock_chapterOrderByWithRelationInput[]
    cursor?: Unlock_chapterWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Unlock_chapterScalarFieldEnum | Unlock_chapterScalarFieldEnum[]
  }

  /**
   * Transactions without action
   */
  export type TransactionsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transactions
     */
    select?: TransactionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transactions
     */
    omit?: TransactionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionsInclude<ExtArgs> | null
  }


  /**
   * Model Unlock_comic
   */

  export type AggregateUnlock_comic = {
    _count: Unlock_comicCountAggregateOutputType | null
    _avg: Unlock_comicAvgAggregateOutputType | null
    _sum: Unlock_comicSumAggregateOutputType | null
    _min: Unlock_comicMinAggregateOutputType | null
    _max: Unlock_comicMaxAggregateOutputType | null
  }

  export type Unlock_comicAvgAggregateOutputType = {
    userId: number | null
    comicId: number | null
    transactionId: number | null
  }

  export type Unlock_comicSumAggregateOutputType = {
    userId: number | null
    comicId: number | null
    transactionId: number | null
  }

  export type Unlock_comicMinAggregateOutputType = {
    userId: number | null
    comicId: number | null
    transactionId: number | null
    createdAt: Date | null
  }

  export type Unlock_comicMaxAggregateOutputType = {
    userId: number | null
    comicId: number | null
    transactionId: number | null
    createdAt: Date | null
  }

  export type Unlock_comicCountAggregateOutputType = {
    userId: number
    comicId: number
    transactionId: number
    createdAt: number
    _all: number
  }


  export type Unlock_comicAvgAggregateInputType = {
    userId?: true
    comicId?: true
    transactionId?: true
  }

  export type Unlock_comicSumAggregateInputType = {
    userId?: true
    comicId?: true
    transactionId?: true
  }

  export type Unlock_comicMinAggregateInputType = {
    userId?: true
    comicId?: true
    transactionId?: true
    createdAt?: true
  }

  export type Unlock_comicMaxAggregateInputType = {
    userId?: true
    comicId?: true
    transactionId?: true
    createdAt?: true
  }

  export type Unlock_comicCountAggregateInputType = {
    userId?: true
    comicId?: true
    transactionId?: true
    createdAt?: true
    _all?: true
  }

  export type Unlock_comicAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Unlock_comic to aggregate.
     */
    where?: Unlock_comicWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Unlock_comics to fetch.
     */
    orderBy?: Unlock_comicOrderByWithRelationInput | Unlock_comicOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: Unlock_comicWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Unlock_comics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Unlock_comics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Unlock_comics
    **/
    _count?: true | Unlock_comicCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Unlock_comicAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Unlock_comicSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Unlock_comicMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Unlock_comicMaxAggregateInputType
  }

  export type GetUnlock_comicAggregateType<T extends Unlock_comicAggregateArgs> = {
        [P in keyof T & keyof AggregateUnlock_comic]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUnlock_comic[P]>
      : GetScalarType<T[P], AggregateUnlock_comic[P]>
  }




  export type Unlock_comicGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: Unlock_comicWhereInput
    orderBy?: Unlock_comicOrderByWithAggregationInput | Unlock_comicOrderByWithAggregationInput[]
    by: Unlock_comicScalarFieldEnum[] | Unlock_comicScalarFieldEnum
    having?: Unlock_comicScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Unlock_comicCountAggregateInputType | true
    _avg?: Unlock_comicAvgAggregateInputType
    _sum?: Unlock_comicSumAggregateInputType
    _min?: Unlock_comicMinAggregateInputType
    _max?: Unlock_comicMaxAggregateInputType
  }

  export type Unlock_comicGroupByOutputType = {
    userId: number
    comicId: number
    transactionId: number
    createdAt: Date
    _count: Unlock_comicCountAggregateOutputType | null
    _avg: Unlock_comicAvgAggregateOutputType | null
    _sum: Unlock_comicSumAggregateOutputType | null
    _min: Unlock_comicMinAggregateOutputType | null
    _max: Unlock_comicMaxAggregateOutputType | null
  }

  type GetUnlock_comicGroupByPayload<T extends Unlock_comicGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Unlock_comicGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Unlock_comicGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Unlock_comicGroupByOutputType[P]>
            : GetScalarType<T[P], Unlock_comicGroupByOutputType[P]>
        }
      >
    >


  export type Unlock_comicSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    userId?: boolean
    comicId?: boolean
    transactionId?: boolean
    createdAt?: boolean
    user?: boolean | UsersDefaultArgs<ExtArgs>
    comic?: boolean | ComicsDefaultArgs<ExtArgs>
    transaction?: boolean | TransactionsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["unlock_comic"]>



  export type Unlock_comicSelectScalar = {
    userId?: boolean
    comicId?: boolean
    transactionId?: boolean
    createdAt?: boolean
  }

  export type Unlock_comicOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"userId" | "comicId" | "transactionId" | "createdAt", ExtArgs["result"]["unlock_comic"]>
  export type Unlock_comicInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UsersDefaultArgs<ExtArgs>
    comic?: boolean | ComicsDefaultArgs<ExtArgs>
    transaction?: boolean | TransactionsDefaultArgs<ExtArgs>
  }

  export type $Unlock_comicPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Unlock_comic"
    objects: {
      user: Prisma.$UsersPayload<ExtArgs>
      comic: Prisma.$ComicsPayload<ExtArgs>
      transaction: Prisma.$TransactionsPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      userId: number
      comicId: number
      transactionId: number
      createdAt: Date
    }, ExtArgs["result"]["unlock_comic"]>
    composites: {}
  }

  type Unlock_comicGetPayload<S extends boolean | null | undefined | Unlock_comicDefaultArgs> = $Result.GetResult<Prisma.$Unlock_comicPayload, S>

  type Unlock_comicCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<Unlock_comicFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Unlock_comicCountAggregateInputType | true
    }

  export interface Unlock_comicDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Unlock_comic'], meta: { name: 'Unlock_comic' } }
    /**
     * Find zero or one Unlock_comic that matches the filter.
     * @param {Unlock_comicFindUniqueArgs} args - Arguments to find a Unlock_comic
     * @example
     * // Get one Unlock_comic
     * const unlock_comic = await prisma.unlock_comic.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends Unlock_comicFindUniqueArgs>(args: SelectSubset<T, Unlock_comicFindUniqueArgs<ExtArgs>>): Prisma__Unlock_comicClient<$Result.GetResult<Prisma.$Unlock_comicPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Unlock_comic that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {Unlock_comicFindUniqueOrThrowArgs} args - Arguments to find a Unlock_comic
     * @example
     * // Get one Unlock_comic
     * const unlock_comic = await prisma.unlock_comic.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends Unlock_comicFindUniqueOrThrowArgs>(args: SelectSubset<T, Unlock_comicFindUniqueOrThrowArgs<ExtArgs>>): Prisma__Unlock_comicClient<$Result.GetResult<Prisma.$Unlock_comicPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Unlock_comic that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Unlock_comicFindFirstArgs} args - Arguments to find a Unlock_comic
     * @example
     * // Get one Unlock_comic
     * const unlock_comic = await prisma.unlock_comic.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends Unlock_comicFindFirstArgs>(args?: SelectSubset<T, Unlock_comicFindFirstArgs<ExtArgs>>): Prisma__Unlock_comicClient<$Result.GetResult<Prisma.$Unlock_comicPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Unlock_comic that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Unlock_comicFindFirstOrThrowArgs} args - Arguments to find a Unlock_comic
     * @example
     * // Get one Unlock_comic
     * const unlock_comic = await prisma.unlock_comic.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends Unlock_comicFindFirstOrThrowArgs>(args?: SelectSubset<T, Unlock_comicFindFirstOrThrowArgs<ExtArgs>>): Prisma__Unlock_comicClient<$Result.GetResult<Prisma.$Unlock_comicPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Unlock_comics that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Unlock_comicFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Unlock_comics
     * const unlock_comics = await prisma.unlock_comic.findMany()
     * 
     * // Get first 10 Unlock_comics
     * const unlock_comics = await prisma.unlock_comic.findMany({ take: 10 })
     * 
     * // Only select the `userId`
     * const unlock_comicWithUserIdOnly = await prisma.unlock_comic.findMany({ select: { userId: true } })
     * 
     */
    findMany<T extends Unlock_comicFindManyArgs>(args?: SelectSubset<T, Unlock_comicFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$Unlock_comicPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Unlock_comic.
     * @param {Unlock_comicCreateArgs} args - Arguments to create a Unlock_comic.
     * @example
     * // Create one Unlock_comic
     * const Unlock_comic = await prisma.unlock_comic.create({
     *   data: {
     *     // ... data to create a Unlock_comic
     *   }
     * })
     * 
     */
    create<T extends Unlock_comicCreateArgs>(args: SelectSubset<T, Unlock_comicCreateArgs<ExtArgs>>): Prisma__Unlock_comicClient<$Result.GetResult<Prisma.$Unlock_comicPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Unlock_comics.
     * @param {Unlock_comicCreateManyArgs} args - Arguments to create many Unlock_comics.
     * @example
     * // Create many Unlock_comics
     * const unlock_comic = await prisma.unlock_comic.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends Unlock_comicCreateManyArgs>(args?: SelectSubset<T, Unlock_comicCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Unlock_comic.
     * @param {Unlock_comicDeleteArgs} args - Arguments to delete one Unlock_comic.
     * @example
     * // Delete one Unlock_comic
     * const Unlock_comic = await prisma.unlock_comic.delete({
     *   where: {
     *     // ... filter to delete one Unlock_comic
     *   }
     * })
     * 
     */
    delete<T extends Unlock_comicDeleteArgs>(args: SelectSubset<T, Unlock_comicDeleteArgs<ExtArgs>>): Prisma__Unlock_comicClient<$Result.GetResult<Prisma.$Unlock_comicPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Unlock_comic.
     * @param {Unlock_comicUpdateArgs} args - Arguments to update one Unlock_comic.
     * @example
     * // Update one Unlock_comic
     * const unlock_comic = await prisma.unlock_comic.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends Unlock_comicUpdateArgs>(args: SelectSubset<T, Unlock_comicUpdateArgs<ExtArgs>>): Prisma__Unlock_comicClient<$Result.GetResult<Prisma.$Unlock_comicPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Unlock_comics.
     * @param {Unlock_comicDeleteManyArgs} args - Arguments to filter Unlock_comics to delete.
     * @example
     * // Delete a few Unlock_comics
     * const { count } = await prisma.unlock_comic.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends Unlock_comicDeleteManyArgs>(args?: SelectSubset<T, Unlock_comicDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Unlock_comics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Unlock_comicUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Unlock_comics
     * const unlock_comic = await prisma.unlock_comic.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends Unlock_comicUpdateManyArgs>(args: SelectSubset<T, Unlock_comicUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Unlock_comic.
     * @param {Unlock_comicUpsertArgs} args - Arguments to update or create a Unlock_comic.
     * @example
     * // Update or create a Unlock_comic
     * const unlock_comic = await prisma.unlock_comic.upsert({
     *   create: {
     *     // ... data to create a Unlock_comic
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Unlock_comic we want to update
     *   }
     * })
     */
    upsert<T extends Unlock_comicUpsertArgs>(args: SelectSubset<T, Unlock_comicUpsertArgs<ExtArgs>>): Prisma__Unlock_comicClient<$Result.GetResult<Prisma.$Unlock_comicPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Unlock_comics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Unlock_comicCountArgs} args - Arguments to filter Unlock_comics to count.
     * @example
     * // Count the number of Unlock_comics
     * const count = await prisma.unlock_comic.count({
     *   where: {
     *     // ... the filter for the Unlock_comics we want to count
     *   }
     * })
    **/
    count<T extends Unlock_comicCountArgs>(
      args?: Subset<T, Unlock_comicCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Unlock_comicCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Unlock_comic.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Unlock_comicAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Unlock_comicAggregateArgs>(args: Subset<T, Unlock_comicAggregateArgs>): Prisma.PrismaPromise<GetUnlock_comicAggregateType<T>>

    /**
     * Group by Unlock_comic.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Unlock_comicGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Unlock_comicGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Unlock_comicGroupByArgs['orderBy'] }
        : { orderBy?: Unlock_comicGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Unlock_comicGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUnlock_comicGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Unlock_comic model
   */
  readonly fields: Unlock_comicFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Unlock_comic.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__Unlock_comicClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UsersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UsersDefaultArgs<ExtArgs>>): Prisma__UsersClient<$Result.GetResult<Prisma.$UsersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    comic<T extends ComicsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ComicsDefaultArgs<ExtArgs>>): Prisma__ComicsClient<$Result.GetResult<Prisma.$ComicsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    transaction<T extends TransactionsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TransactionsDefaultArgs<ExtArgs>>): Prisma__TransactionsClient<$Result.GetResult<Prisma.$TransactionsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Unlock_comic model
   */
  interface Unlock_comicFieldRefs {
    readonly userId: FieldRef<"Unlock_comic", 'Int'>
    readonly comicId: FieldRef<"Unlock_comic", 'Int'>
    readonly transactionId: FieldRef<"Unlock_comic", 'Int'>
    readonly createdAt: FieldRef<"Unlock_comic", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Unlock_comic findUnique
   */
  export type Unlock_comicFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Unlock_comic
     */
    select?: Unlock_comicSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Unlock_comic
     */
    omit?: Unlock_comicOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Unlock_comicInclude<ExtArgs> | null
    /**
     * Filter, which Unlock_comic to fetch.
     */
    where: Unlock_comicWhereUniqueInput
  }

  /**
   * Unlock_comic findUniqueOrThrow
   */
  export type Unlock_comicFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Unlock_comic
     */
    select?: Unlock_comicSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Unlock_comic
     */
    omit?: Unlock_comicOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Unlock_comicInclude<ExtArgs> | null
    /**
     * Filter, which Unlock_comic to fetch.
     */
    where: Unlock_comicWhereUniqueInput
  }

  /**
   * Unlock_comic findFirst
   */
  export type Unlock_comicFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Unlock_comic
     */
    select?: Unlock_comicSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Unlock_comic
     */
    omit?: Unlock_comicOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Unlock_comicInclude<ExtArgs> | null
    /**
     * Filter, which Unlock_comic to fetch.
     */
    where?: Unlock_comicWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Unlock_comics to fetch.
     */
    orderBy?: Unlock_comicOrderByWithRelationInput | Unlock_comicOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Unlock_comics.
     */
    cursor?: Unlock_comicWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Unlock_comics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Unlock_comics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Unlock_comics.
     */
    distinct?: Unlock_comicScalarFieldEnum | Unlock_comicScalarFieldEnum[]
  }

  /**
   * Unlock_comic findFirstOrThrow
   */
  export type Unlock_comicFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Unlock_comic
     */
    select?: Unlock_comicSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Unlock_comic
     */
    omit?: Unlock_comicOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Unlock_comicInclude<ExtArgs> | null
    /**
     * Filter, which Unlock_comic to fetch.
     */
    where?: Unlock_comicWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Unlock_comics to fetch.
     */
    orderBy?: Unlock_comicOrderByWithRelationInput | Unlock_comicOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Unlock_comics.
     */
    cursor?: Unlock_comicWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Unlock_comics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Unlock_comics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Unlock_comics.
     */
    distinct?: Unlock_comicScalarFieldEnum | Unlock_comicScalarFieldEnum[]
  }

  /**
   * Unlock_comic findMany
   */
  export type Unlock_comicFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Unlock_comic
     */
    select?: Unlock_comicSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Unlock_comic
     */
    omit?: Unlock_comicOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Unlock_comicInclude<ExtArgs> | null
    /**
     * Filter, which Unlock_comics to fetch.
     */
    where?: Unlock_comicWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Unlock_comics to fetch.
     */
    orderBy?: Unlock_comicOrderByWithRelationInput | Unlock_comicOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Unlock_comics.
     */
    cursor?: Unlock_comicWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Unlock_comics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Unlock_comics.
     */
    skip?: number
    distinct?: Unlock_comicScalarFieldEnum | Unlock_comicScalarFieldEnum[]
  }

  /**
   * Unlock_comic create
   */
  export type Unlock_comicCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Unlock_comic
     */
    select?: Unlock_comicSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Unlock_comic
     */
    omit?: Unlock_comicOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Unlock_comicInclude<ExtArgs> | null
    /**
     * The data needed to create a Unlock_comic.
     */
    data: XOR<Unlock_comicCreateInput, Unlock_comicUncheckedCreateInput>
  }

  /**
   * Unlock_comic createMany
   */
  export type Unlock_comicCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Unlock_comics.
     */
    data: Unlock_comicCreateManyInput | Unlock_comicCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Unlock_comic update
   */
  export type Unlock_comicUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Unlock_comic
     */
    select?: Unlock_comicSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Unlock_comic
     */
    omit?: Unlock_comicOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Unlock_comicInclude<ExtArgs> | null
    /**
     * The data needed to update a Unlock_comic.
     */
    data: XOR<Unlock_comicUpdateInput, Unlock_comicUncheckedUpdateInput>
    /**
     * Choose, which Unlock_comic to update.
     */
    where: Unlock_comicWhereUniqueInput
  }

  /**
   * Unlock_comic updateMany
   */
  export type Unlock_comicUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Unlock_comics.
     */
    data: XOR<Unlock_comicUpdateManyMutationInput, Unlock_comicUncheckedUpdateManyInput>
    /**
     * Filter which Unlock_comics to update
     */
    where?: Unlock_comicWhereInput
    /**
     * Limit how many Unlock_comics to update.
     */
    limit?: number
  }

  /**
   * Unlock_comic upsert
   */
  export type Unlock_comicUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Unlock_comic
     */
    select?: Unlock_comicSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Unlock_comic
     */
    omit?: Unlock_comicOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Unlock_comicInclude<ExtArgs> | null
    /**
     * The filter to search for the Unlock_comic to update in case it exists.
     */
    where: Unlock_comicWhereUniqueInput
    /**
     * In case the Unlock_comic found by the `where` argument doesn't exist, create a new Unlock_comic with this data.
     */
    create: XOR<Unlock_comicCreateInput, Unlock_comicUncheckedCreateInput>
    /**
     * In case the Unlock_comic was found with the provided `where` argument, update it with this data.
     */
    update: XOR<Unlock_comicUpdateInput, Unlock_comicUncheckedUpdateInput>
  }

  /**
   * Unlock_comic delete
   */
  export type Unlock_comicDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Unlock_comic
     */
    select?: Unlock_comicSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Unlock_comic
     */
    omit?: Unlock_comicOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Unlock_comicInclude<ExtArgs> | null
    /**
     * Filter which Unlock_comic to delete.
     */
    where: Unlock_comicWhereUniqueInput
  }

  /**
   * Unlock_comic deleteMany
   */
  export type Unlock_comicDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Unlock_comics to delete
     */
    where?: Unlock_comicWhereInput
    /**
     * Limit how many Unlock_comics to delete.
     */
    limit?: number
  }

  /**
   * Unlock_comic without action
   */
  export type Unlock_comicDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Unlock_comic
     */
    select?: Unlock_comicSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Unlock_comic
     */
    omit?: Unlock_comicOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Unlock_comicInclude<ExtArgs> | null
  }


  /**
   * Model Unlock_volume
   */

  export type AggregateUnlock_volume = {
    _count: Unlock_volumeCountAggregateOutputType | null
    _avg: Unlock_volumeAvgAggregateOutputType | null
    _sum: Unlock_volumeSumAggregateOutputType | null
    _min: Unlock_volumeMinAggregateOutputType | null
    _max: Unlock_volumeMaxAggregateOutputType | null
  }

  export type Unlock_volumeAvgAggregateOutputType = {
    userId: number | null
    volumeId: number | null
    transactionId: number | null
  }

  export type Unlock_volumeSumAggregateOutputType = {
    userId: number | null
    volumeId: number | null
    transactionId: number | null
  }

  export type Unlock_volumeMinAggregateOutputType = {
    userId: number | null
    volumeId: number | null
    transactionId: number | null
    createdAt: Date | null
  }

  export type Unlock_volumeMaxAggregateOutputType = {
    userId: number | null
    volumeId: number | null
    transactionId: number | null
    createdAt: Date | null
  }

  export type Unlock_volumeCountAggregateOutputType = {
    userId: number
    volumeId: number
    transactionId: number
    createdAt: number
    _all: number
  }


  export type Unlock_volumeAvgAggregateInputType = {
    userId?: true
    volumeId?: true
    transactionId?: true
  }

  export type Unlock_volumeSumAggregateInputType = {
    userId?: true
    volumeId?: true
    transactionId?: true
  }

  export type Unlock_volumeMinAggregateInputType = {
    userId?: true
    volumeId?: true
    transactionId?: true
    createdAt?: true
  }

  export type Unlock_volumeMaxAggregateInputType = {
    userId?: true
    volumeId?: true
    transactionId?: true
    createdAt?: true
  }

  export type Unlock_volumeCountAggregateInputType = {
    userId?: true
    volumeId?: true
    transactionId?: true
    createdAt?: true
    _all?: true
  }

  export type Unlock_volumeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Unlock_volume to aggregate.
     */
    where?: Unlock_volumeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Unlock_volumes to fetch.
     */
    orderBy?: Unlock_volumeOrderByWithRelationInput | Unlock_volumeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: Unlock_volumeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Unlock_volumes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Unlock_volumes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Unlock_volumes
    **/
    _count?: true | Unlock_volumeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Unlock_volumeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Unlock_volumeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Unlock_volumeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Unlock_volumeMaxAggregateInputType
  }

  export type GetUnlock_volumeAggregateType<T extends Unlock_volumeAggregateArgs> = {
        [P in keyof T & keyof AggregateUnlock_volume]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUnlock_volume[P]>
      : GetScalarType<T[P], AggregateUnlock_volume[P]>
  }




  export type Unlock_volumeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: Unlock_volumeWhereInput
    orderBy?: Unlock_volumeOrderByWithAggregationInput | Unlock_volumeOrderByWithAggregationInput[]
    by: Unlock_volumeScalarFieldEnum[] | Unlock_volumeScalarFieldEnum
    having?: Unlock_volumeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Unlock_volumeCountAggregateInputType | true
    _avg?: Unlock_volumeAvgAggregateInputType
    _sum?: Unlock_volumeSumAggregateInputType
    _min?: Unlock_volumeMinAggregateInputType
    _max?: Unlock_volumeMaxAggregateInputType
  }

  export type Unlock_volumeGroupByOutputType = {
    userId: number
    volumeId: number
    transactionId: number
    createdAt: Date
    _count: Unlock_volumeCountAggregateOutputType | null
    _avg: Unlock_volumeAvgAggregateOutputType | null
    _sum: Unlock_volumeSumAggregateOutputType | null
    _min: Unlock_volumeMinAggregateOutputType | null
    _max: Unlock_volumeMaxAggregateOutputType | null
  }

  type GetUnlock_volumeGroupByPayload<T extends Unlock_volumeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Unlock_volumeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Unlock_volumeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Unlock_volumeGroupByOutputType[P]>
            : GetScalarType<T[P], Unlock_volumeGroupByOutputType[P]>
        }
      >
    >


  export type Unlock_volumeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    userId?: boolean
    volumeId?: boolean
    transactionId?: boolean
    createdAt?: boolean
    user?: boolean | UsersDefaultArgs<ExtArgs>
    volume?: boolean | VolumesDefaultArgs<ExtArgs>
    transaction?: boolean | TransactionsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["unlock_volume"]>



  export type Unlock_volumeSelectScalar = {
    userId?: boolean
    volumeId?: boolean
    transactionId?: boolean
    createdAt?: boolean
  }

  export type Unlock_volumeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"userId" | "volumeId" | "transactionId" | "createdAt", ExtArgs["result"]["unlock_volume"]>
  export type Unlock_volumeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UsersDefaultArgs<ExtArgs>
    volume?: boolean | VolumesDefaultArgs<ExtArgs>
    transaction?: boolean | TransactionsDefaultArgs<ExtArgs>
  }

  export type $Unlock_volumePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Unlock_volume"
    objects: {
      user: Prisma.$UsersPayload<ExtArgs>
      volume: Prisma.$VolumesPayload<ExtArgs>
      transaction: Prisma.$TransactionsPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      userId: number
      volumeId: number
      transactionId: number
      createdAt: Date
    }, ExtArgs["result"]["unlock_volume"]>
    composites: {}
  }

  type Unlock_volumeGetPayload<S extends boolean | null | undefined | Unlock_volumeDefaultArgs> = $Result.GetResult<Prisma.$Unlock_volumePayload, S>

  type Unlock_volumeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<Unlock_volumeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Unlock_volumeCountAggregateInputType | true
    }

  export interface Unlock_volumeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Unlock_volume'], meta: { name: 'Unlock_volume' } }
    /**
     * Find zero or one Unlock_volume that matches the filter.
     * @param {Unlock_volumeFindUniqueArgs} args - Arguments to find a Unlock_volume
     * @example
     * // Get one Unlock_volume
     * const unlock_volume = await prisma.unlock_volume.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends Unlock_volumeFindUniqueArgs>(args: SelectSubset<T, Unlock_volumeFindUniqueArgs<ExtArgs>>): Prisma__Unlock_volumeClient<$Result.GetResult<Prisma.$Unlock_volumePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Unlock_volume that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {Unlock_volumeFindUniqueOrThrowArgs} args - Arguments to find a Unlock_volume
     * @example
     * // Get one Unlock_volume
     * const unlock_volume = await prisma.unlock_volume.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends Unlock_volumeFindUniqueOrThrowArgs>(args: SelectSubset<T, Unlock_volumeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__Unlock_volumeClient<$Result.GetResult<Prisma.$Unlock_volumePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Unlock_volume that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Unlock_volumeFindFirstArgs} args - Arguments to find a Unlock_volume
     * @example
     * // Get one Unlock_volume
     * const unlock_volume = await prisma.unlock_volume.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends Unlock_volumeFindFirstArgs>(args?: SelectSubset<T, Unlock_volumeFindFirstArgs<ExtArgs>>): Prisma__Unlock_volumeClient<$Result.GetResult<Prisma.$Unlock_volumePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Unlock_volume that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Unlock_volumeFindFirstOrThrowArgs} args - Arguments to find a Unlock_volume
     * @example
     * // Get one Unlock_volume
     * const unlock_volume = await prisma.unlock_volume.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends Unlock_volumeFindFirstOrThrowArgs>(args?: SelectSubset<T, Unlock_volumeFindFirstOrThrowArgs<ExtArgs>>): Prisma__Unlock_volumeClient<$Result.GetResult<Prisma.$Unlock_volumePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Unlock_volumes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Unlock_volumeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Unlock_volumes
     * const unlock_volumes = await prisma.unlock_volume.findMany()
     * 
     * // Get first 10 Unlock_volumes
     * const unlock_volumes = await prisma.unlock_volume.findMany({ take: 10 })
     * 
     * // Only select the `userId`
     * const unlock_volumeWithUserIdOnly = await prisma.unlock_volume.findMany({ select: { userId: true } })
     * 
     */
    findMany<T extends Unlock_volumeFindManyArgs>(args?: SelectSubset<T, Unlock_volumeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$Unlock_volumePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Unlock_volume.
     * @param {Unlock_volumeCreateArgs} args - Arguments to create a Unlock_volume.
     * @example
     * // Create one Unlock_volume
     * const Unlock_volume = await prisma.unlock_volume.create({
     *   data: {
     *     // ... data to create a Unlock_volume
     *   }
     * })
     * 
     */
    create<T extends Unlock_volumeCreateArgs>(args: SelectSubset<T, Unlock_volumeCreateArgs<ExtArgs>>): Prisma__Unlock_volumeClient<$Result.GetResult<Prisma.$Unlock_volumePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Unlock_volumes.
     * @param {Unlock_volumeCreateManyArgs} args - Arguments to create many Unlock_volumes.
     * @example
     * // Create many Unlock_volumes
     * const unlock_volume = await prisma.unlock_volume.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends Unlock_volumeCreateManyArgs>(args?: SelectSubset<T, Unlock_volumeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Unlock_volume.
     * @param {Unlock_volumeDeleteArgs} args - Arguments to delete one Unlock_volume.
     * @example
     * // Delete one Unlock_volume
     * const Unlock_volume = await prisma.unlock_volume.delete({
     *   where: {
     *     // ... filter to delete one Unlock_volume
     *   }
     * })
     * 
     */
    delete<T extends Unlock_volumeDeleteArgs>(args: SelectSubset<T, Unlock_volumeDeleteArgs<ExtArgs>>): Prisma__Unlock_volumeClient<$Result.GetResult<Prisma.$Unlock_volumePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Unlock_volume.
     * @param {Unlock_volumeUpdateArgs} args - Arguments to update one Unlock_volume.
     * @example
     * // Update one Unlock_volume
     * const unlock_volume = await prisma.unlock_volume.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends Unlock_volumeUpdateArgs>(args: SelectSubset<T, Unlock_volumeUpdateArgs<ExtArgs>>): Prisma__Unlock_volumeClient<$Result.GetResult<Prisma.$Unlock_volumePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Unlock_volumes.
     * @param {Unlock_volumeDeleteManyArgs} args - Arguments to filter Unlock_volumes to delete.
     * @example
     * // Delete a few Unlock_volumes
     * const { count } = await prisma.unlock_volume.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends Unlock_volumeDeleteManyArgs>(args?: SelectSubset<T, Unlock_volumeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Unlock_volumes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Unlock_volumeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Unlock_volumes
     * const unlock_volume = await prisma.unlock_volume.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends Unlock_volumeUpdateManyArgs>(args: SelectSubset<T, Unlock_volumeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Unlock_volume.
     * @param {Unlock_volumeUpsertArgs} args - Arguments to update or create a Unlock_volume.
     * @example
     * // Update or create a Unlock_volume
     * const unlock_volume = await prisma.unlock_volume.upsert({
     *   create: {
     *     // ... data to create a Unlock_volume
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Unlock_volume we want to update
     *   }
     * })
     */
    upsert<T extends Unlock_volumeUpsertArgs>(args: SelectSubset<T, Unlock_volumeUpsertArgs<ExtArgs>>): Prisma__Unlock_volumeClient<$Result.GetResult<Prisma.$Unlock_volumePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Unlock_volumes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Unlock_volumeCountArgs} args - Arguments to filter Unlock_volumes to count.
     * @example
     * // Count the number of Unlock_volumes
     * const count = await prisma.unlock_volume.count({
     *   where: {
     *     // ... the filter for the Unlock_volumes we want to count
     *   }
     * })
    **/
    count<T extends Unlock_volumeCountArgs>(
      args?: Subset<T, Unlock_volumeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Unlock_volumeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Unlock_volume.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Unlock_volumeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Unlock_volumeAggregateArgs>(args: Subset<T, Unlock_volumeAggregateArgs>): Prisma.PrismaPromise<GetUnlock_volumeAggregateType<T>>

    /**
     * Group by Unlock_volume.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Unlock_volumeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Unlock_volumeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Unlock_volumeGroupByArgs['orderBy'] }
        : { orderBy?: Unlock_volumeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Unlock_volumeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUnlock_volumeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Unlock_volume model
   */
  readonly fields: Unlock_volumeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Unlock_volume.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__Unlock_volumeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UsersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UsersDefaultArgs<ExtArgs>>): Prisma__UsersClient<$Result.GetResult<Prisma.$UsersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    volume<T extends VolumesDefaultArgs<ExtArgs> = {}>(args?: Subset<T, VolumesDefaultArgs<ExtArgs>>): Prisma__VolumesClient<$Result.GetResult<Prisma.$VolumesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    transaction<T extends TransactionsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TransactionsDefaultArgs<ExtArgs>>): Prisma__TransactionsClient<$Result.GetResult<Prisma.$TransactionsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Unlock_volume model
   */
  interface Unlock_volumeFieldRefs {
    readonly userId: FieldRef<"Unlock_volume", 'Int'>
    readonly volumeId: FieldRef<"Unlock_volume", 'Int'>
    readonly transactionId: FieldRef<"Unlock_volume", 'Int'>
    readonly createdAt: FieldRef<"Unlock_volume", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Unlock_volume findUnique
   */
  export type Unlock_volumeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Unlock_volume
     */
    select?: Unlock_volumeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Unlock_volume
     */
    omit?: Unlock_volumeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Unlock_volumeInclude<ExtArgs> | null
    /**
     * Filter, which Unlock_volume to fetch.
     */
    where: Unlock_volumeWhereUniqueInput
  }

  /**
   * Unlock_volume findUniqueOrThrow
   */
  export type Unlock_volumeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Unlock_volume
     */
    select?: Unlock_volumeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Unlock_volume
     */
    omit?: Unlock_volumeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Unlock_volumeInclude<ExtArgs> | null
    /**
     * Filter, which Unlock_volume to fetch.
     */
    where: Unlock_volumeWhereUniqueInput
  }

  /**
   * Unlock_volume findFirst
   */
  export type Unlock_volumeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Unlock_volume
     */
    select?: Unlock_volumeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Unlock_volume
     */
    omit?: Unlock_volumeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Unlock_volumeInclude<ExtArgs> | null
    /**
     * Filter, which Unlock_volume to fetch.
     */
    where?: Unlock_volumeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Unlock_volumes to fetch.
     */
    orderBy?: Unlock_volumeOrderByWithRelationInput | Unlock_volumeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Unlock_volumes.
     */
    cursor?: Unlock_volumeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Unlock_volumes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Unlock_volumes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Unlock_volumes.
     */
    distinct?: Unlock_volumeScalarFieldEnum | Unlock_volumeScalarFieldEnum[]
  }

  /**
   * Unlock_volume findFirstOrThrow
   */
  export type Unlock_volumeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Unlock_volume
     */
    select?: Unlock_volumeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Unlock_volume
     */
    omit?: Unlock_volumeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Unlock_volumeInclude<ExtArgs> | null
    /**
     * Filter, which Unlock_volume to fetch.
     */
    where?: Unlock_volumeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Unlock_volumes to fetch.
     */
    orderBy?: Unlock_volumeOrderByWithRelationInput | Unlock_volumeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Unlock_volumes.
     */
    cursor?: Unlock_volumeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Unlock_volumes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Unlock_volumes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Unlock_volumes.
     */
    distinct?: Unlock_volumeScalarFieldEnum | Unlock_volumeScalarFieldEnum[]
  }

  /**
   * Unlock_volume findMany
   */
  export type Unlock_volumeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Unlock_volume
     */
    select?: Unlock_volumeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Unlock_volume
     */
    omit?: Unlock_volumeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Unlock_volumeInclude<ExtArgs> | null
    /**
     * Filter, which Unlock_volumes to fetch.
     */
    where?: Unlock_volumeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Unlock_volumes to fetch.
     */
    orderBy?: Unlock_volumeOrderByWithRelationInput | Unlock_volumeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Unlock_volumes.
     */
    cursor?: Unlock_volumeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Unlock_volumes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Unlock_volumes.
     */
    skip?: number
    distinct?: Unlock_volumeScalarFieldEnum | Unlock_volumeScalarFieldEnum[]
  }

  /**
   * Unlock_volume create
   */
  export type Unlock_volumeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Unlock_volume
     */
    select?: Unlock_volumeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Unlock_volume
     */
    omit?: Unlock_volumeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Unlock_volumeInclude<ExtArgs> | null
    /**
     * The data needed to create a Unlock_volume.
     */
    data: XOR<Unlock_volumeCreateInput, Unlock_volumeUncheckedCreateInput>
  }

  /**
   * Unlock_volume createMany
   */
  export type Unlock_volumeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Unlock_volumes.
     */
    data: Unlock_volumeCreateManyInput | Unlock_volumeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Unlock_volume update
   */
  export type Unlock_volumeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Unlock_volume
     */
    select?: Unlock_volumeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Unlock_volume
     */
    omit?: Unlock_volumeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Unlock_volumeInclude<ExtArgs> | null
    /**
     * The data needed to update a Unlock_volume.
     */
    data: XOR<Unlock_volumeUpdateInput, Unlock_volumeUncheckedUpdateInput>
    /**
     * Choose, which Unlock_volume to update.
     */
    where: Unlock_volumeWhereUniqueInput
  }

  /**
   * Unlock_volume updateMany
   */
  export type Unlock_volumeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Unlock_volumes.
     */
    data: XOR<Unlock_volumeUpdateManyMutationInput, Unlock_volumeUncheckedUpdateManyInput>
    /**
     * Filter which Unlock_volumes to update
     */
    where?: Unlock_volumeWhereInput
    /**
     * Limit how many Unlock_volumes to update.
     */
    limit?: number
  }

  /**
   * Unlock_volume upsert
   */
  export type Unlock_volumeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Unlock_volume
     */
    select?: Unlock_volumeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Unlock_volume
     */
    omit?: Unlock_volumeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Unlock_volumeInclude<ExtArgs> | null
    /**
     * The filter to search for the Unlock_volume to update in case it exists.
     */
    where: Unlock_volumeWhereUniqueInput
    /**
     * In case the Unlock_volume found by the `where` argument doesn't exist, create a new Unlock_volume with this data.
     */
    create: XOR<Unlock_volumeCreateInput, Unlock_volumeUncheckedCreateInput>
    /**
     * In case the Unlock_volume was found with the provided `where` argument, update it with this data.
     */
    update: XOR<Unlock_volumeUpdateInput, Unlock_volumeUncheckedUpdateInput>
  }

  /**
   * Unlock_volume delete
   */
  export type Unlock_volumeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Unlock_volume
     */
    select?: Unlock_volumeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Unlock_volume
     */
    omit?: Unlock_volumeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Unlock_volumeInclude<ExtArgs> | null
    /**
     * Filter which Unlock_volume to delete.
     */
    where: Unlock_volumeWhereUniqueInput
  }

  /**
   * Unlock_volume deleteMany
   */
  export type Unlock_volumeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Unlock_volumes to delete
     */
    where?: Unlock_volumeWhereInput
    /**
     * Limit how many Unlock_volumes to delete.
     */
    limit?: number
  }

  /**
   * Unlock_volume without action
   */
  export type Unlock_volumeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Unlock_volume
     */
    select?: Unlock_volumeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Unlock_volume
     */
    omit?: Unlock_volumeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Unlock_volumeInclude<ExtArgs> | null
  }


  /**
   * Model Unlock_chapter
   */

  export type AggregateUnlock_chapter = {
    _count: Unlock_chapterCountAggregateOutputType | null
    _avg: Unlock_chapterAvgAggregateOutputType | null
    _sum: Unlock_chapterSumAggregateOutputType | null
    _min: Unlock_chapterMinAggregateOutputType | null
    _max: Unlock_chapterMaxAggregateOutputType | null
  }

  export type Unlock_chapterAvgAggregateOutputType = {
    userId: number | null
    chapterId: number | null
    transactionId: number | null
  }

  export type Unlock_chapterSumAggregateOutputType = {
    userId: number | null
    chapterId: number | null
    transactionId: number | null
  }

  export type Unlock_chapterMinAggregateOutputType = {
    userId: number | null
    chapterId: number | null
    transactionId: number | null
    createdAt: Date | null
  }

  export type Unlock_chapterMaxAggregateOutputType = {
    userId: number | null
    chapterId: number | null
    transactionId: number | null
    createdAt: Date | null
  }

  export type Unlock_chapterCountAggregateOutputType = {
    userId: number
    chapterId: number
    transactionId: number
    createdAt: number
    _all: number
  }


  export type Unlock_chapterAvgAggregateInputType = {
    userId?: true
    chapterId?: true
    transactionId?: true
  }

  export type Unlock_chapterSumAggregateInputType = {
    userId?: true
    chapterId?: true
    transactionId?: true
  }

  export type Unlock_chapterMinAggregateInputType = {
    userId?: true
    chapterId?: true
    transactionId?: true
    createdAt?: true
  }

  export type Unlock_chapterMaxAggregateInputType = {
    userId?: true
    chapterId?: true
    transactionId?: true
    createdAt?: true
  }

  export type Unlock_chapterCountAggregateInputType = {
    userId?: true
    chapterId?: true
    transactionId?: true
    createdAt?: true
    _all?: true
  }

  export type Unlock_chapterAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Unlock_chapter to aggregate.
     */
    where?: Unlock_chapterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Unlock_chapters to fetch.
     */
    orderBy?: Unlock_chapterOrderByWithRelationInput | Unlock_chapterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: Unlock_chapterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Unlock_chapters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Unlock_chapters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Unlock_chapters
    **/
    _count?: true | Unlock_chapterCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Unlock_chapterAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Unlock_chapterSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Unlock_chapterMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Unlock_chapterMaxAggregateInputType
  }

  export type GetUnlock_chapterAggregateType<T extends Unlock_chapterAggregateArgs> = {
        [P in keyof T & keyof AggregateUnlock_chapter]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUnlock_chapter[P]>
      : GetScalarType<T[P], AggregateUnlock_chapter[P]>
  }




  export type Unlock_chapterGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: Unlock_chapterWhereInput
    orderBy?: Unlock_chapterOrderByWithAggregationInput | Unlock_chapterOrderByWithAggregationInput[]
    by: Unlock_chapterScalarFieldEnum[] | Unlock_chapterScalarFieldEnum
    having?: Unlock_chapterScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Unlock_chapterCountAggregateInputType | true
    _avg?: Unlock_chapterAvgAggregateInputType
    _sum?: Unlock_chapterSumAggregateInputType
    _min?: Unlock_chapterMinAggregateInputType
    _max?: Unlock_chapterMaxAggregateInputType
  }

  export type Unlock_chapterGroupByOutputType = {
    userId: number
    chapterId: number
    transactionId: number
    createdAt: Date
    _count: Unlock_chapterCountAggregateOutputType | null
    _avg: Unlock_chapterAvgAggregateOutputType | null
    _sum: Unlock_chapterSumAggregateOutputType | null
    _min: Unlock_chapterMinAggregateOutputType | null
    _max: Unlock_chapterMaxAggregateOutputType | null
  }

  type GetUnlock_chapterGroupByPayload<T extends Unlock_chapterGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Unlock_chapterGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Unlock_chapterGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Unlock_chapterGroupByOutputType[P]>
            : GetScalarType<T[P], Unlock_chapterGroupByOutputType[P]>
        }
      >
    >


  export type Unlock_chapterSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    userId?: boolean
    chapterId?: boolean
    transactionId?: boolean
    createdAt?: boolean
    user?: boolean | UsersDefaultArgs<ExtArgs>
    chapter?: boolean | ChaptersDefaultArgs<ExtArgs>
    transaction?: boolean | TransactionsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["unlock_chapter"]>



  export type Unlock_chapterSelectScalar = {
    userId?: boolean
    chapterId?: boolean
    transactionId?: boolean
    createdAt?: boolean
  }

  export type Unlock_chapterOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"userId" | "chapterId" | "transactionId" | "createdAt", ExtArgs["result"]["unlock_chapter"]>
  export type Unlock_chapterInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UsersDefaultArgs<ExtArgs>
    chapter?: boolean | ChaptersDefaultArgs<ExtArgs>
    transaction?: boolean | TransactionsDefaultArgs<ExtArgs>
  }

  export type $Unlock_chapterPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Unlock_chapter"
    objects: {
      user: Prisma.$UsersPayload<ExtArgs>
      chapter: Prisma.$ChaptersPayload<ExtArgs>
      transaction: Prisma.$TransactionsPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      userId: number
      chapterId: number
      transactionId: number
      createdAt: Date
    }, ExtArgs["result"]["unlock_chapter"]>
    composites: {}
  }

  type Unlock_chapterGetPayload<S extends boolean | null | undefined | Unlock_chapterDefaultArgs> = $Result.GetResult<Prisma.$Unlock_chapterPayload, S>

  type Unlock_chapterCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<Unlock_chapterFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Unlock_chapterCountAggregateInputType | true
    }

  export interface Unlock_chapterDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Unlock_chapter'], meta: { name: 'Unlock_chapter' } }
    /**
     * Find zero or one Unlock_chapter that matches the filter.
     * @param {Unlock_chapterFindUniqueArgs} args - Arguments to find a Unlock_chapter
     * @example
     * // Get one Unlock_chapter
     * const unlock_chapter = await prisma.unlock_chapter.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends Unlock_chapterFindUniqueArgs>(args: SelectSubset<T, Unlock_chapterFindUniqueArgs<ExtArgs>>): Prisma__Unlock_chapterClient<$Result.GetResult<Prisma.$Unlock_chapterPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Unlock_chapter that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {Unlock_chapterFindUniqueOrThrowArgs} args - Arguments to find a Unlock_chapter
     * @example
     * // Get one Unlock_chapter
     * const unlock_chapter = await prisma.unlock_chapter.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends Unlock_chapterFindUniqueOrThrowArgs>(args: SelectSubset<T, Unlock_chapterFindUniqueOrThrowArgs<ExtArgs>>): Prisma__Unlock_chapterClient<$Result.GetResult<Prisma.$Unlock_chapterPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Unlock_chapter that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Unlock_chapterFindFirstArgs} args - Arguments to find a Unlock_chapter
     * @example
     * // Get one Unlock_chapter
     * const unlock_chapter = await prisma.unlock_chapter.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends Unlock_chapterFindFirstArgs>(args?: SelectSubset<T, Unlock_chapterFindFirstArgs<ExtArgs>>): Prisma__Unlock_chapterClient<$Result.GetResult<Prisma.$Unlock_chapterPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Unlock_chapter that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Unlock_chapterFindFirstOrThrowArgs} args - Arguments to find a Unlock_chapter
     * @example
     * // Get one Unlock_chapter
     * const unlock_chapter = await prisma.unlock_chapter.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends Unlock_chapterFindFirstOrThrowArgs>(args?: SelectSubset<T, Unlock_chapterFindFirstOrThrowArgs<ExtArgs>>): Prisma__Unlock_chapterClient<$Result.GetResult<Prisma.$Unlock_chapterPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Unlock_chapters that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Unlock_chapterFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Unlock_chapters
     * const unlock_chapters = await prisma.unlock_chapter.findMany()
     * 
     * // Get first 10 Unlock_chapters
     * const unlock_chapters = await prisma.unlock_chapter.findMany({ take: 10 })
     * 
     * // Only select the `userId`
     * const unlock_chapterWithUserIdOnly = await prisma.unlock_chapter.findMany({ select: { userId: true } })
     * 
     */
    findMany<T extends Unlock_chapterFindManyArgs>(args?: SelectSubset<T, Unlock_chapterFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$Unlock_chapterPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Unlock_chapter.
     * @param {Unlock_chapterCreateArgs} args - Arguments to create a Unlock_chapter.
     * @example
     * // Create one Unlock_chapter
     * const Unlock_chapter = await prisma.unlock_chapter.create({
     *   data: {
     *     // ... data to create a Unlock_chapter
     *   }
     * })
     * 
     */
    create<T extends Unlock_chapterCreateArgs>(args: SelectSubset<T, Unlock_chapterCreateArgs<ExtArgs>>): Prisma__Unlock_chapterClient<$Result.GetResult<Prisma.$Unlock_chapterPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Unlock_chapters.
     * @param {Unlock_chapterCreateManyArgs} args - Arguments to create many Unlock_chapters.
     * @example
     * // Create many Unlock_chapters
     * const unlock_chapter = await prisma.unlock_chapter.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends Unlock_chapterCreateManyArgs>(args?: SelectSubset<T, Unlock_chapterCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Unlock_chapter.
     * @param {Unlock_chapterDeleteArgs} args - Arguments to delete one Unlock_chapter.
     * @example
     * // Delete one Unlock_chapter
     * const Unlock_chapter = await prisma.unlock_chapter.delete({
     *   where: {
     *     // ... filter to delete one Unlock_chapter
     *   }
     * })
     * 
     */
    delete<T extends Unlock_chapterDeleteArgs>(args: SelectSubset<T, Unlock_chapterDeleteArgs<ExtArgs>>): Prisma__Unlock_chapterClient<$Result.GetResult<Prisma.$Unlock_chapterPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Unlock_chapter.
     * @param {Unlock_chapterUpdateArgs} args - Arguments to update one Unlock_chapter.
     * @example
     * // Update one Unlock_chapter
     * const unlock_chapter = await prisma.unlock_chapter.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends Unlock_chapterUpdateArgs>(args: SelectSubset<T, Unlock_chapterUpdateArgs<ExtArgs>>): Prisma__Unlock_chapterClient<$Result.GetResult<Prisma.$Unlock_chapterPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Unlock_chapters.
     * @param {Unlock_chapterDeleteManyArgs} args - Arguments to filter Unlock_chapters to delete.
     * @example
     * // Delete a few Unlock_chapters
     * const { count } = await prisma.unlock_chapter.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends Unlock_chapterDeleteManyArgs>(args?: SelectSubset<T, Unlock_chapterDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Unlock_chapters.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Unlock_chapterUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Unlock_chapters
     * const unlock_chapter = await prisma.unlock_chapter.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends Unlock_chapterUpdateManyArgs>(args: SelectSubset<T, Unlock_chapterUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Unlock_chapter.
     * @param {Unlock_chapterUpsertArgs} args - Arguments to update or create a Unlock_chapter.
     * @example
     * // Update or create a Unlock_chapter
     * const unlock_chapter = await prisma.unlock_chapter.upsert({
     *   create: {
     *     // ... data to create a Unlock_chapter
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Unlock_chapter we want to update
     *   }
     * })
     */
    upsert<T extends Unlock_chapterUpsertArgs>(args: SelectSubset<T, Unlock_chapterUpsertArgs<ExtArgs>>): Prisma__Unlock_chapterClient<$Result.GetResult<Prisma.$Unlock_chapterPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Unlock_chapters.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Unlock_chapterCountArgs} args - Arguments to filter Unlock_chapters to count.
     * @example
     * // Count the number of Unlock_chapters
     * const count = await prisma.unlock_chapter.count({
     *   where: {
     *     // ... the filter for the Unlock_chapters we want to count
     *   }
     * })
    **/
    count<T extends Unlock_chapterCountArgs>(
      args?: Subset<T, Unlock_chapterCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Unlock_chapterCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Unlock_chapter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Unlock_chapterAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Unlock_chapterAggregateArgs>(args: Subset<T, Unlock_chapterAggregateArgs>): Prisma.PrismaPromise<GetUnlock_chapterAggregateType<T>>

    /**
     * Group by Unlock_chapter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Unlock_chapterGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Unlock_chapterGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Unlock_chapterGroupByArgs['orderBy'] }
        : { orderBy?: Unlock_chapterGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Unlock_chapterGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUnlock_chapterGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Unlock_chapter model
   */
  readonly fields: Unlock_chapterFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Unlock_chapter.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__Unlock_chapterClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UsersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UsersDefaultArgs<ExtArgs>>): Prisma__UsersClient<$Result.GetResult<Prisma.$UsersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    chapter<T extends ChaptersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ChaptersDefaultArgs<ExtArgs>>): Prisma__ChaptersClient<$Result.GetResult<Prisma.$ChaptersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    transaction<T extends TransactionsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TransactionsDefaultArgs<ExtArgs>>): Prisma__TransactionsClient<$Result.GetResult<Prisma.$TransactionsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Unlock_chapter model
   */
  interface Unlock_chapterFieldRefs {
    readonly userId: FieldRef<"Unlock_chapter", 'Int'>
    readonly chapterId: FieldRef<"Unlock_chapter", 'Int'>
    readonly transactionId: FieldRef<"Unlock_chapter", 'Int'>
    readonly createdAt: FieldRef<"Unlock_chapter", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Unlock_chapter findUnique
   */
  export type Unlock_chapterFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Unlock_chapter
     */
    select?: Unlock_chapterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Unlock_chapter
     */
    omit?: Unlock_chapterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Unlock_chapterInclude<ExtArgs> | null
    /**
     * Filter, which Unlock_chapter to fetch.
     */
    where: Unlock_chapterWhereUniqueInput
  }

  /**
   * Unlock_chapter findUniqueOrThrow
   */
  export type Unlock_chapterFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Unlock_chapter
     */
    select?: Unlock_chapterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Unlock_chapter
     */
    omit?: Unlock_chapterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Unlock_chapterInclude<ExtArgs> | null
    /**
     * Filter, which Unlock_chapter to fetch.
     */
    where: Unlock_chapterWhereUniqueInput
  }

  /**
   * Unlock_chapter findFirst
   */
  export type Unlock_chapterFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Unlock_chapter
     */
    select?: Unlock_chapterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Unlock_chapter
     */
    omit?: Unlock_chapterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Unlock_chapterInclude<ExtArgs> | null
    /**
     * Filter, which Unlock_chapter to fetch.
     */
    where?: Unlock_chapterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Unlock_chapters to fetch.
     */
    orderBy?: Unlock_chapterOrderByWithRelationInput | Unlock_chapterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Unlock_chapters.
     */
    cursor?: Unlock_chapterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Unlock_chapters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Unlock_chapters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Unlock_chapters.
     */
    distinct?: Unlock_chapterScalarFieldEnum | Unlock_chapterScalarFieldEnum[]
  }

  /**
   * Unlock_chapter findFirstOrThrow
   */
  export type Unlock_chapterFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Unlock_chapter
     */
    select?: Unlock_chapterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Unlock_chapter
     */
    omit?: Unlock_chapterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Unlock_chapterInclude<ExtArgs> | null
    /**
     * Filter, which Unlock_chapter to fetch.
     */
    where?: Unlock_chapterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Unlock_chapters to fetch.
     */
    orderBy?: Unlock_chapterOrderByWithRelationInput | Unlock_chapterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Unlock_chapters.
     */
    cursor?: Unlock_chapterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Unlock_chapters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Unlock_chapters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Unlock_chapters.
     */
    distinct?: Unlock_chapterScalarFieldEnum | Unlock_chapterScalarFieldEnum[]
  }

  /**
   * Unlock_chapter findMany
   */
  export type Unlock_chapterFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Unlock_chapter
     */
    select?: Unlock_chapterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Unlock_chapter
     */
    omit?: Unlock_chapterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Unlock_chapterInclude<ExtArgs> | null
    /**
     * Filter, which Unlock_chapters to fetch.
     */
    where?: Unlock_chapterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Unlock_chapters to fetch.
     */
    orderBy?: Unlock_chapterOrderByWithRelationInput | Unlock_chapterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Unlock_chapters.
     */
    cursor?: Unlock_chapterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Unlock_chapters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Unlock_chapters.
     */
    skip?: number
    distinct?: Unlock_chapterScalarFieldEnum | Unlock_chapterScalarFieldEnum[]
  }

  /**
   * Unlock_chapter create
   */
  export type Unlock_chapterCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Unlock_chapter
     */
    select?: Unlock_chapterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Unlock_chapter
     */
    omit?: Unlock_chapterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Unlock_chapterInclude<ExtArgs> | null
    /**
     * The data needed to create a Unlock_chapter.
     */
    data: XOR<Unlock_chapterCreateInput, Unlock_chapterUncheckedCreateInput>
  }

  /**
   * Unlock_chapter createMany
   */
  export type Unlock_chapterCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Unlock_chapters.
     */
    data: Unlock_chapterCreateManyInput | Unlock_chapterCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Unlock_chapter update
   */
  export type Unlock_chapterUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Unlock_chapter
     */
    select?: Unlock_chapterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Unlock_chapter
     */
    omit?: Unlock_chapterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Unlock_chapterInclude<ExtArgs> | null
    /**
     * The data needed to update a Unlock_chapter.
     */
    data: XOR<Unlock_chapterUpdateInput, Unlock_chapterUncheckedUpdateInput>
    /**
     * Choose, which Unlock_chapter to update.
     */
    where: Unlock_chapterWhereUniqueInput
  }

  /**
   * Unlock_chapter updateMany
   */
  export type Unlock_chapterUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Unlock_chapters.
     */
    data: XOR<Unlock_chapterUpdateManyMutationInput, Unlock_chapterUncheckedUpdateManyInput>
    /**
     * Filter which Unlock_chapters to update
     */
    where?: Unlock_chapterWhereInput
    /**
     * Limit how many Unlock_chapters to update.
     */
    limit?: number
  }

  /**
   * Unlock_chapter upsert
   */
  export type Unlock_chapterUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Unlock_chapter
     */
    select?: Unlock_chapterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Unlock_chapter
     */
    omit?: Unlock_chapterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Unlock_chapterInclude<ExtArgs> | null
    /**
     * The filter to search for the Unlock_chapter to update in case it exists.
     */
    where: Unlock_chapterWhereUniqueInput
    /**
     * In case the Unlock_chapter found by the `where` argument doesn't exist, create a new Unlock_chapter with this data.
     */
    create: XOR<Unlock_chapterCreateInput, Unlock_chapterUncheckedCreateInput>
    /**
     * In case the Unlock_chapter was found with the provided `where` argument, update it with this data.
     */
    update: XOR<Unlock_chapterUpdateInput, Unlock_chapterUncheckedUpdateInput>
  }

  /**
   * Unlock_chapter delete
   */
  export type Unlock_chapterDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Unlock_chapter
     */
    select?: Unlock_chapterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Unlock_chapter
     */
    omit?: Unlock_chapterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Unlock_chapterInclude<ExtArgs> | null
    /**
     * Filter which Unlock_chapter to delete.
     */
    where: Unlock_chapterWhereUniqueInput
  }

  /**
   * Unlock_chapter deleteMany
   */
  export type Unlock_chapterDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Unlock_chapters to delete
     */
    where?: Unlock_chapterWhereInput
    /**
     * Limit how many Unlock_chapters to delete.
     */
    limit?: number
  }

  /**
   * Unlock_chapter without action
   */
  export type Unlock_chapterDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Unlock_chapter
     */
    select?: Unlock_chapterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Unlock_chapter
     */
    omit?: Unlock_chapterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Unlock_chapterInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const CategoriesScalarFieldEnum: {
    id: 'id',
    title: 'title'
  };

  export type CategoriesScalarFieldEnum = (typeof CategoriesScalarFieldEnum)[keyof typeof CategoriesScalarFieldEnum]


  export const AuthorsScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    keywords: 'keywords'
  };

  export type AuthorsScalarFieldEnum = (typeof AuthorsScalarFieldEnum)[keyof typeof AuthorsScalarFieldEnum]


  export const ComicsScalarFieldEnum: {
    id: 'id',
    title: 'title',
    description: 'description',
    image: 'image',
    keywords: 'keywords',
    status: 'status',
    price: 'price',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    userId: 'userId'
  };

  export type ComicsScalarFieldEnum = (typeof ComicsScalarFieldEnum)[keyof typeof ComicsScalarFieldEnum]


  export const VolumesScalarFieldEnum: {
    id: 'id',
    title: 'title',
    description: 'description',
    price: 'price',
    comicId: 'comicId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type VolumesScalarFieldEnum = (typeof VolumesScalarFieldEnum)[keyof typeof VolumesScalarFieldEnum]


  export const ChaptersScalarFieldEnum: {
    id: 'id',
    title: 'title',
    filePath: 'filePath',
    content: 'content',
    price: 'price',
    lock: 'lock',
    volumeId: 'volumeId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ChaptersScalarFieldEnum = (typeof ChaptersScalarFieldEnum)[keyof typeof ChaptersScalarFieldEnum]


  export const RolesScalarFieldEnum: {
    id: 'id',
    title: 'title',
    description: 'description'
  };

  export type RolesScalarFieldEnum = (typeof RolesScalarFieldEnum)[keyof typeof RolesScalarFieldEnum]


  export const UsersScalarFieldEnum: {
    id: 'id',
    name: 'name',
    email: 'email',
    password: 'password',
    description: 'description',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    isDisabled: 'isDisabled'
  };

  export type UsersScalarFieldEnum = (typeof UsersScalarFieldEnum)[keyof typeof UsersScalarFieldEnum]


  export const FavoritesScalarFieldEnum: {
    userId: 'userId',
    comicId: 'comicId',
    addedAt: 'addedAt'
  };

  export type FavoritesScalarFieldEnum = (typeof FavoritesScalarFieldEnum)[keyof typeof FavoritesScalarFieldEnum]


  export const RatesScalarFieldEnum: {
    userId: 'userId',
    comicId: 'comicId',
    score: 'score',
    content: 'content',
    createdAt: 'createdAt'
  };

  export type RatesScalarFieldEnum = (typeof RatesScalarFieldEnum)[keyof typeof RatesScalarFieldEnum]


  export const ErrorsScalarFieldEnum: {
    userId: 'userId',
    chapterId: 'chapterId',
    content: 'content',
    status: 'status',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ErrorsScalarFieldEnum = (typeof ErrorsScalarFieldEnum)[keyof typeof ErrorsScalarFieldEnum]


  export const ViewsScalarFieldEnum: {
    userId: 'userId',
    comicId: 'comicId',
    chapterId: 'chapterId',
    lastedAt: 'lastedAt'
  };

  export type ViewsScalarFieldEnum = (typeof ViewsScalarFieldEnum)[keyof typeof ViewsScalarFieldEnum]


  export const CommentsScalarFieldEnum: {
    id: 'id',
    content: 'content',
    userId: 'userId',
    chapterId: 'chapterId',
    comicId: 'comicId',
    createdAt: 'createdAt'
  };

  export type CommentsScalarFieldEnum = (typeof CommentsScalarFieldEnum)[keyof typeof CommentsScalarFieldEnum]


  export const NotificationsScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    commentId: 'commentId',
    content: 'content',
    isRead: 'isRead',
    createdAt: 'createdAt'
  };

  export type NotificationsScalarFieldEnum = (typeof NotificationsScalarFieldEnum)[keyof typeof NotificationsScalarFieldEnum]


  export const WalletsScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    value: 'value',
    updatedAt: 'updatedAt'
  };

  export type WalletsScalarFieldEnum = (typeof WalletsScalarFieldEnum)[keyof typeof WalletsScalarFieldEnum]


  export const TransactionsScalarFieldEnum: {
    id: 'id',
    walletId: 'walletId',
    amount: 'amount',
    description: 'description',
    status: 'status',
    createdAt: 'createdAt'
  };

  export type TransactionsScalarFieldEnum = (typeof TransactionsScalarFieldEnum)[keyof typeof TransactionsScalarFieldEnum]


  export const Unlock_comicScalarFieldEnum: {
    userId: 'userId',
    comicId: 'comicId',
    transactionId: 'transactionId',
    createdAt: 'createdAt'
  };

  export type Unlock_comicScalarFieldEnum = (typeof Unlock_comicScalarFieldEnum)[keyof typeof Unlock_comicScalarFieldEnum]


  export const Unlock_volumeScalarFieldEnum: {
    userId: 'userId',
    volumeId: 'volumeId',
    transactionId: 'transactionId',
    createdAt: 'createdAt'
  };

  export type Unlock_volumeScalarFieldEnum = (typeof Unlock_volumeScalarFieldEnum)[keyof typeof Unlock_volumeScalarFieldEnum]


  export const Unlock_chapterScalarFieldEnum: {
    userId: 'userId',
    chapterId: 'chapterId',
    transactionId: 'transactionId',
    createdAt: 'createdAt'
  };

  export type Unlock_chapterScalarFieldEnum = (typeof Unlock_chapterScalarFieldEnum)[keyof typeof Unlock_chapterScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const CategoriesOrderByRelevanceFieldEnum: {
    title: 'title'
  };

  export type CategoriesOrderByRelevanceFieldEnum = (typeof CategoriesOrderByRelevanceFieldEnum)[keyof typeof CategoriesOrderByRelevanceFieldEnum]


  export const AuthorsOrderByRelevanceFieldEnum: {
    name: 'name',
    description: 'description',
    keywords: 'keywords'
  };

  export type AuthorsOrderByRelevanceFieldEnum = (typeof AuthorsOrderByRelevanceFieldEnum)[keyof typeof AuthorsOrderByRelevanceFieldEnum]


  export const ComicsOrderByRelevanceFieldEnum: {
    title: 'title',
    description: 'description',
    image: 'image',
    keywords: 'keywords',
    status: 'status'
  };

  export type ComicsOrderByRelevanceFieldEnum = (typeof ComicsOrderByRelevanceFieldEnum)[keyof typeof ComicsOrderByRelevanceFieldEnum]


  export const VolumesOrderByRelevanceFieldEnum: {
    title: 'title',
    description: 'description'
  };

  export type VolumesOrderByRelevanceFieldEnum = (typeof VolumesOrderByRelevanceFieldEnum)[keyof typeof VolumesOrderByRelevanceFieldEnum]


  export const ChaptersOrderByRelevanceFieldEnum: {
    title: 'title',
    filePath: 'filePath',
    content: 'content'
  };

  export type ChaptersOrderByRelevanceFieldEnum = (typeof ChaptersOrderByRelevanceFieldEnum)[keyof typeof ChaptersOrderByRelevanceFieldEnum]


  export const RolesOrderByRelevanceFieldEnum: {
    title: 'title',
    description: 'description'
  };

  export type RolesOrderByRelevanceFieldEnum = (typeof RolesOrderByRelevanceFieldEnum)[keyof typeof RolesOrderByRelevanceFieldEnum]


  export const UsersOrderByRelevanceFieldEnum: {
    name: 'name',
    email: 'email',
    password: 'password',
    description: 'description'
  };

  export type UsersOrderByRelevanceFieldEnum = (typeof UsersOrderByRelevanceFieldEnum)[keyof typeof UsersOrderByRelevanceFieldEnum]


  export const RatesOrderByRelevanceFieldEnum: {
    content: 'content'
  };

  export type RatesOrderByRelevanceFieldEnum = (typeof RatesOrderByRelevanceFieldEnum)[keyof typeof RatesOrderByRelevanceFieldEnum]


  export const ErrorsOrderByRelevanceFieldEnum: {
    content: 'content',
    status: 'status'
  };

  export type ErrorsOrderByRelevanceFieldEnum = (typeof ErrorsOrderByRelevanceFieldEnum)[keyof typeof ErrorsOrderByRelevanceFieldEnum]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  export const CommentsOrderByRelevanceFieldEnum: {
    content: 'content'
  };

  export type CommentsOrderByRelevanceFieldEnum = (typeof CommentsOrderByRelevanceFieldEnum)[keyof typeof CommentsOrderByRelevanceFieldEnum]


  export const NotificationsOrderByRelevanceFieldEnum: {
    content: 'content'
  };

  export type NotificationsOrderByRelevanceFieldEnum = (typeof NotificationsOrderByRelevanceFieldEnum)[keyof typeof NotificationsOrderByRelevanceFieldEnum]


  export const TransactionsOrderByRelevanceFieldEnum: {
    description: 'description',
    status: 'status'
  };

  export type TransactionsOrderByRelevanceFieldEnum = (typeof TransactionsOrderByRelevanceFieldEnum)[keyof typeof TransactionsOrderByRelevanceFieldEnum]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'Decimal'
   */
  export type DecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    
  /**
   * Deep Input Types
   */


  export type CategoriesWhereInput = {
    AND?: CategoriesWhereInput | CategoriesWhereInput[]
    OR?: CategoriesWhereInput[]
    NOT?: CategoriesWhereInput | CategoriesWhereInput[]
    id?: IntFilter<"Categories"> | number
    title?: StringFilter<"Categories"> | string
    comics?: ComicsListRelationFilter
  }

  export type CategoriesOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    comics?: ComicsOrderByRelationAggregateInput
    _relevance?: CategoriesOrderByRelevanceInput
  }

  export type CategoriesWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    title?: string
    AND?: CategoriesWhereInput | CategoriesWhereInput[]
    OR?: CategoriesWhereInput[]
    NOT?: CategoriesWhereInput | CategoriesWhereInput[]
    comics?: ComicsListRelationFilter
  }, "id" | "title">

  export type CategoriesOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    _count?: CategoriesCountOrderByAggregateInput
    _avg?: CategoriesAvgOrderByAggregateInput
    _max?: CategoriesMaxOrderByAggregateInput
    _min?: CategoriesMinOrderByAggregateInput
    _sum?: CategoriesSumOrderByAggregateInput
  }

  export type CategoriesScalarWhereWithAggregatesInput = {
    AND?: CategoriesScalarWhereWithAggregatesInput | CategoriesScalarWhereWithAggregatesInput[]
    OR?: CategoriesScalarWhereWithAggregatesInput[]
    NOT?: CategoriesScalarWhereWithAggregatesInput | CategoriesScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Categories"> | number
    title?: StringWithAggregatesFilter<"Categories"> | string
  }

  export type AuthorsWhereInput = {
    AND?: AuthorsWhereInput | AuthorsWhereInput[]
    OR?: AuthorsWhereInput[]
    NOT?: AuthorsWhereInput | AuthorsWhereInput[]
    id?: IntFilter<"Authors"> | number
    name?: StringFilter<"Authors"> | string
    description?: StringFilter<"Authors"> | string
    keywords?: StringFilter<"Authors"> | string
    comics?: ComicsListRelationFilter
  }

  export type AuthorsOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    keywords?: SortOrder
    comics?: ComicsOrderByRelationAggregateInput
    _relevance?: AuthorsOrderByRelevanceInput
  }

  export type AuthorsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    name?: string
    AND?: AuthorsWhereInput | AuthorsWhereInput[]
    OR?: AuthorsWhereInput[]
    NOT?: AuthorsWhereInput | AuthorsWhereInput[]
    description?: StringFilter<"Authors"> | string
    keywords?: StringFilter<"Authors"> | string
    comics?: ComicsListRelationFilter
  }, "id" | "name">

  export type AuthorsOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    keywords?: SortOrder
    _count?: AuthorsCountOrderByAggregateInput
    _avg?: AuthorsAvgOrderByAggregateInput
    _max?: AuthorsMaxOrderByAggregateInput
    _min?: AuthorsMinOrderByAggregateInput
    _sum?: AuthorsSumOrderByAggregateInput
  }

  export type AuthorsScalarWhereWithAggregatesInput = {
    AND?: AuthorsScalarWhereWithAggregatesInput | AuthorsScalarWhereWithAggregatesInput[]
    OR?: AuthorsScalarWhereWithAggregatesInput[]
    NOT?: AuthorsScalarWhereWithAggregatesInput | AuthorsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Authors"> | number
    name?: StringWithAggregatesFilter<"Authors"> | string
    description?: StringWithAggregatesFilter<"Authors"> | string
    keywords?: StringWithAggregatesFilter<"Authors"> | string
  }

  export type ComicsWhereInput = {
    AND?: ComicsWhereInput | ComicsWhereInput[]
    OR?: ComicsWhereInput[]
    NOT?: ComicsWhereInput | ComicsWhereInput[]
    id?: IntFilter<"Comics"> | number
    title?: StringFilter<"Comics"> | string
    description?: StringFilter<"Comics"> | string
    image?: StringFilter<"Comics"> | string
    keywords?: StringFilter<"Comics"> | string
    status?: StringFilter<"Comics"> | string
    price?: DecimalFilter<"Comics"> | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFilter<"Comics"> | Date | string
    updatedAt?: DateTimeFilter<"Comics"> | Date | string
    userId?: IntFilter<"Comics"> | number
    categories?: CategoriesListRelationFilter
    authors?: AuthorsListRelationFilter
    volumes?: VolumesListRelationFilter
    favorites?: FavoritesListRelationFilter
    rates?: RatesListRelationFilter
    views?: ViewsListRelationFilter
    comment?: CommentsListRelationFilter
    unlock_comic?: Unlock_comicListRelationFilter
    user?: XOR<UsersScalarRelationFilter, UsersWhereInput>
  }

  export type ComicsOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    image?: SortOrder
    keywords?: SortOrder
    status?: SortOrder
    price?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrder
    categories?: CategoriesOrderByRelationAggregateInput
    authors?: AuthorsOrderByRelationAggregateInput
    volumes?: VolumesOrderByRelationAggregateInput
    favorites?: FavoritesOrderByRelationAggregateInput
    rates?: RatesOrderByRelationAggregateInput
    views?: ViewsOrderByRelationAggregateInput
    comment?: CommentsOrderByRelationAggregateInput
    unlock_comic?: Unlock_comicOrderByRelationAggregateInput
    user?: UsersOrderByWithRelationInput
    _relevance?: ComicsOrderByRelevanceInput
  }

  export type ComicsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    title?: string
    AND?: ComicsWhereInput | ComicsWhereInput[]
    OR?: ComicsWhereInput[]
    NOT?: ComicsWhereInput | ComicsWhereInput[]
    description?: StringFilter<"Comics"> | string
    image?: StringFilter<"Comics"> | string
    keywords?: StringFilter<"Comics"> | string
    status?: StringFilter<"Comics"> | string
    price?: DecimalFilter<"Comics"> | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFilter<"Comics"> | Date | string
    updatedAt?: DateTimeFilter<"Comics"> | Date | string
    userId?: IntFilter<"Comics"> | number
    categories?: CategoriesListRelationFilter
    authors?: AuthorsListRelationFilter
    volumes?: VolumesListRelationFilter
    favorites?: FavoritesListRelationFilter
    rates?: RatesListRelationFilter
    views?: ViewsListRelationFilter
    comment?: CommentsListRelationFilter
    unlock_comic?: Unlock_comicListRelationFilter
    user?: XOR<UsersScalarRelationFilter, UsersWhereInput>
  }, "id" | "title">

  export type ComicsOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    image?: SortOrder
    keywords?: SortOrder
    status?: SortOrder
    price?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrder
    _count?: ComicsCountOrderByAggregateInput
    _avg?: ComicsAvgOrderByAggregateInput
    _max?: ComicsMaxOrderByAggregateInput
    _min?: ComicsMinOrderByAggregateInput
    _sum?: ComicsSumOrderByAggregateInput
  }

  export type ComicsScalarWhereWithAggregatesInput = {
    AND?: ComicsScalarWhereWithAggregatesInput | ComicsScalarWhereWithAggregatesInput[]
    OR?: ComicsScalarWhereWithAggregatesInput[]
    NOT?: ComicsScalarWhereWithAggregatesInput | ComicsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Comics"> | number
    title?: StringWithAggregatesFilter<"Comics"> | string
    description?: StringWithAggregatesFilter<"Comics"> | string
    image?: StringWithAggregatesFilter<"Comics"> | string
    keywords?: StringWithAggregatesFilter<"Comics"> | string
    status?: StringWithAggregatesFilter<"Comics"> | string
    price?: DecimalWithAggregatesFilter<"Comics"> | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeWithAggregatesFilter<"Comics"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Comics"> | Date | string
    userId?: IntWithAggregatesFilter<"Comics"> | number
  }

  export type VolumesWhereInput = {
    AND?: VolumesWhereInput | VolumesWhereInput[]
    OR?: VolumesWhereInput[]
    NOT?: VolumesWhereInput | VolumesWhereInput[]
    id?: IntFilter<"Volumes"> | number
    title?: StringFilter<"Volumes"> | string
    description?: StringFilter<"Volumes"> | string
    price?: DecimalFilter<"Volumes"> | Decimal | DecimalJsLike | number | string
    comicId?: IntFilter<"Volumes"> | number
    createdAt?: DateTimeFilter<"Volumes"> | Date | string
    updatedAt?: DateTimeFilter<"Volumes"> | Date | string
    comic?: XOR<ComicsScalarRelationFilter, ComicsWhereInput>
    chapters?: ChaptersListRelationFilter
    unlock_volume?: Unlock_volumeListRelationFilter
  }

  export type VolumesOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    price?: SortOrder
    comicId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    comic?: ComicsOrderByWithRelationInput
    chapters?: ChaptersOrderByRelationAggregateInput
    unlock_volume?: Unlock_volumeOrderByRelationAggregateInput
    _relevance?: VolumesOrderByRelevanceInput
  }

  export type VolumesWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: VolumesWhereInput | VolumesWhereInput[]
    OR?: VolumesWhereInput[]
    NOT?: VolumesWhereInput | VolumesWhereInput[]
    title?: StringFilter<"Volumes"> | string
    description?: StringFilter<"Volumes"> | string
    price?: DecimalFilter<"Volumes"> | Decimal | DecimalJsLike | number | string
    comicId?: IntFilter<"Volumes"> | number
    createdAt?: DateTimeFilter<"Volumes"> | Date | string
    updatedAt?: DateTimeFilter<"Volumes"> | Date | string
    comic?: XOR<ComicsScalarRelationFilter, ComicsWhereInput>
    chapters?: ChaptersListRelationFilter
    unlock_volume?: Unlock_volumeListRelationFilter
  }, "id">

  export type VolumesOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    price?: SortOrder
    comicId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: VolumesCountOrderByAggregateInput
    _avg?: VolumesAvgOrderByAggregateInput
    _max?: VolumesMaxOrderByAggregateInput
    _min?: VolumesMinOrderByAggregateInput
    _sum?: VolumesSumOrderByAggregateInput
  }

  export type VolumesScalarWhereWithAggregatesInput = {
    AND?: VolumesScalarWhereWithAggregatesInput | VolumesScalarWhereWithAggregatesInput[]
    OR?: VolumesScalarWhereWithAggregatesInput[]
    NOT?: VolumesScalarWhereWithAggregatesInput | VolumesScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Volumes"> | number
    title?: StringWithAggregatesFilter<"Volumes"> | string
    description?: StringWithAggregatesFilter<"Volumes"> | string
    price?: DecimalWithAggregatesFilter<"Volumes"> | Decimal | DecimalJsLike | number | string
    comicId?: IntWithAggregatesFilter<"Volumes"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Volumes"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Volumes"> | Date | string
  }

  export type ChaptersWhereInput = {
    AND?: ChaptersWhereInput | ChaptersWhereInput[]
    OR?: ChaptersWhereInput[]
    NOT?: ChaptersWhereInput | ChaptersWhereInput[]
    id?: IntFilter<"Chapters"> | number
    title?: StringFilter<"Chapters"> | string
    filePath?: StringFilter<"Chapters"> | string
    content?: StringFilter<"Chapters"> | string
    price?: DecimalFilter<"Chapters"> | Decimal | DecimalJsLike | number | string
    lock?: BoolFilter<"Chapters"> | boolean
    volumeId?: IntFilter<"Chapters"> | number
    createdAt?: DateTimeFilter<"Chapters"> | Date | string
    updatedAt?: DateTimeFilter<"Chapters"> | Date | string
    volume?: XOR<VolumesScalarRelationFilter, VolumesWhereInput>
    errors?: ErrorsListRelationFilter
    views?: ViewsListRelationFilter
    coments?: CommentsListRelationFilter
    unlock_chapter?: Unlock_chapterListRelationFilter
  }

  export type ChaptersOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    filePath?: SortOrder
    content?: SortOrder
    price?: SortOrder
    lock?: SortOrder
    volumeId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    volume?: VolumesOrderByWithRelationInput
    errors?: ErrorsOrderByRelationAggregateInput
    views?: ViewsOrderByRelationAggregateInput
    coments?: CommentsOrderByRelationAggregateInput
    unlock_chapter?: Unlock_chapterOrderByRelationAggregateInput
    _relevance?: ChaptersOrderByRelevanceInput
  }

  export type ChaptersWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ChaptersWhereInput | ChaptersWhereInput[]
    OR?: ChaptersWhereInput[]
    NOT?: ChaptersWhereInput | ChaptersWhereInput[]
    title?: StringFilter<"Chapters"> | string
    filePath?: StringFilter<"Chapters"> | string
    content?: StringFilter<"Chapters"> | string
    price?: DecimalFilter<"Chapters"> | Decimal | DecimalJsLike | number | string
    lock?: BoolFilter<"Chapters"> | boolean
    volumeId?: IntFilter<"Chapters"> | number
    createdAt?: DateTimeFilter<"Chapters"> | Date | string
    updatedAt?: DateTimeFilter<"Chapters"> | Date | string
    volume?: XOR<VolumesScalarRelationFilter, VolumesWhereInput>
    errors?: ErrorsListRelationFilter
    views?: ViewsListRelationFilter
    coments?: CommentsListRelationFilter
    unlock_chapter?: Unlock_chapterListRelationFilter
  }, "id">

  export type ChaptersOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    filePath?: SortOrder
    content?: SortOrder
    price?: SortOrder
    lock?: SortOrder
    volumeId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ChaptersCountOrderByAggregateInput
    _avg?: ChaptersAvgOrderByAggregateInput
    _max?: ChaptersMaxOrderByAggregateInput
    _min?: ChaptersMinOrderByAggregateInput
    _sum?: ChaptersSumOrderByAggregateInput
  }

  export type ChaptersScalarWhereWithAggregatesInput = {
    AND?: ChaptersScalarWhereWithAggregatesInput | ChaptersScalarWhereWithAggregatesInput[]
    OR?: ChaptersScalarWhereWithAggregatesInput[]
    NOT?: ChaptersScalarWhereWithAggregatesInput | ChaptersScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Chapters"> | number
    title?: StringWithAggregatesFilter<"Chapters"> | string
    filePath?: StringWithAggregatesFilter<"Chapters"> | string
    content?: StringWithAggregatesFilter<"Chapters"> | string
    price?: DecimalWithAggregatesFilter<"Chapters"> | Decimal | DecimalJsLike | number | string
    lock?: BoolWithAggregatesFilter<"Chapters"> | boolean
    volumeId?: IntWithAggregatesFilter<"Chapters"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Chapters"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Chapters"> | Date | string
  }

  export type RolesWhereInput = {
    AND?: RolesWhereInput | RolesWhereInput[]
    OR?: RolesWhereInput[]
    NOT?: RolesWhereInput | RolesWhereInput[]
    id?: IntFilter<"Roles"> | number
    title?: StringFilter<"Roles"> | string
    description?: StringFilter<"Roles"> | string
    users?: UsersListRelationFilter
  }

  export type RolesOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    users?: UsersOrderByRelationAggregateInput
    _relevance?: RolesOrderByRelevanceInput
  }

  export type RolesWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    title?: string
    AND?: RolesWhereInput | RolesWhereInput[]
    OR?: RolesWhereInput[]
    NOT?: RolesWhereInput | RolesWhereInput[]
    description?: StringFilter<"Roles"> | string
    users?: UsersListRelationFilter
  }, "id" | "title">

  export type RolesOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    _count?: RolesCountOrderByAggregateInput
    _avg?: RolesAvgOrderByAggregateInput
    _max?: RolesMaxOrderByAggregateInput
    _min?: RolesMinOrderByAggregateInput
    _sum?: RolesSumOrderByAggregateInput
  }

  export type RolesScalarWhereWithAggregatesInput = {
    AND?: RolesScalarWhereWithAggregatesInput | RolesScalarWhereWithAggregatesInput[]
    OR?: RolesScalarWhereWithAggregatesInput[]
    NOT?: RolesScalarWhereWithAggregatesInput | RolesScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Roles"> | number
    title?: StringWithAggregatesFilter<"Roles"> | string
    description?: StringWithAggregatesFilter<"Roles"> | string
  }

  export type UsersWhereInput = {
    AND?: UsersWhereInput | UsersWhereInput[]
    OR?: UsersWhereInput[]
    NOT?: UsersWhereInput | UsersWhereInput[]
    id?: IntFilter<"Users"> | number
    name?: StringFilter<"Users"> | string
    email?: StringFilter<"Users"> | string
    password?: StringFilter<"Users"> | string
    description?: StringFilter<"Users"> | string
    createdAt?: DateTimeFilter<"Users"> | Date | string
    updatedAt?: DateTimeFilter<"Users"> | Date | string
    isDisabled?: BoolFilter<"Users"> | boolean
    comics?: ComicsListRelationFilter
    userRole?: RolesListRelationFilter
    favorites?: FavoritesListRelationFilter
    rates?: RatesListRelationFilter
    errors?: ErrorsListRelationFilter
    views?: ViewsListRelationFilter
    coments?: CommentsListRelationFilter
    notifications?: NotificationsListRelationFilter
    wallets?: XOR<WalletsNullableScalarRelationFilter, WalletsWhereInput> | null
    unlock_comic?: Unlock_comicListRelationFilter
    unlock_volume?: Unlock_volumeListRelationFilter
    unlock_chapter?: Unlock_chapterListRelationFilter
  }

  export type UsersOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    password?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isDisabled?: SortOrder
    comics?: ComicsOrderByRelationAggregateInput
    userRole?: RolesOrderByRelationAggregateInput
    favorites?: FavoritesOrderByRelationAggregateInput
    rates?: RatesOrderByRelationAggregateInput
    errors?: ErrorsOrderByRelationAggregateInput
    views?: ViewsOrderByRelationAggregateInput
    coments?: CommentsOrderByRelationAggregateInput
    notifications?: NotificationsOrderByRelationAggregateInput
    wallets?: WalletsOrderByWithRelationInput
    unlock_comic?: Unlock_comicOrderByRelationAggregateInput
    unlock_volume?: Unlock_volumeOrderByRelationAggregateInput
    unlock_chapter?: Unlock_chapterOrderByRelationAggregateInput
    _relevance?: UsersOrderByRelevanceInput
  }

  export type UsersWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    name?: string
    email?: string
    AND?: UsersWhereInput | UsersWhereInput[]
    OR?: UsersWhereInput[]
    NOT?: UsersWhereInput | UsersWhereInput[]
    password?: StringFilter<"Users"> | string
    description?: StringFilter<"Users"> | string
    createdAt?: DateTimeFilter<"Users"> | Date | string
    updatedAt?: DateTimeFilter<"Users"> | Date | string
    isDisabled?: BoolFilter<"Users"> | boolean
    comics?: ComicsListRelationFilter
    userRole?: RolesListRelationFilter
    favorites?: FavoritesListRelationFilter
    rates?: RatesListRelationFilter
    errors?: ErrorsListRelationFilter
    views?: ViewsListRelationFilter
    coments?: CommentsListRelationFilter
    notifications?: NotificationsListRelationFilter
    wallets?: XOR<WalletsNullableScalarRelationFilter, WalletsWhereInput> | null
    unlock_comic?: Unlock_comicListRelationFilter
    unlock_volume?: Unlock_volumeListRelationFilter
    unlock_chapter?: Unlock_chapterListRelationFilter
  }, "id" | "name" | "email">

  export type UsersOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    password?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isDisabled?: SortOrder
    _count?: UsersCountOrderByAggregateInput
    _avg?: UsersAvgOrderByAggregateInput
    _max?: UsersMaxOrderByAggregateInput
    _min?: UsersMinOrderByAggregateInput
    _sum?: UsersSumOrderByAggregateInput
  }

  export type UsersScalarWhereWithAggregatesInput = {
    AND?: UsersScalarWhereWithAggregatesInput | UsersScalarWhereWithAggregatesInput[]
    OR?: UsersScalarWhereWithAggregatesInput[]
    NOT?: UsersScalarWhereWithAggregatesInput | UsersScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Users"> | number
    name?: StringWithAggregatesFilter<"Users"> | string
    email?: StringWithAggregatesFilter<"Users"> | string
    password?: StringWithAggregatesFilter<"Users"> | string
    description?: StringWithAggregatesFilter<"Users"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Users"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Users"> | Date | string
    isDisabled?: BoolWithAggregatesFilter<"Users"> | boolean
  }

  export type FavoritesWhereInput = {
    AND?: FavoritesWhereInput | FavoritesWhereInput[]
    OR?: FavoritesWhereInput[]
    NOT?: FavoritesWhereInput | FavoritesWhereInput[]
    userId?: IntFilter<"Favorites"> | number
    comicId?: IntFilter<"Favorites"> | number
    addedAt?: DateTimeFilter<"Favorites"> | Date | string
    user?: XOR<UsersScalarRelationFilter, UsersWhereInput>
    comic?: XOR<ComicsScalarRelationFilter, ComicsWhereInput>
  }

  export type FavoritesOrderByWithRelationInput = {
    userId?: SortOrder
    comicId?: SortOrder
    addedAt?: SortOrder
    user?: UsersOrderByWithRelationInput
    comic?: ComicsOrderByWithRelationInput
  }

  export type FavoritesWhereUniqueInput = Prisma.AtLeast<{
    userId_comicId?: FavoritesUserIdComicIdCompoundUniqueInput
    AND?: FavoritesWhereInput | FavoritesWhereInput[]
    OR?: FavoritesWhereInput[]
    NOT?: FavoritesWhereInput | FavoritesWhereInput[]
    userId?: IntFilter<"Favorites"> | number
    comicId?: IntFilter<"Favorites"> | number
    addedAt?: DateTimeFilter<"Favorites"> | Date | string
    user?: XOR<UsersScalarRelationFilter, UsersWhereInput>
    comic?: XOR<ComicsScalarRelationFilter, ComicsWhereInput>
  }, "userId_comicId">

  export type FavoritesOrderByWithAggregationInput = {
    userId?: SortOrder
    comicId?: SortOrder
    addedAt?: SortOrder
    _count?: FavoritesCountOrderByAggregateInput
    _avg?: FavoritesAvgOrderByAggregateInput
    _max?: FavoritesMaxOrderByAggregateInput
    _min?: FavoritesMinOrderByAggregateInput
    _sum?: FavoritesSumOrderByAggregateInput
  }

  export type FavoritesScalarWhereWithAggregatesInput = {
    AND?: FavoritesScalarWhereWithAggregatesInput | FavoritesScalarWhereWithAggregatesInput[]
    OR?: FavoritesScalarWhereWithAggregatesInput[]
    NOT?: FavoritesScalarWhereWithAggregatesInput | FavoritesScalarWhereWithAggregatesInput[]
    userId?: IntWithAggregatesFilter<"Favorites"> | number
    comicId?: IntWithAggregatesFilter<"Favorites"> | number
    addedAt?: DateTimeWithAggregatesFilter<"Favorites"> | Date | string
  }

  export type RatesWhereInput = {
    AND?: RatesWhereInput | RatesWhereInput[]
    OR?: RatesWhereInput[]
    NOT?: RatesWhereInput | RatesWhereInput[]
    userId?: IntFilter<"Rates"> | number
    comicId?: IntFilter<"Rates"> | number
    score?: FloatFilter<"Rates"> | number
    content?: StringFilter<"Rates"> | string
    createdAt?: DateTimeFilter<"Rates"> | Date | string
    user?: XOR<UsersScalarRelationFilter, UsersWhereInput>
    comic?: XOR<ComicsScalarRelationFilter, ComicsWhereInput>
  }

  export type RatesOrderByWithRelationInput = {
    userId?: SortOrder
    comicId?: SortOrder
    score?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    user?: UsersOrderByWithRelationInput
    comic?: ComicsOrderByWithRelationInput
    _relevance?: RatesOrderByRelevanceInput
  }

  export type RatesWhereUniqueInput = Prisma.AtLeast<{
    userId_comicId?: RatesUserIdComicIdCompoundUniqueInput
    AND?: RatesWhereInput | RatesWhereInput[]
    OR?: RatesWhereInput[]
    NOT?: RatesWhereInput | RatesWhereInput[]
    userId?: IntFilter<"Rates"> | number
    comicId?: IntFilter<"Rates"> | number
    score?: FloatFilter<"Rates"> | number
    content?: StringFilter<"Rates"> | string
    createdAt?: DateTimeFilter<"Rates"> | Date | string
    user?: XOR<UsersScalarRelationFilter, UsersWhereInput>
    comic?: XOR<ComicsScalarRelationFilter, ComicsWhereInput>
  }, "userId_comicId">

  export type RatesOrderByWithAggregationInput = {
    userId?: SortOrder
    comicId?: SortOrder
    score?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    _count?: RatesCountOrderByAggregateInput
    _avg?: RatesAvgOrderByAggregateInput
    _max?: RatesMaxOrderByAggregateInput
    _min?: RatesMinOrderByAggregateInput
    _sum?: RatesSumOrderByAggregateInput
  }

  export type RatesScalarWhereWithAggregatesInput = {
    AND?: RatesScalarWhereWithAggregatesInput | RatesScalarWhereWithAggregatesInput[]
    OR?: RatesScalarWhereWithAggregatesInput[]
    NOT?: RatesScalarWhereWithAggregatesInput | RatesScalarWhereWithAggregatesInput[]
    userId?: IntWithAggregatesFilter<"Rates"> | number
    comicId?: IntWithAggregatesFilter<"Rates"> | number
    score?: FloatWithAggregatesFilter<"Rates"> | number
    content?: StringWithAggregatesFilter<"Rates"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Rates"> | Date | string
  }

  export type ErrorsWhereInput = {
    AND?: ErrorsWhereInput | ErrorsWhereInput[]
    OR?: ErrorsWhereInput[]
    NOT?: ErrorsWhereInput | ErrorsWhereInput[]
    userId?: IntFilter<"Errors"> | number
    chapterId?: IntFilter<"Errors"> | number
    content?: StringFilter<"Errors"> | string
    status?: StringFilter<"Errors"> | string
    createdAt?: DateTimeFilter<"Errors"> | Date | string
    updatedAt?: DateTimeFilter<"Errors"> | Date | string
    user?: XOR<UsersScalarRelationFilter, UsersWhereInput>
    chapter?: XOR<ChaptersScalarRelationFilter, ChaptersWhereInput>
  }

  export type ErrorsOrderByWithRelationInput = {
    userId?: SortOrder
    chapterId?: SortOrder
    content?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UsersOrderByWithRelationInput
    chapter?: ChaptersOrderByWithRelationInput
    _relevance?: ErrorsOrderByRelevanceInput
  }

  export type ErrorsWhereUniqueInput = Prisma.AtLeast<{
    userId_chapterId?: ErrorsUserIdChapterIdCompoundUniqueInput
    AND?: ErrorsWhereInput | ErrorsWhereInput[]
    OR?: ErrorsWhereInput[]
    NOT?: ErrorsWhereInput | ErrorsWhereInput[]
    userId?: IntFilter<"Errors"> | number
    chapterId?: IntFilter<"Errors"> | number
    content?: StringFilter<"Errors"> | string
    status?: StringFilter<"Errors"> | string
    createdAt?: DateTimeFilter<"Errors"> | Date | string
    updatedAt?: DateTimeFilter<"Errors"> | Date | string
    user?: XOR<UsersScalarRelationFilter, UsersWhereInput>
    chapter?: XOR<ChaptersScalarRelationFilter, ChaptersWhereInput>
  }, "userId_chapterId">

  export type ErrorsOrderByWithAggregationInput = {
    userId?: SortOrder
    chapterId?: SortOrder
    content?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ErrorsCountOrderByAggregateInput
    _avg?: ErrorsAvgOrderByAggregateInput
    _max?: ErrorsMaxOrderByAggregateInput
    _min?: ErrorsMinOrderByAggregateInput
    _sum?: ErrorsSumOrderByAggregateInput
  }

  export type ErrorsScalarWhereWithAggregatesInput = {
    AND?: ErrorsScalarWhereWithAggregatesInput | ErrorsScalarWhereWithAggregatesInput[]
    OR?: ErrorsScalarWhereWithAggregatesInput[]
    NOT?: ErrorsScalarWhereWithAggregatesInput | ErrorsScalarWhereWithAggregatesInput[]
    userId?: IntWithAggregatesFilter<"Errors"> | number
    chapterId?: IntWithAggregatesFilter<"Errors"> | number
    content?: StringWithAggregatesFilter<"Errors"> | string
    status?: StringWithAggregatesFilter<"Errors"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Errors"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Errors"> | Date | string
  }

  export type ViewsWhereInput = {
    AND?: ViewsWhereInput | ViewsWhereInput[]
    OR?: ViewsWhereInput[]
    NOT?: ViewsWhereInput | ViewsWhereInput[]
    userId?: IntFilter<"Views"> | number
    comicId?: IntFilter<"Views"> | number
    chapterId?: IntFilter<"Views"> | number
    lastedAt?: DateTimeFilter<"Views"> | Date | string
    user?: XOR<UsersScalarRelationFilter, UsersWhereInput>
    comic?: XOR<ComicsScalarRelationFilter, ComicsWhereInput>
    chapter?: XOR<ChaptersScalarRelationFilter, ChaptersWhereInput>
  }

  export type ViewsOrderByWithRelationInput = {
    userId?: SortOrder
    comicId?: SortOrder
    chapterId?: SortOrder
    lastedAt?: SortOrder
    user?: UsersOrderByWithRelationInput
    comic?: ComicsOrderByWithRelationInput
    chapter?: ChaptersOrderByWithRelationInput
  }

  export type ViewsWhereUniqueInput = Prisma.AtLeast<{
    userId_comicId?: ViewsUserIdComicIdCompoundUniqueInput
    AND?: ViewsWhereInput | ViewsWhereInput[]
    OR?: ViewsWhereInput[]
    NOT?: ViewsWhereInput | ViewsWhereInput[]
    userId?: IntFilter<"Views"> | number
    comicId?: IntFilter<"Views"> | number
    chapterId?: IntFilter<"Views"> | number
    lastedAt?: DateTimeFilter<"Views"> | Date | string
    user?: XOR<UsersScalarRelationFilter, UsersWhereInput>
    comic?: XOR<ComicsScalarRelationFilter, ComicsWhereInput>
    chapter?: XOR<ChaptersScalarRelationFilter, ChaptersWhereInput>
  }, "userId_comicId">

  export type ViewsOrderByWithAggregationInput = {
    userId?: SortOrder
    comicId?: SortOrder
    chapterId?: SortOrder
    lastedAt?: SortOrder
    _count?: ViewsCountOrderByAggregateInput
    _avg?: ViewsAvgOrderByAggregateInput
    _max?: ViewsMaxOrderByAggregateInput
    _min?: ViewsMinOrderByAggregateInput
    _sum?: ViewsSumOrderByAggregateInput
  }

  export type ViewsScalarWhereWithAggregatesInput = {
    AND?: ViewsScalarWhereWithAggregatesInput | ViewsScalarWhereWithAggregatesInput[]
    OR?: ViewsScalarWhereWithAggregatesInput[]
    NOT?: ViewsScalarWhereWithAggregatesInput | ViewsScalarWhereWithAggregatesInput[]
    userId?: IntWithAggregatesFilter<"Views"> | number
    comicId?: IntWithAggregatesFilter<"Views"> | number
    chapterId?: IntWithAggregatesFilter<"Views"> | number
    lastedAt?: DateTimeWithAggregatesFilter<"Views"> | Date | string
  }

  export type CommentsWhereInput = {
    AND?: CommentsWhereInput | CommentsWhereInput[]
    OR?: CommentsWhereInput[]
    NOT?: CommentsWhereInput | CommentsWhereInput[]
    id?: IntFilter<"Comments"> | number
    content?: StringFilter<"Comments"> | string
    userId?: IntFilter<"Comments"> | number
    chapterId?: IntNullableFilter<"Comments"> | number | null
    comicId?: IntFilter<"Comments"> | number
    createdAt?: DateTimeFilter<"Comments"> | Date | string
    user?: XOR<UsersScalarRelationFilter, UsersWhereInput>
    chapter?: XOR<ChaptersNullableScalarRelationFilter, ChaptersWhereInput> | null
    comic?: XOR<ComicsScalarRelationFilter, ComicsWhereInput>
    notification?: NotificationsListRelationFilter
  }

  export type CommentsOrderByWithRelationInput = {
    id?: SortOrder
    content?: SortOrder
    userId?: SortOrder
    chapterId?: SortOrderInput | SortOrder
    comicId?: SortOrder
    createdAt?: SortOrder
    user?: UsersOrderByWithRelationInput
    chapter?: ChaptersOrderByWithRelationInput
    comic?: ComicsOrderByWithRelationInput
    notification?: NotificationsOrderByRelationAggregateInput
    _relevance?: CommentsOrderByRelevanceInput
  }

  export type CommentsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: CommentsWhereInput | CommentsWhereInput[]
    OR?: CommentsWhereInput[]
    NOT?: CommentsWhereInput | CommentsWhereInput[]
    content?: StringFilter<"Comments"> | string
    userId?: IntFilter<"Comments"> | number
    chapterId?: IntNullableFilter<"Comments"> | number | null
    comicId?: IntFilter<"Comments"> | number
    createdAt?: DateTimeFilter<"Comments"> | Date | string
    user?: XOR<UsersScalarRelationFilter, UsersWhereInput>
    chapter?: XOR<ChaptersNullableScalarRelationFilter, ChaptersWhereInput> | null
    comic?: XOR<ComicsScalarRelationFilter, ComicsWhereInput>
    notification?: NotificationsListRelationFilter
  }, "id">

  export type CommentsOrderByWithAggregationInput = {
    id?: SortOrder
    content?: SortOrder
    userId?: SortOrder
    chapterId?: SortOrderInput | SortOrder
    comicId?: SortOrder
    createdAt?: SortOrder
    _count?: CommentsCountOrderByAggregateInput
    _avg?: CommentsAvgOrderByAggregateInput
    _max?: CommentsMaxOrderByAggregateInput
    _min?: CommentsMinOrderByAggregateInput
    _sum?: CommentsSumOrderByAggregateInput
  }

  export type CommentsScalarWhereWithAggregatesInput = {
    AND?: CommentsScalarWhereWithAggregatesInput | CommentsScalarWhereWithAggregatesInput[]
    OR?: CommentsScalarWhereWithAggregatesInput[]
    NOT?: CommentsScalarWhereWithAggregatesInput | CommentsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Comments"> | number
    content?: StringWithAggregatesFilter<"Comments"> | string
    userId?: IntWithAggregatesFilter<"Comments"> | number
    chapterId?: IntNullableWithAggregatesFilter<"Comments"> | number | null
    comicId?: IntWithAggregatesFilter<"Comments"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Comments"> | Date | string
  }

  export type NotificationsWhereInput = {
    AND?: NotificationsWhereInput | NotificationsWhereInput[]
    OR?: NotificationsWhereInput[]
    NOT?: NotificationsWhereInput | NotificationsWhereInput[]
    id?: IntFilter<"Notifications"> | number
    userId?: IntFilter<"Notifications"> | number
    commentId?: IntNullableFilter<"Notifications"> | number | null
    content?: StringFilter<"Notifications"> | string
    isRead?: BoolFilter<"Notifications"> | boolean
    createdAt?: DateTimeFilter<"Notifications"> | Date | string
    user?: XOR<UsersScalarRelationFilter, UsersWhereInput>
    comment?: XOR<CommentsNullableScalarRelationFilter, CommentsWhereInput> | null
  }

  export type NotificationsOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    commentId?: SortOrderInput | SortOrder
    content?: SortOrder
    isRead?: SortOrder
    createdAt?: SortOrder
    user?: UsersOrderByWithRelationInput
    comment?: CommentsOrderByWithRelationInput
    _relevance?: NotificationsOrderByRelevanceInput
  }

  export type NotificationsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: NotificationsWhereInput | NotificationsWhereInput[]
    OR?: NotificationsWhereInput[]
    NOT?: NotificationsWhereInput | NotificationsWhereInput[]
    userId?: IntFilter<"Notifications"> | number
    commentId?: IntNullableFilter<"Notifications"> | number | null
    content?: StringFilter<"Notifications"> | string
    isRead?: BoolFilter<"Notifications"> | boolean
    createdAt?: DateTimeFilter<"Notifications"> | Date | string
    user?: XOR<UsersScalarRelationFilter, UsersWhereInput>
    comment?: XOR<CommentsNullableScalarRelationFilter, CommentsWhereInput> | null
  }, "id">

  export type NotificationsOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    commentId?: SortOrderInput | SortOrder
    content?: SortOrder
    isRead?: SortOrder
    createdAt?: SortOrder
    _count?: NotificationsCountOrderByAggregateInput
    _avg?: NotificationsAvgOrderByAggregateInput
    _max?: NotificationsMaxOrderByAggregateInput
    _min?: NotificationsMinOrderByAggregateInput
    _sum?: NotificationsSumOrderByAggregateInput
  }

  export type NotificationsScalarWhereWithAggregatesInput = {
    AND?: NotificationsScalarWhereWithAggregatesInput | NotificationsScalarWhereWithAggregatesInput[]
    OR?: NotificationsScalarWhereWithAggregatesInput[]
    NOT?: NotificationsScalarWhereWithAggregatesInput | NotificationsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Notifications"> | number
    userId?: IntWithAggregatesFilter<"Notifications"> | number
    commentId?: IntNullableWithAggregatesFilter<"Notifications"> | number | null
    content?: StringWithAggregatesFilter<"Notifications"> | string
    isRead?: BoolWithAggregatesFilter<"Notifications"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Notifications"> | Date | string
  }

  export type WalletsWhereInput = {
    AND?: WalletsWhereInput | WalletsWhereInput[]
    OR?: WalletsWhereInput[]
    NOT?: WalletsWhereInput | WalletsWhereInput[]
    id?: IntFilter<"Wallets"> | number
    userId?: IntFilter<"Wallets"> | number
    value?: DecimalFilter<"Wallets"> | Decimal | DecimalJsLike | number | string
    updatedAt?: DateTimeFilter<"Wallets"> | Date | string
    user?: XOR<UsersScalarRelationFilter, UsersWhereInput>
    transactions?: TransactionsListRelationFilter
  }

  export type WalletsOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    value?: SortOrder
    updatedAt?: SortOrder
    user?: UsersOrderByWithRelationInput
    transactions?: TransactionsOrderByRelationAggregateInput
  }

  export type WalletsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    userId?: number
    AND?: WalletsWhereInput | WalletsWhereInput[]
    OR?: WalletsWhereInput[]
    NOT?: WalletsWhereInput | WalletsWhereInput[]
    value?: DecimalFilter<"Wallets"> | Decimal | DecimalJsLike | number | string
    updatedAt?: DateTimeFilter<"Wallets"> | Date | string
    user?: XOR<UsersScalarRelationFilter, UsersWhereInput>
    transactions?: TransactionsListRelationFilter
  }, "id" | "userId">

  export type WalletsOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    value?: SortOrder
    updatedAt?: SortOrder
    _count?: WalletsCountOrderByAggregateInput
    _avg?: WalletsAvgOrderByAggregateInput
    _max?: WalletsMaxOrderByAggregateInput
    _min?: WalletsMinOrderByAggregateInput
    _sum?: WalletsSumOrderByAggregateInput
  }

  export type WalletsScalarWhereWithAggregatesInput = {
    AND?: WalletsScalarWhereWithAggregatesInput | WalletsScalarWhereWithAggregatesInput[]
    OR?: WalletsScalarWhereWithAggregatesInput[]
    NOT?: WalletsScalarWhereWithAggregatesInput | WalletsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Wallets"> | number
    userId?: IntWithAggregatesFilter<"Wallets"> | number
    value?: DecimalWithAggregatesFilter<"Wallets"> | Decimal | DecimalJsLike | number | string
    updatedAt?: DateTimeWithAggregatesFilter<"Wallets"> | Date | string
  }

  export type TransactionsWhereInput = {
    AND?: TransactionsWhereInput | TransactionsWhereInput[]
    OR?: TransactionsWhereInput[]
    NOT?: TransactionsWhereInput | TransactionsWhereInput[]
    id?: IntFilter<"Transactions"> | number
    walletId?: IntFilter<"Transactions"> | number
    amount?: DecimalFilter<"Transactions"> | Decimal | DecimalJsLike | number | string
    description?: StringFilter<"Transactions"> | string
    status?: StringFilter<"Transactions"> | string
    createdAt?: DateTimeFilter<"Transactions"> | Date | string
    wallet?: XOR<WalletsScalarRelationFilter, WalletsWhereInput>
    unlock_comic?: Unlock_comicListRelationFilter
    unlock_volume?: Unlock_volumeListRelationFilter
    unlock_chapter?: Unlock_chapterListRelationFilter
  }

  export type TransactionsOrderByWithRelationInput = {
    id?: SortOrder
    walletId?: SortOrder
    amount?: SortOrder
    description?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    wallet?: WalletsOrderByWithRelationInput
    unlock_comic?: Unlock_comicOrderByRelationAggregateInput
    unlock_volume?: Unlock_volumeOrderByRelationAggregateInput
    unlock_chapter?: Unlock_chapterOrderByRelationAggregateInput
    _relevance?: TransactionsOrderByRelevanceInput
  }

  export type TransactionsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: TransactionsWhereInput | TransactionsWhereInput[]
    OR?: TransactionsWhereInput[]
    NOT?: TransactionsWhereInput | TransactionsWhereInput[]
    walletId?: IntFilter<"Transactions"> | number
    amount?: DecimalFilter<"Transactions"> | Decimal | DecimalJsLike | number | string
    description?: StringFilter<"Transactions"> | string
    status?: StringFilter<"Transactions"> | string
    createdAt?: DateTimeFilter<"Transactions"> | Date | string
    wallet?: XOR<WalletsScalarRelationFilter, WalletsWhereInput>
    unlock_comic?: Unlock_comicListRelationFilter
    unlock_volume?: Unlock_volumeListRelationFilter
    unlock_chapter?: Unlock_chapterListRelationFilter
  }, "id">

  export type TransactionsOrderByWithAggregationInput = {
    id?: SortOrder
    walletId?: SortOrder
    amount?: SortOrder
    description?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    _count?: TransactionsCountOrderByAggregateInput
    _avg?: TransactionsAvgOrderByAggregateInput
    _max?: TransactionsMaxOrderByAggregateInput
    _min?: TransactionsMinOrderByAggregateInput
    _sum?: TransactionsSumOrderByAggregateInput
  }

  export type TransactionsScalarWhereWithAggregatesInput = {
    AND?: TransactionsScalarWhereWithAggregatesInput | TransactionsScalarWhereWithAggregatesInput[]
    OR?: TransactionsScalarWhereWithAggregatesInput[]
    NOT?: TransactionsScalarWhereWithAggregatesInput | TransactionsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Transactions"> | number
    walletId?: IntWithAggregatesFilter<"Transactions"> | number
    amount?: DecimalWithAggregatesFilter<"Transactions"> | Decimal | DecimalJsLike | number | string
    description?: StringWithAggregatesFilter<"Transactions"> | string
    status?: StringWithAggregatesFilter<"Transactions"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Transactions"> | Date | string
  }

  export type Unlock_comicWhereInput = {
    AND?: Unlock_comicWhereInput | Unlock_comicWhereInput[]
    OR?: Unlock_comicWhereInput[]
    NOT?: Unlock_comicWhereInput | Unlock_comicWhereInput[]
    userId?: IntFilter<"Unlock_comic"> | number
    comicId?: IntFilter<"Unlock_comic"> | number
    transactionId?: IntFilter<"Unlock_comic"> | number
    createdAt?: DateTimeFilter<"Unlock_comic"> | Date | string
    user?: XOR<UsersScalarRelationFilter, UsersWhereInput>
    comic?: XOR<ComicsScalarRelationFilter, ComicsWhereInput>
    transaction?: XOR<TransactionsScalarRelationFilter, TransactionsWhereInput>
  }

  export type Unlock_comicOrderByWithRelationInput = {
    userId?: SortOrder
    comicId?: SortOrder
    transactionId?: SortOrder
    createdAt?: SortOrder
    user?: UsersOrderByWithRelationInput
    comic?: ComicsOrderByWithRelationInput
    transaction?: TransactionsOrderByWithRelationInput
  }

  export type Unlock_comicWhereUniqueInput = Prisma.AtLeast<{
    userId_comicId_transactionId?: Unlock_comicUserIdComicIdTransactionIdCompoundUniqueInput
    AND?: Unlock_comicWhereInput | Unlock_comicWhereInput[]
    OR?: Unlock_comicWhereInput[]
    NOT?: Unlock_comicWhereInput | Unlock_comicWhereInput[]
    userId?: IntFilter<"Unlock_comic"> | number
    comicId?: IntFilter<"Unlock_comic"> | number
    transactionId?: IntFilter<"Unlock_comic"> | number
    createdAt?: DateTimeFilter<"Unlock_comic"> | Date | string
    user?: XOR<UsersScalarRelationFilter, UsersWhereInput>
    comic?: XOR<ComicsScalarRelationFilter, ComicsWhereInput>
    transaction?: XOR<TransactionsScalarRelationFilter, TransactionsWhereInput>
  }, "userId_comicId_transactionId">

  export type Unlock_comicOrderByWithAggregationInput = {
    userId?: SortOrder
    comicId?: SortOrder
    transactionId?: SortOrder
    createdAt?: SortOrder
    _count?: Unlock_comicCountOrderByAggregateInput
    _avg?: Unlock_comicAvgOrderByAggregateInput
    _max?: Unlock_comicMaxOrderByAggregateInput
    _min?: Unlock_comicMinOrderByAggregateInput
    _sum?: Unlock_comicSumOrderByAggregateInput
  }

  export type Unlock_comicScalarWhereWithAggregatesInput = {
    AND?: Unlock_comicScalarWhereWithAggregatesInput | Unlock_comicScalarWhereWithAggregatesInput[]
    OR?: Unlock_comicScalarWhereWithAggregatesInput[]
    NOT?: Unlock_comicScalarWhereWithAggregatesInput | Unlock_comicScalarWhereWithAggregatesInput[]
    userId?: IntWithAggregatesFilter<"Unlock_comic"> | number
    comicId?: IntWithAggregatesFilter<"Unlock_comic"> | number
    transactionId?: IntWithAggregatesFilter<"Unlock_comic"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Unlock_comic"> | Date | string
  }

  export type Unlock_volumeWhereInput = {
    AND?: Unlock_volumeWhereInput | Unlock_volumeWhereInput[]
    OR?: Unlock_volumeWhereInput[]
    NOT?: Unlock_volumeWhereInput | Unlock_volumeWhereInput[]
    userId?: IntFilter<"Unlock_volume"> | number
    volumeId?: IntFilter<"Unlock_volume"> | number
    transactionId?: IntFilter<"Unlock_volume"> | number
    createdAt?: DateTimeFilter<"Unlock_volume"> | Date | string
    user?: XOR<UsersScalarRelationFilter, UsersWhereInput>
    volume?: XOR<VolumesScalarRelationFilter, VolumesWhereInput>
    transaction?: XOR<TransactionsScalarRelationFilter, TransactionsWhereInput>
  }

  export type Unlock_volumeOrderByWithRelationInput = {
    userId?: SortOrder
    volumeId?: SortOrder
    transactionId?: SortOrder
    createdAt?: SortOrder
    user?: UsersOrderByWithRelationInput
    volume?: VolumesOrderByWithRelationInput
    transaction?: TransactionsOrderByWithRelationInput
  }

  export type Unlock_volumeWhereUniqueInput = Prisma.AtLeast<{
    userId_volumeId_transactionId?: Unlock_volumeUserIdVolumeIdTransactionIdCompoundUniqueInput
    AND?: Unlock_volumeWhereInput | Unlock_volumeWhereInput[]
    OR?: Unlock_volumeWhereInput[]
    NOT?: Unlock_volumeWhereInput | Unlock_volumeWhereInput[]
    userId?: IntFilter<"Unlock_volume"> | number
    volumeId?: IntFilter<"Unlock_volume"> | number
    transactionId?: IntFilter<"Unlock_volume"> | number
    createdAt?: DateTimeFilter<"Unlock_volume"> | Date | string
    user?: XOR<UsersScalarRelationFilter, UsersWhereInput>
    volume?: XOR<VolumesScalarRelationFilter, VolumesWhereInput>
    transaction?: XOR<TransactionsScalarRelationFilter, TransactionsWhereInput>
  }, "userId_volumeId_transactionId">

  export type Unlock_volumeOrderByWithAggregationInput = {
    userId?: SortOrder
    volumeId?: SortOrder
    transactionId?: SortOrder
    createdAt?: SortOrder
    _count?: Unlock_volumeCountOrderByAggregateInput
    _avg?: Unlock_volumeAvgOrderByAggregateInput
    _max?: Unlock_volumeMaxOrderByAggregateInput
    _min?: Unlock_volumeMinOrderByAggregateInput
    _sum?: Unlock_volumeSumOrderByAggregateInput
  }

  export type Unlock_volumeScalarWhereWithAggregatesInput = {
    AND?: Unlock_volumeScalarWhereWithAggregatesInput | Unlock_volumeScalarWhereWithAggregatesInput[]
    OR?: Unlock_volumeScalarWhereWithAggregatesInput[]
    NOT?: Unlock_volumeScalarWhereWithAggregatesInput | Unlock_volumeScalarWhereWithAggregatesInput[]
    userId?: IntWithAggregatesFilter<"Unlock_volume"> | number
    volumeId?: IntWithAggregatesFilter<"Unlock_volume"> | number
    transactionId?: IntWithAggregatesFilter<"Unlock_volume"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Unlock_volume"> | Date | string
  }

  export type Unlock_chapterWhereInput = {
    AND?: Unlock_chapterWhereInput | Unlock_chapterWhereInput[]
    OR?: Unlock_chapterWhereInput[]
    NOT?: Unlock_chapterWhereInput | Unlock_chapterWhereInput[]
    userId?: IntFilter<"Unlock_chapter"> | number
    chapterId?: IntFilter<"Unlock_chapter"> | number
    transactionId?: IntFilter<"Unlock_chapter"> | number
    createdAt?: DateTimeFilter<"Unlock_chapter"> | Date | string
    user?: XOR<UsersScalarRelationFilter, UsersWhereInput>
    chapter?: XOR<ChaptersScalarRelationFilter, ChaptersWhereInput>
    transaction?: XOR<TransactionsScalarRelationFilter, TransactionsWhereInput>
  }

  export type Unlock_chapterOrderByWithRelationInput = {
    userId?: SortOrder
    chapterId?: SortOrder
    transactionId?: SortOrder
    createdAt?: SortOrder
    user?: UsersOrderByWithRelationInput
    chapter?: ChaptersOrderByWithRelationInput
    transaction?: TransactionsOrderByWithRelationInput
  }

  export type Unlock_chapterWhereUniqueInput = Prisma.AtLeast<{
    userId_chapterId_transactionId?: Unlock_chapterUserIdChapterIdTransactionIdCompoundUniqueInput
    AND?: Unlock_chapterWhereInput | Unlock_chapterWhereInput[]
    OR?: Unlock_chapterWhereInput[]
    NOT?: Unlock_chapterWhereInput | Unlock_chapterWhereInput[]
    userId?: IntFilter<"Unlock_chapter"> | number
    chapterId?: IntFilter<"Unlock_chapter"> | number
    transactionId?: IntFilter<"Unlock_chapter"> | number
    createdAt?: DateTimeFilter<"Unlock_chapter"> | Date | string
    user?: XOR<UsersScalarRelationFilter, UsersWhereInput>
    chapter?: XOR<ChaptersScalarRelationFilter, ChaptersWhereInput>
    transaction?: XOR<TransactionsScalarRelationFilter, TransactionsWhereInput>
  }, "userId_chapterId_transactionId">

  export type Unlock_chapterOrderByWithAggregationInput = {
    userId?: SortOrder
    chapterId?: SortOrder
    transactionId?: SortOrder
    createdAt?: SortOrder
    _count?: Unlock_chapterCountOrderByAggregateInput
    _avg?: Unlock_chapterAvgOrderByAggregateInput
    _max?: Unlock_chapterMaxOrderByAggregateInput
    _min?: Unlock_chapterMinOrderByAggregateInput
    _sum?: Unlock_chapterSumOrderByAggregateInput
  }

  export type Unlock_chapterScalarWhereWithAggregatesInput = {
    AND?: Unlock_chapterScalarWhereWithAggregatesInput | Unlock_chapterScalarWhereWithAggregatesInput[]
    OR?: Unlock_chapterScalarWhereWithAggregatesInput[]
    NOT?: Unlock_chapterScalarWhereWithAggregatesInput | Unlock_chapterScalarWhereWithAggregatesInput[]
    userId?: IntWithAggregatesFilter<"Unlock_chapter"> | number
    chapterId?: IntWithAggregatesFilter<"Unlock_chapter"> | number
    transactionId?: IntWithAggregatesFilter<"Unlock_chapter"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Unlock_chapter"> | Date | string
  }

  export type CategoriesCreateInput = {
    title: string
    comics?: ComicsCreateNestedManyWithoutCategoriesInput
  }

  export type CategoriesUncheckedCreateInput = {
    id?: number
    title: string
    comics?: ComicsUncheckedCreateNestedManyWithoutCategoriesInput
  }

  export type CategoriesUpdateInput = {
    title?: StringFieldUpdateOperationsInput | string
    comics?: ComicsUpdateManyWithoutCategoriesNestedInput
  }

  export type CategoriesUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    comics?: ComicsUncheckedUpdateManyWithoutCategoriesNestedInput
  }

  export type CategoriesCreateManyInput = {
    id?: number
    title: string
  }

  export type CategoriesUpdateManyMutationInput = {
    title?: StringFieldUpdateOperationsInput | string
  }

  export type CategoriesUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
  }

  export type AuthorsCreateInput = {
    name: string
    description: string
    keywords: string
    comics?: ComicsCreateNestedManyWithoutAuthorsInput
  }

  export type AuthorsUncheckedCreateInput = {
    id?: number
    name: string
    description: string
    keywords: string
    comics?: ComicsUncheckedCreateNestedManyWithoutAuthorsInput
  }

  export type AuthorsUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    keywords?: StringFieldUpdateOperationsInput | string
    comics?: ComicsUpdateManyWithoutAuthorsNestedInput
  }

  export type AuthorsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    keywords?: StringFieldUpdateOperationsInput | string
    comics?: ComicsUncheckedUpdateManyWithoutAuthorsNestedInput
  }

  export type AuthorsCreateManyInput = {
    id?: number
    name: string
    description: string
    keywords: string
  }

  export type AuthorsUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    keywords?: StringFieldUpdateOperationsInput | string
  }

  export type AuthorsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    keywords?: StringFieldUpdateOperationsInput | string
  }

  export type ComicsCreateInput = {
    title: string
    description: string
    image: string
    keywords: string
    status: string
    price: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
    categories?: CategoriesCreateNestedManyWithoutComicsInput
    authors?: AuthorsCreateNestedManyWithoutComicsInput
    volumes?: VolumesCreateNestedManyWithoutComicInput
    favorites?: FavoritesCreateNestedManyWithoutComicInput
    rates?: RatesCreateNestedManyWithoutComicInput
    views?: ViewsCreateNestedManyWithoutComicInput
    comment?: CommentsCreateNestedManyWithoutComicInput
    unlock_comic?: Unlock_comicCreateNestedManyWithoutComicInput
    user: UsersCreateNestedOneWithoutComicsInput
  }

  export type ComicsUncheckedCreateInput = {
    id?: number
    title: string
    description: string
    image: string
    keywords: string
    status: string
    price: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
    userId: number
    categories?: CategoriesUncheckedCreateNestedManyWithoutComicsInput
    authors?: AuthorsUncheckedCreateNestedManyWithoutComicsInput
    volumes?: VolumesUncheckedCreateNestedManyWithoutComicInput
    favorites?: FavoritesUncheckedCreateNestedManyWithoutComicInput
    rates?: RatesUncheckedCreateNestedManyWithoutComicInput
    views?: ViewsUncheckedCreateNestedManyWithoutComicInput
    comment?: CommentsUncheckedCreateNestedManyWithoutComicInput
    unlock_comic?: Unlock_comicUncheckedCreateNestedManyWithoutComicInput
  }

  export type ComicsUpdateInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    keywords?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    categories?: CategoriesUpdateManyWithoutComicsNestedInput
    authors?: AuthorsUpdateManyWithoutComicsNestedInput
    volumes?: VolumesUpdateManyWithoutComicNestedInput
    favorites?: FavoritesUpdateManyWithoutComicNestedInput
    rates?: RatesUpdateManyWithoutComicNestedInput
    views?: ViewsUpdateManyWithoutComicNestedInput
    comment?: CommentsUpdateManyWithoutComicNestedInput
    unlock_comic?: Unlock_comicUpdateManyWithoutComicNestedInput
    user?: UsersUpdateOneRequiredWithoutComicsNestedInput
  }

  export type ComicsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    keywords?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: IntFieldUpdateOperationsInput | number
    categories?: CategoriesUncheckedUpdateManyWithoutComicsNestedInput
    authors?: AuthorsUncheckedUpdateManyWithoutComicsNestedInput
    volumes?: VolumesUncheckedUpdateManyWithoutComicNestedInput
    favorites?: FavoritesUncheckedUpdateManyWithoutComicNestedInput
    rates?: RatesUncheckedUpdateManyWithoutComicNestedInput
    views?: ViewsUncheckedUpdateManyWithoutComicNestedInput
    comment?: CommentsUncheckedUpdateManyWithoutComicNestedInput
    unlock_comic?: Unlock_comicUncheckedUpdateManyWithoutComicNestedInput
  }

  export type ComicsCreateManyInput = {
    id?: number
    title: string
    description: string
    image: string
    keywords: string
    status: string
    price: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
    userId: number
  }

  export type ComicsUpdateManyMutationInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    keywords?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ComicsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    keywords?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: IntFieldUpdateOperationsInput | number
  }

  export type VolumesCreateInput = {
    title: string
    description: string
    price: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
    comic: ComicsCreateNestedOneWithoutVolumesInput
    chapters?: ChaptersCreateNestedManyWithoutVolumeInput
    unlock_volume?: Unlock_volumeCreateNestedManyWithoutVolumeInput
  }

  export type VolumesUncheckedCreateInput = {
    id?: number
    title: string
    description: string
    price: Decimal | DecimalJsLike | number | string
    comicId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    chapters?: ChaptersUncheckedCreateNestedManyWithoutVolumeInput
    unlock_volume?: Unlock_volumeUncheckedCreateNestedManyWithoutVolumeInput
  }

  export type VolumesUpdateInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    comic?: ComicsUpdateOneRequiredWithoutVolumesNestedInput
    chapters?: ChaptersUpdateManyWithoutVolumeNestedInput
    unlock_volume?: Unlock_volumeUpdateManyWithoutVolumeNestedInput
  }

  export type VolumesUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    comicId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    chapters?: ChaptersUncheckedUpdateManyWithoutVolumeNestedInput
    unlock_volume?: Unlock_volumeUncheckedUpdateManyWithoutVolumeNestedInput
  }

  export type VolumesCreateManyInput = {
    id?: number
    title: string
    description: string
    price: Decimal | DecimalJsLike | number | string
    comicId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VolumesUpdateManyMutationInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VolumesUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    comicId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChaptersCreateInput = {
    title: string
    filePath: string
    content: string
    price: Decimal | DecimalJsLike | number | string
    lock: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    volume: VolumesCreateNestedOneWithoutChaptersInput
    errors?: ErrorsCreateNestedManyWithoutChapterInput
    views?: ViewsCreateNestedManyWithoutChapterInput
    coments?: CommentsCreateNestedManyWithoutChapterInput
    unlock_chapter?: Unlock_chapterCreateNestedManyWithoutChapterInput
  }

  export type ChaptersUncheckedCreateInput = {
    id?: number
    title: string
    filePath: string
    content: string
    price: Decimal | DecimalJsLike | number | string
    lock: boolean
    volumeId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    errors?: ErrorsUncheckedCreateNestedManyWithoutChapterInput
    views?: ViewsUncheckedCreateNestedManyWithoutChapterInput
    coments?: CommentsUncheckedCreateNestedManyWithoutChapterInput
    unlock_chapter?: Unlock_chapterUncheckedCreateNestedManyWithoutChapterInput
  }

  export type ChaptersUpdateInput = {
    title?: StringFieldUpdateOperationsInput | string
    filePath?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    lock?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    volume?: VolumesUpdateOneRequiredWithoutChaptersNestedInput
    errors?: ErrorsUpdateManyWithoutChapterNestedInput
    views?: ViewsUpdateManyWithoutChapterNestedInput
    coments?: CommentsUpdateManyWithoutChapterNestedInput
    unlock_chapter?: Unlock_chapterUpdateManyWithoutChapterNestedInput
  }

  export type ChaptersUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    filePath?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    lock?: BoolFieldUpdateOperationsInput | boolean
    volumeId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    errors?: ErrorsUncheckedUpdateManyWithoutChapterNestedInput
    views?: ViewsUncheckedUpdateManyWithoutChapterNestedInput
    coments?: CommentsUncheckedUpdateManyWithoutChapterNestedInput
    unlock_chapter?: Unlock_chapterUncheckedUpdateManyWithoutChapterNestedInput
  }

  export type ChaptersCreateManyInput = {
    id?: number
    title: string
    filePath: string
    content: string
    price: Decimal | DecimalJsLike | number | string
    lock: boolean
    volumeId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ChaptersUpdateManyMutationInput = {
    title?: StringFieldUpdateOperationsInput | string
    filePath?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    lock?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChaptersUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    filePath?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    lock?: BoolFieldUpdateOperationsInput | boolean
    volumeId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RolesCreateInput = {
    title: string
    description: string
    users?: UsersCreateNestedManyWithoutUserRoleInput
  }

  export type RolesUncheckedCreateInput = {
    id?: number
    title: string
    description: string
    users?: UsersUncheckedCreateNestedManyWithoutUserRoleInput
  }

  export type RolesUpdateInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    users?: UsersUpdateManyWithoutUserRoleNestedInput
  }

  export type RolesUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    users?: UsersUncheckedUpdateManyWithoutUserRoleNestedInput
  }

  export type RolesCreateManyInput = {
    id?: number
    title: string
    description: string
  }

  export type RolesUpdateManyMutationInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
  }

  export type RolesUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
  }

  export type UsersCreateInput = {
    name: string
    email: string
    password: string
    description: string
    createdAt?: Date | string
    updatedAt?: Date | string
    isDisabled: boolean
    comics?: ComicsCreateNestedManyWithoutUserInput
    userRole?: RolesCreateNestedManyWithoutUsersInput
    favorites?: FavoritesCreateNestedManyWithoutUserInput
    rates?: RatesCreateNestedManyWithoutUserInput
    errors?: ErrorsCreateNestedManyWithoutUserInput
    views?: ViewsCreateNestedManyWithoutUserInput
    coments?: CommentsCreateNestedManyWithoutUserInput
    notifications?: NotificationsCreateNestedManyWithoutUserInput
    wallets?: WalletsCreateNestedOneWithoutUserInput
    unlock_comic?: Unlock_comicCreateNestedManyWithoutUserInput
    unlock_volume?: Unlock_volumeCreateNestedManyWithoutUserInput
    unlock_chapter?: Unlock_chapterCreateNestedManyWithoutUserInput
  }

  export type UsersUncheckedCreateInput = {
    id?: number
    name: string
    email: string
    password: string
    description: string
    createdAt?: Date | string
    updatedAt?: Date | string
    isDisabled: boolean
    comics?: ComicsUncheckedCreateNestedManyWithoutUserInput
    userRole?: RolesUncheckedCreateNestedManyWithoutUsersInput
    favorites?: FavoritesUncheckedCreateNestedManyWithoutUserInput
    rates?: RatesUncheckedCreateNestedManyWithoutUserInput
    errors?: ErrorsUncheckedCreateNestedManyWithoutUserInput
    views?: ViewsUncheckedCreateNestedManyWithoutUserInput
    coments?: CommentsUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationsUncheckedCreateNestedManyWithoutUserInput
    wallets?: WalletsUncheckedCreateNestedOneWithoutUserInput
    unlock_comic?: Unlock_comicUncheckedCreateNestedManyWithoutUserInput
    unlock_volume?: Unlock_volumeUncheckedCreateNestedManyWithoutUserInput
    unlock_chapter?: Unlock_chapterUncheckedCreateNestedManyWithoutUserInput
  }

  export type UsersUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDisabled?: BoolFieldUpdateOperationsInput | boolean
    comics?: ComicsUpdateManyWithoutUserNestedInput
    userRole?: RolesUpdateManyWithoutUsersNestedInput
    favorites?: FavoritesUpdateManyWithoutUserNestedInput
    rates?: RatesUpdateManyWithoutUserNestedInput
    errors?: ErrorsUpdateManyWithoutUserNestedInput
    views?: ViewsUpdateManyWithoutUserNestedInput
    coments?: CommentsUpdateManyWithoutUserNestedInput
    notifications?: NotificationsUpdateManyWithoutUserNestedInput
    wallets?: WalletsUpdateOneWithoutUserNestedInput
    unlock_comic?: Unlock_comicUpdateManyWithoutUserNestedInput
    unlock_volume?: Unlock_volumeUpdateManyWithoutUserNestedInput
    unlock_chapter?: Unlock_chapterUpdateManyWithoutUserNestedInput
  }

  export type UsersUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDisabled?: BoolFieldUpdateOperationsInput | boolean
    comics?: ComicsUncheckedUpdateManyWithoutUserNestedInput
    userRole?: RolesUncheckedUpdateManyWithoutUsersNestedInput
    favorites?: FavoritesUncheckedUpdateManyWithoutUserNestedInput
    rates?: RatesUncheckedUpdateManyWithoutUserNestedInput
    errors?: ErrorsUncheckedUpdateManyWithoutUserNestedInput
    views?: ViewsUncheckedUpdateManyWithoutUserNestedInput
    coments?: CommentsUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationsUncheckedUpdateManyWithoutUserNestedInput
    wallets?: WalletsUncheckedUpdateOneWithoutUserNestedInput
    unlock_comic?: Unlock_comicUncheckedUpdateManyWithoutUserNestedInput
    unlock_volume?: Unlock_volumeUncheckedUpdateManyWithoutUserNestedInput
    unlock_chapter?: Unlock_chapterUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UsersCreateManyInput = {
    id?: number
    name: string
    email: string
    password: string
    description: string
    createdAt?: Date | string
    updatedAt?: Date | string
    isDisabled: boolean
  }

  export type UsersUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDisabled?: BoolFieldUpdateOperationsInput | boolean
  }

  export type UsersUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDisabled?: BoolFieldUpdateOperationsInput | boolean
  }

  export type FavoritesCreateInput = {
    addedAt?: Date | string
    user: UsersCreateNestedOneWithoutFavoritesInput
    comic: ComicsCreateNestedOneWithoutFavoritesInput
  }

  export type FavoritesUncheckedCreateInput = {
    userId: number
    comicId: number
    addedAt?: Date | string
  }

  export type FavoritesUpdateInput = {
    addedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UsersUpdateOneRequiredWithoutFavoritesNestedInput
    comic?: ComicsUpdateOneRequiredWithoutFavoritesNestedInput
  }

  export type FavoritesUncheckedUpdateInput = {
    userId?: IntFieldUpdateOperationsInput | number
    comicId?: IntFieldUpdateOperationsInput | number
    addedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FavoritesCreateManyInput = {
    userId: number
    comicId: number
    addedAt?: Date | string
  }

  export type FavoritesUpdateManyMutationInput = {
    addedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FavoritesUncheckedUpdateManyInput = {
    userId?: IntFieldUpdateOperationsInput | number
    comicId?: IntFieldUpdateOperationsInput | number
    addedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RatesCreateInput = {
    score?: number
    content: string
    createdAt?: Date | string
    user: UsersCreateNestedOneWithoutRatesInput
    comic: ComicsCreateNestedOneWithoutRatesInput
  }

  export type RatesUncheckedCreateInput = {
    userId: number
    comicId: number
    score?: number
    content: string
    createdAt?: Date | string
  }

  export type RatesUpdateInput = {
    score?: FloatFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UsersUpdateOneRequiredWithoutRatesNestedInput
    comic?: ComicsUpdateOneRequiredWithoutRatesNestedInput
  }

  export type RatesUncheckedUpdateInput = {
    userId?: IntFieldUpdateOperationsInput | number
    comicId?: IntFieldUpdateOperationsInput | number
    score?: FloatFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RatesCreateManyInput = {
    userId: number
    comicId: number
    score?: number
    content: string
    createdAt?: Date | string
  }

  export type RatesUpdateManyMutationInput = {
    score?: FloatFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RatesUncheckedUpdateManyInput = {
    userId?: IntFieldUpdateOperationsInput | number
    comicId?: IntFieldUpdateOperationsInput | number
    score?: FloatFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ErrorsCreateInput = {
    content: string
    status: string
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UsersCreateNestedOneWithoutErrorsInput
    chapter: ChaptersCreateNestedOneWithoutErrorsInput
  }

  export type ErrorsUncheckedCreateInput = {
    userId: number
    chapterId: number
    content: string
    status: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ErrorsUpdateInput = {
    content?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UsersUpdateOneRequiredWithoutErrorsNestedInput
    chapter?: ChaptersUpdateOneRequiredWithoutErrorsNestedInput
  }

  export type ErrorsUncheckedUpdateInput = {
    userId?: IntFieldUpdateOperationsInput | number
    chapterId?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ErrorsCreateManyInput = {
    userId: number
    chapterId: number
    content: string
    status: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ErrorsUpdateManyMutationInput = {
    content?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ErrorsUncheckedUpdateManyInput = {
    userId?: IntFieldUpdateOperationsInput | number
    chapterId?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ViewsCreateInput = {
    lastedAt?: Date | string
    user: UsersCreateNestedOneWithoutViewsInput
    comic: ComicsCreateNestedOneWithoutViewsInput
    chapter: ChaptersCreateNestedOneWithoutViewsInput
  }

  export type ViewsUncheckedCreateInput = {
    userId: number
    comicId: number
    chapterId: number
    lastedAt?: Date | string
  }

  export type ViewsUpdateInput = {
    lastedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UsersUpdateOneRequiredWithoutViewsNestedInput
    comic?: ComicsUpdateOneRequiredWithoutViewsNestedInput
    chapter?: ChaptersUpdateOneRequiredWithoutViewsNestedInput
  }

  export type ViewsUncheckedUpdateInput = {
    userId?: IntFieldUpdateOperationsInput | number
    comicId?: IntFieldUpdateOperationsInput | number
    chapterId?: IntFieldUpdateOperationsInput | number
    lastedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ViewsCreateManyInput = {
    userId: number
    comicId: number
    chapterId: number
    lastedAt?: Date | string
  }

  export type ViewsUpdateManyMutationInput = {
    lastedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ViewsUncheckedUpdateManyInput = {
    userId?: IntFieldUpdateOperationsInput | number
    comicId?: IntFieldUpdateOperationsInput | number
    chapterId?: IntFieldUpdateOperationsInput | number
    lastedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommentsCreateInput = {
    content: string
    createdAt?: Date | string
    user: UsersCreateNestedOneWithoutComentsInput
    chapter?: ChaptersCreateNestedOneWithoutComentsInput
    comic: ComicsCreateNestedOneWithoutCommentInput
    notification?: NotificationsCreateNestedManyWithoutCommentInput
  }

  export type CommentsUncheckedCreateInput = {
    id?: number
    content: string
    userId: number
    chapterId?: number | null
    comicId: number
    createdAt?: Date | string
    notification?: NotificationsUncheckedCreateNestedManyWithoutCommentInput
  }

  export type CommentsUpdateInput = {
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UsersUpdateOneRequiredWithoutComentsNestedInput
    chapter?: ChaptersUpdateOneWithoutComentsNestedInput
    comic?: ComicsUpdateOneRequiredWithoutCommentNestedInput
    notification?: NotificationsUpdateManyWithoutCommentNestedInput
  }

  export type CommentsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    userId?: IntFieldUpdateOperationsInput | number
    chapterId?: NullableIntFieldUpdateOperationsInput | number | null
    comicId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notification?: NotificationsUncheckedUpdateManyWithoutCommentNestedInput
  }

  export type CommentsCreateManyInput = {
    id?: number
    content: string
    userId: number
    chapterId?: number | null
    comicId: number
    createdAt?: Date | string
  }

  export type CommentsUpdateManyMutationInput = {
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommentsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    userId?: IntFieldUpdateOperationsInput | number
    chapterId?: NullableIntFieldUpdateOperationsInput | number | null
    comicId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationsCreateInput = {
    content: string
    isRead: boolean
    createdAt?: Date | string
    user: UsersCreateNestedOneWithoutNotificationsInput
    comment?: CommentsCreateNestedOneWithoutNotificationInput
  }

  export type NotificationsUncheckedCreateInput = {
    id?: number
    userId: number
    commentId?: number | null
    content: string
    isRead: boolean
    createdAt?: Date | string
  }

  export type NotificationsUpdateInput = {
    content?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UsersUpdateOneRequiredWithoutNotificationsNestedInput
    comment?: CommentsUpdateOneWithoutNotificationNestedInput
  }

  export type NotificationsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    commentId?: NullableIntFieldUpdateOperationsInput | number | null
    content?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationsCreateManyInput = {
    id?: number
    userId: number
    commentId?: number | null
    content: string
    isRead: boolean
    createdAt?: Date | string
  }

  export type NotificationsUpdateManyMutationInput = {
    content?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    commentId?: NullableIntFieldUpdateOperationsInput | number | null
    content?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WalletsCreateInput = {
    value: Decimal | DecimalJsLike | number | string
    updatedAt?: Date | string
    user: UsersCreateNestedOneWithoutWalletsInput
    transactions?: TransactionsCreateNestedManyWithoutWalletInput
  }

  export type WalletsUncheckedCreateInput = {
    id?: number
    userId: number
    value: Decimal | DecimalJsLike | number | string
    updatedAt?: Date | string
    transactions?: TransactionsUncheckedCreateNestedManyWithoutWalletInput
  }

  export type WalletsUpdateInput = {
    value?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UsersUpdateOneRequiredWithoutWalletsNestedInput
    transactions?: TransactionsUpdateManyWithoutWalletNestedInput
  }

  export type WalletsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    value?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transactions?: TransactionsUncheckedUpdateManyWithoutWalletNestedInput
  }

  export type WalletsCreateManyInput = {
    id?: number
    userId: number
    value: Decimal | DecimalJsLike | number | string
    updatedAt?: Date | string
  }

  export type WalletsUpdateManyMutationInput = {
    value?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WalletsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    value?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransactionsCreateInput = {
    amount: Decimal | DecimalJsLike | number | string
    description: string
    status: string
    createdAt?: Date | string
    wallet: WalletsCreateNestedOneWithoutTransactionsInput
    unlock_comic?: Unlock_comicCreateNestedManyWithoutTransactionInput
    unlock_volume?: Unlock_volumeCreateNestedManyWithoutTransactionInput
    unlock_chapter?: Unlock_chapterCreateNestedManyWithoutTransactionInput
  }

  export type TransactionsUncheckedCreateInput = {
    id?: number
    walletId: number
    amount: Decimal | DecimalJsLike | number | string
    description: string
    status: string
    createdAt?: Date | string
    unlock_comic?: Unlock_comicUncheckedCreateNestedManyWithoutTransactionInput
    unlock_volume?: Unlock_volumeUncheckedCreateNestedManyWithoutTransactionInput
    unlock_chapter?: Unlock_chapterUncheckedCreateNestedManyWithoutTransactionInput
  }

  export type TransactionsUpdateInput = {
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    description?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    wallet?: WalletsUpdateOneRequiredWithoutTransactionsNestedInput
    unlock_comic?: Unlock_comicUpdateManyWithoutTransactionNestedInput
    unlock_volume?: Unlock_volumeUpdateManyWithoutTransactionNestedInput
    unlock_chapter?: Unlock_chapterUpdateManyWithoutTransactionNestedInput
  }

  export type TransactionsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    walletId?: IntFieldUpdateOperationsInput | number
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    description?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    unlock_comic?: Unlock_comicUncheckedUpdateManyWithoutTransactionNestedInput
    unlock_volume?: Unlock_volumeUncheckedUpdateManyWithoutTransactionNestedInput
    unlock_chapter?: Unlock_chapterUncheckedUpdateManyWithoutTransactionNestedInput
  }

  export type TransactionsCreateManyInput = {
    id?: number
    walletId: number
    amount: Decimal | DecimalJsLike | number | string
    description: string
    status: string
    createdAt?: Date | string
  }

  export type TransactionsUpdateManyMutationInput = {
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    description?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransactionsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    walletId?: IntFieldUpdateOperationsInput | number
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    description?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type Unlock_comicCreateInput = {
    createdAt?: Date | string
    user: UsersCreateNestedOneWithoutUnlock_comicInput
    comic: ComicsCreateNestedOneWithoutUnlock_comicInput
    transaction: TransactionsCreateNestedOneWithoutUnlock_comicInput
  }

  export type Unlock_comicUncheckedCreateInput = {
    userId: number
    comicId: number
    transactionId: number
    createdAt?: Date | string
  }

  export type Unlock_comicUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UsersUpdateOneRequiredWithoutUnlock_comicNestedInput
    comic?: ComicsUpdateOneRequiredWithoutUnlock_comicNestedInput
    transaction?: TransactionsUpdateOneRequiredWithoutUnlock_comicNestedInput
  }

  export type Unlock_comicUncheckedUpdateInput = {
    userId?: IntFieldUpdateOperationsInput | number
    comicId?: IntFieldUpdateOperationsInput | number
    transactionId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type Unlock_comicCreateManyInput = {
    userId: number
    comicId: number
    transactionId: number
    createdAt?: Date | string
  }

  export type Unlock_comicUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type Unlock_comicUncheckedUpdateManyInput = {
    userId?: IntFieldUpdateOperationsInput | number
    comicId?: IntFieldUpdateOperationsInput | number
    transactionId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type Unlock_volumeCreateInput = {
    createdAt?: Date | string
    user: UsersCreateNestedOneWithoutUnlock_volumeInput
    volume: VolumesCreateNestedOneWithoutUnlock_volumeInput
    transaction: TransactionsCreateNestedOneWithoutUnlock_volumeInput
  }

  export type Unlock_volumeUncheckedCreateInput = {
    userId: number
    volumeId: number
    transactionId: number
    createdAt?: Date | string
  }

  export type Unlock_volumeUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UsersUpdateOneRequiredWithoutUnlock_volumeNestedInput
    volume?: VolumesUpdateOneRequiredWithoutUnlock_volumeNestedInput
    transaction?: TransactionsUpdateOneRequiredWithoutUnlock_volumeNestedInput
  }

  export type Unlock_volumeUncheckedUpdateInput = {
    userId?: IntFieldUpdateOperationsInput | number
    volumeId?: IntFieldUpdateOperationsInput | number
    transactionId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type Unlock_volumeCreateManyInput = {
    userId: number
    volumeId: number
    transactionId: number
    createdAt?: Date | string
  }

  export type Unlock_volumeUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type Unlock_volumeUncheckedUpdateManyInput = {
    userId?: IntFieldUpdateOperationsInput | number
    volumeId?: IntFieldUpdateOperationsInput | number
    transactionId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type Unlock_chapterCreateInput = {
    createdAt?: Date | string
    user: UsersCreateNestedOneWithoutUnlock_chapterInput
    chapter: ChaptersCreateNestedOneWithoutUnlock_chapterInput
    transaction: TransactionsCreateNestedOneWithoutUnlock_chapterInput
  }

  export type Unlock_chapterUncheckedCreateInput = {
    userId: number
    chapterId: number
    transactionId: number
    createdAt?: Date | string
  }

  export type Unlock_chapterUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UsersUpdateOneRequiredWithoutUnlock_chapterNestedInput
    chapter?: ChaptersUpdateOneRequiredWithoutUnlock_chapterNestedInput
    transaction?: TransactionsUpdateOneRequiredWithoutUnlock_chapterNestedInput
  }

  export type Unlock_chapterUncheckedUpdateInput = {
    userId?: IntFieldUpdateOperationsInput | number
    chapterId?: IntFieldUpdateOperationsInput | number
    transactionId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type Unlock_chapterCreateManyInput = {
    userId: number
    chapterId: number
    transactionId: number
    createdAt?: Date | string
  }

  export type Unlock_chapterUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type Unlock_chapterUncheckedUpdateManyInput = {
    userId?: IntFieldUpdateOperationsInput | number
    chapterId?: IntFieldUpdateOperationsInput | number
    transactionId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type ComicsListRelationFilter = {
    every?: ComicsWhereInput
    some?: ComicsWhereInput
    none?: ComicsWhereInput
  }

  export type ComicsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CategoriesOrderByRelevanceInput = {
    fields: CategoriesOrderByRelevanceFieldEnum | CategoriesOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type CategoriesCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
  }

  export type CategoriesAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type CategoriesMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
  }

  export type CategoriesMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
  }

  export type CategoriesSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type AuthorsOrderByRelevanceInput = {
    fields: AuthorsOrderByRelevanceFieldEnum | AuthorsOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type AuthorsCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    keywords?: SortOrder
  }

  export type AuthorsAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type AuthorsMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    keywords?: SortOrder
  }

  export type AuthorsMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    keywords?: SortOrder
  }

  export type AuthorsSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type DecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[]
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[]
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type CategoriesListRelationFilter = {
    every?: CategoriesWhereInput
    some?: CategoriesWhereInput
    none?: CategoriesWhereInput
  }

  export type AuthorsListRelationFilter = {
    every?: AuthorsWhereInput
    some?: AuthorsWhereInput
    none?: AuthorsWhereInput
  }

  export type VolumesListRelationFilter = {
    every?: VolumesWhereInput
    some?: VolumesWhereInput
    none?: VolumesWhereInput
  }

  export type FavoritesListRelationFilter = {
    every?: FavoritesWhereInput
    some?: FavoritesWhereInput
    none?: FavoritesWhereInput
  }

  export type RatesListRelationFilter = {
    every?: RatesWhereInput
    some?: RatesWhereInput
    none?: RatesWhereInput
  }

  export type ViewsListRelationFilter = {
    every?: ViewsWhereInput
    some?: ViewsWhereInput
    none?: ViewsWhereInput
  }

  export type CommentsListRelationFilter = {
    every?: CommentsWhereInput
    some?: CommentsWhereInput
    none?: CommentsWhereInput
  }

  export type Unlock_comicListRelationFilter = {
    every?: Unlock_comicWhereInput
    some?: Unlock_comicWhereInput
    none?: Unlock_comicWhereInput
  }

  export type UsersScalarRelationFilter = {
    is?: UsersWhereInput
    isNot?: UsersWhereInput
  }

  export type CategoriesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AuthorsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type VolumesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type FavoritesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RatesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ViewsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CommentsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type Unlock_comicOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ComicsOrderByRelevanceInput = {
    fields: ComicsOrderByRelevanceFieldEnum | ComicsOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type ComicsCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    image?: SortOrder
    keywords?: SortOrder
    status?: SortOrder
    price?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrder
  }

  export type ComicsAvgOrderByAggregateInput = {
    id?: SortOrder
    price?: SortOrder
    userId?: SortOrder
  }

  export type ComicsMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    image?: SortOrder
    keywords?: SortOrder
    status?: SortOrder
    price?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrder
  }

  export type ComicsMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    image?: SortOrder
    keywords?: SortOrder
    status?: SortOrder
    price?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrder
  }

  export type ComicsSumOrderByAggregateInput = {
    id?: SortOrder
    price?: SortOrder
    userId?: SortOrder
  }

  export type DecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[]
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[]
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type ComicsScalarRelationFilter = {
    is?: ComicsWhereInput
    isNot?: ComicsWhereInput
  }

  export type ChaptersListRelationFilter = {
    every?: ChaptersWhereInput
    some?: ChaptersWhereInput
    none?: ChaptersWhereInput
  }

  export type Unlock_volumeListRelationFilter = {
    every?: Unlock_volumeWhereInput
    some?: Unlock_volumeWhereInput
    none?: Unlock_volumeWhereInput
  }

  export type ChaptersOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type Unlock_volumeOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type VolumesOrderByRelevanceInput = {
    fields: VolumesOrderByRelevanceFieldEnum | VolumesOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type VolumesCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    price?: SortOrder
    comicId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type VolumesAvgOrderByAggregateInput = {
    id?: SortOrder
    price?: SortOrder
    comicId?: SortOrder
  }

  export type VolumesMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    price?: SortOrder
    comicId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type VolumesMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    price?: SortOrder
    comicId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type VolumesSumOrderByAggregateInput = {
    id?: SortOrder
    price?: SortOrder
    comicId?: SortOrder
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type VolumesScalarRelationFilter = {
    is?: VolumesWhereInput
    isNot?: VolumesWhereInput
  }

  export type ErrorsListRelationFilter = {
    every?: ErrorsWhereInput
    some?: ErrorsWhereInput
    none?: ErrorsWhereInput
  }

  export type Unlock_chapterListRelationFilter = {
    every?: Unlock_chapterWhereInput
    some?: Unlock_chapterWhereInput
    none?: Unlock_chapterWhereInput
  }

  export type ErrorsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type Unlock_chapterOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ChaptersOrderByRelevanceInput = {
    fields: ChaptersOrderByRelevanceFieldEnum | ChaptersOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type ChaptersCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    filePath?: SortOrder
    content?: SortOrder
    price?: SortOrder
    lock?: SortOrder
    volumeId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ChaptersAvgOrderByAggregateInput = {
    id?: SortOrder
    price?: SortOrder
    volumeId?: SortOrder
  }

  export type ChaptersMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    filePath?: SortOrder
    content?: SortOrder
    price?: SortOrder
    lock?: SortOrder
    volumeId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ChaptersMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    filePath?: SortOrder
    content?: SortOrder
    price?: SortOrder
    lock?: SortOrder
    volumeId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ChaptersSumOrderByAggregateInput = {
    id?: SortOrder
    price?: SortOrder
    volumeId?: SortOrder
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type UsersListRelationFilter = {
    every?: UsersWhereInput
    some?: UsersWhereInput
    none?: UsersWhereInput
  }

  export type UsersOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RolesOrderByRelevanceInput = {
    fields: RolesOrderByRelevanceFieldEnum | RolesOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type RolesCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
  }

  export type RolesAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type RolesMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
  }

  export type RolesMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
  }

  export type RolesSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type RolesListRelationFilter = {
    every?: RolesWhereInput
    some?: RolesWhereInput
    none?: RolesWhereInput
  }

  export type NotificationsListRelationFilter = {
    every?: NotificationsWhereInput
    some?: NotificationsWhereInput
    none?: NotificationsWhereInput
  }

  export type WalletsNullableScalarRelationFilter = {
    is?: WalletsWhereInput | null
    isNot?: WalletsWhereInput | null
  }

  export type RolesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type NotificationsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UsersOrderByRelevanceInput = {
    fields: UsersOrderByRelevanceFieldEnum | UsersOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type UsersCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    password?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isDisabled?: SortOrder
  }

  export type UsersAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type UsersMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    password?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isDisabled?: SortOrder
  }

  export type UsersMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    password?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isDisabled?: SortOrder
  }

  export type UsersSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type FavoritesUserIdComicIdCompoundUniqueInput = {
    userId: number
    comicId: number
  }

  export type FavoritesCountOrderByAggregateInput = {
    userId?: SortOrder
    comicId?: SortOrder
    addedAt?: SortOrder
  }

  export type FavoritesAvgOrderByAggregateInput = {
    userId?: SortOrder
    comicId?: SortOrder
  }

  export type FavoritesMaxOrderByAggregateInput = {
    userId?: SortOrder
    comicId?: SortOrder
    addedAt?: SortOrder
  }

  export type FavoritesMinOrderByAggregateInput = {
    userId?: SortOrder
    comicId?: SortOrder
    addedAt?: SortOrder
  }

  export type FavoritesSumOrderByAggregateInput = {
    userId?: SortOrder
    comicId?: SortOrder
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type RatesOrderByRelevanceInput = {
    fields: RatesOrderByRelevanceFieldEnum | RatesOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type RatesUserIdComicIdCompoundUniqueInput = {
    userId: number
    comicId: number
  }

  export type RatesCountOrderByAggregateInput = {
    userId?: SortOrder
    comicId?: SortOrder
    score?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
  }

  export type RatesAvgOrderByAggregateInput = {
    userId?: SortOrder
    comicId?: SortOrder
    score?: SortOrder
  }

  export type RatesMaxOrderByAggregateInput = {
    userId?: SortOrder
    comicId?: SortOrder
    score?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
  }

  export type RatesMinOrderByAggregateInput = {
    userId?: SortOrder
    comicId?: SortOrder
    score?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
  }

  export type RatesSumOrderByAggregateInput = {
    userId?: SortOrder
    comicId?: SortOrder
    score?: SortOrder
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type ChaptersScalarRelationFilter = {
    is?: ChaptersWhereInput
    isNot?: ChaptersWhereInput
  }

  export type ErrorsOrderByRelevanceInput = {
    fields: ErrorsOrderByRelevanceFieldEnum | ErrorsOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type ErrorsUserIdChapterIdCompoundUniqueInput = {
    userId: number
    chapterId: number
  }

  export type ErrorsCountOrderByAggregateInput = {
    userId?: SortOrder
    chapterId?: SortOrder
    content?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ErrorsAvgOrderByAggregateInput = {
    userId?: SortOrder
    chapterId?: SortOrder
  }

  export type ErrorsMaxOrderByAggregateInput = {
    userId?: SortOrder
    chapterId?: SortOrder
    content?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ErrorsMinOrderByAggregateInput = {
    userId?: SortOrder
    chapterId?: SortOrder
    content?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ErrorsSumOrderByAggregateInput = {
    userId?: SortOrder
    chapterId?: SortOrder
  }

  export type ViewsUserIdComicIdCompoundUniqueInput = {
    userId: number
    comicId: number
  }

  export type ViewsCountOrderByAggregateInput = {
    userId?: SortOrder
    comicId?: SortOrder
    chapterId?: SortOrder
    lastedAt?: SortOrder
  }

  export type ViewsAvgOrderByAggregateInput = {
    userId?: SortOrder
    comicId?: SortOrder
    chapterId?: SortOrder
  }

  export type ViewsMaxOrderByAggregateInput = {
    userId?: SortOrder
    comicId?: SortOrder
    chapterId?: SortOrder
    lastedAt?: SortOrder
  }

  export type ViewsMinOrderByAggregateInput = {
    userId?: SortOrder
    comicId?: SortOrder
    chapterId?: SortOrder
    lastedAt?: SortOrder
  }

  export type ViewsSumOrderByAggregateInput = {
    userId?: SortOrder
    comicId?: SortOrder
    chapterId?: SortOrder
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type ChaptersNullableScalarRelationFilter = {
    is?: ChaptersWhereInput | null
    isNot?: ChaptersWhereInput | null
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type CommentsOrderByRelevanceInput = {
    fields: CommentsOrderByRelevanceFieldEnum | CommentsOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type CommentsCountOrderByAggregateInput = {
    id?: SortOrder
    content?: SortOrder
    userId?: SortOrder
    chapterId?: SortOrder
    comicId?: SortOrder
    createdAt?: SortOrder
  }

  export type CommentsAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    chapterId?: SortOrder
    comicId?: SortOrder
  }

  export type CommentsMaxOrderByAggregateInput = {
    id?: SortOrder
    content?: SortOrder
    userId?: SortOrder
    chapterId?: SortOrder
    comicId?: SortOrder
    createdAt?: SortOrder
  }

  export type CommentsMinOrderByAggregateInput = {
    id?: SortOrder
    content?: SortOrder
    userId?: SortOrder
    chapterId?: SortOrder
    comicId?: SortOrder
    createdAt?: SortOrder
  }

  export type CommentsSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    chapterId?: SortOrder
    comicId?: SortOrder
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type CommentsNullableScalarRelationFilter = {
    is?: CommentsWhereInput | null
    isNot?: CommentsWhereInput | null
  }

  export type NotificationsOrderByRelevanceInput = {
    fields: NotificationsOrderByRelevanceFieldEnum | NotificationsOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type NotificationsCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    commentId?: SortOrder
    content?: SortOrder
    isRead?: SortOrder
    createdAt?: SortOrder
  }

  export type NotificationsAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    commentId?: SortOrder
  }

  export type NotificationsMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    commentId?: SortOrder
    content?: SortOrder
    isRead?: SortOrder
    createdAt?: SortOrder
  }

  export type NotificationsMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    commentId?: SortOrder
    content?: SortOrder
    isRead?: SortOrder
    createdAt?: SortOrder
  }

  export type NotificationsSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    commentId?: SortOrder
  }

  export type TransactionsListRelationFilter = {
    every?: TransactionsWhereInput
    some?: TransactionsWhereInput
    none?: TransactionsWhereInput
  }

  export type TransactionsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type WalletsCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    value?: SortOrder
    updatedAt?: SortOrder
  }

  export type WalletsAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    value?: SortOrder
  }

  export type WalletsMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    value?: SortOrder
    updatedAt?: SortOrder
  }

  export type WalletsMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    value?: SortOrder
    updatedAt?: SortOrder
  }

  export type WalletsSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    value?: SortOrder
  }

  export type WalletsScalarRelationFilter = {
    is?: WalletsWhereInput
    isNot?: WalletsWhereInput
  }

  export type TransactionsOrderByRelevanceInput = {
    fields: TransactionsOrderByRelevanceFieldEnum | TransactionsOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type TransactionsCountOrderByAggregateInput = {
    id?: SortOrder
    walletId?: SortOrder
    amount?: SortOrder
    description?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
  }

  export type TransactionsAvgOrderByAggregateInput = {
    id?: SortOrder
    walletId?: SortOrder
    amount?: SortOrder
  }

  export type TransactionsMaxOrderByAggregateInput = {
    id?: SortOrder
    walletId?: SortOrder
    amount?: SortOrder
    description?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
  }

  export type TransactionsMinOrderByAggregateInput = {
    id?: SortOrder
    walletId?: SortOrder
    amount?: SortOrder
    description?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
  }

  export type TransactionsSumOrderByAggregateInput = {
    id?: SortOrder
    walletId?: SortOrder
    amount?: SortOrder
  }

  export type TransactionsScalarRelationFilter = {
    is?: TransactionsWhereInput
    isNot?: TransactionsWhereInput
  }

  export type Unlock_comicUserIdComicIdTransactionIdCompoundUniqueInput = {
    userId: number
    comicId: number
    transactionId: number
  }

  export type Unlock_comicCountOrderByAggregateInput = {
    userId?: SortOrder
    comicId?: SortOrder
    transactionId?: SortOrder
    createdAt?: SortOrder
  }

  export type Unlock_comicAvgOrderByAggregateInput = {
    userId?: SortOrder
    comicId?: SortOrder
    transactionId?: SortOrder
  }

  export type Unlock_comicMaxOrderByAggregateInput = {
    userId?: SortOrder
    comicId?: SortOrder
    transactionId?: SortOrder
    createdAt?: SortOrder
  }

  export type Unlock_comicMinOrderByAggregateInput = {
    userId?: SortOrder
    comicId?: SortOrder
    transactionId?: SortOrder
    createdAt?: SortOrder
  }

  export type Unlock_comicSumOrderByAggregateInput = {
    userId?: SortOrder
    comicId?: SortOrder
    transactionId?: SortOrder
  }

  export type Unlock_volumeUserIdVolumeIdTransactionIdCompoundUniqueInput = {
    userId: number
    volumeId: number
    transactionId: number
  }

  export type Unlock_volumeCountOrderByAggregateInput = {
    userId?: SortOrder
    volumeId?: SortOrder
    transactionId?: SortOrder
    createdAt?: SortOrder
  }

  export type Unlock_volumeAvgOrderByAggregateInput = {
    userId?: SortOrder
    volumeId?: SortOrder
    transactionId?: SortOrder
  }

  export type Unlock_volumeMaxOrderByAggregateInput = {
    userId?: SortOrder
    volumeId?: SortOrder
    transactionId?: SortOrder
    createdAt?: SortOrder
  }

  export type Unlock_volumeMinOrderByAggregateInput = {
    userId?: SortOrder
    volumeId?: SortOrder
    transactionId?: SortOrder
    createdAt?: SortOrder
  }

  export type Unlock_volumeSumOrderByAggregateInput = {
    userId?: SortOrder
    volumeId?: SortOrder
    transactionId?: SortOrder
  }

  export type Unlock_chapterUserIdChapterIdTransactionIdCompoundUniqueInput = {
    userId: number
    chapterId: number
    transactionId: number
  }

  export type Unlock_chapterCountOrderByAggregateInput = {
    userId?: SortOrder
    chapterId?: SortOrder
    transactionId?: SortOrder
    createdAt?: SortOrder
  }

  export type Unlock_chapterAvgOrderByAggregateInput = {
    userId?: SortOrder
    chapterId?: SortOrder
    transactionId?: SortOrder
  }

  export type Unlock_chapterMaxOrderByAggregateInput = {
    userId?: SortOrder
    chapterId?: SortOrder
    transactionId?: SortOrder
    createdAt?: SortOrder
  }

  export type Unlock_chapterMinOrderByAggregateInput = {
    userId?: SortOrder
    chapterId?: SortOrder
    transactionId?: SortOrder
    createdAt?: SortOrder
  }

  export type Unlock_chapterSumOrderByAggregateInput = {
    userId?: SortOrder
    chapterId?: SortOrder
    transactionId?: SortOrder
  }

  export type ComicsCreateNestedManyWithoutCategoriesInput = {
    create?: XOR<ComicsCreateWithoutCategoriesInput, ComicsUncheckedCreateWithoutCategoriesInput> | ComicsCreateWithoutCategoriesInput[] | ComicsUncheckedCreateWithoutCategoriesInput[]
    connectOrCreate?: ComicsCreateOrConnectWithoutCategoriesInput | ComicsCreateOrConnectWithoutCategoriesInput[]
    connect?: ComicsWhereUniqueInput | ComicsWhereUniqueInput[]
  }

  export type ComicsUncheckedCreateNestedManyWithoutCategoriesInput = {
    create?: XOR<ComicsCreateWithoutCategoriesInput, ComicsUncheckedCreateWithoutCategoriesInput> | ComicsCreateWithoutCategoriesInput[] | ComicsUncheckedCreateWithoutCategoriesInput[]
    connectOrCreate?: ComicsCreateOrConnectWithoutCategoriesInput | ComicsCreateOrConnectWithoutCategoriesInput[]
    connect?: ComicsWhereUniqueInput | ComicsWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type ComicsUpdateManyWithoutCategoriesNestedInput = {
    create?: XOR<ComicsCreateWithoutCategoriesInput, ComicsUncheckedCreateWithoutCategoriesInput> | ComicsCreateWithoutCategoriesInput[] | ComicsUncheckedCreateWithoutCategoriesInput[]
    connectOrCreate?: ComicsCreateOrConnectWithoutCategoriesInput | ComicsCreateOrConnectWithoutCategoriesInput[]
    upsert?: ComicsUpsertWithWhereUniqueWithoutCategoriesInput | ComicsUpsertWithWhereUniqueWithoutCategoriesInput[]
    set?: ComicsWhereUniqueInput | ComicsWhereUniqueInput[]
    disconnect?: ComicsWhereUniqueInput | ComicsWhereUniqueInput[]
    delete?: ComicsWhereUniqueInput | ComicsWhereUniqueInput[]
    connect?: ComicsWhereUniqueInput | ComicsWhereUniqueInput[]
    update?: ComicsUpdateWithWhereUniqueWithoutCategoriesInput | ComicsUpdateWithWhereUniqueWithoutCategoriesInput[]
    updateMany?: ComicsUpdateManyWithWhereWithoutCategoriesInput | ComicsUpdateManyWithWhereWithoutCategoriesInput[]
    deleteMany?: ComicsScalarWhereInput | ComicsScalarWhereInput[]
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type ComicsUncheckedUpdateManyWithoutCategoriesNestedInput = {
    create?: XOR<ComicsCreateWithoutCategoriesInput, ComicsUncheckedCreateWithoutCategoriesInput> | ComicsCreateWithoutCategoriesInput[] | ComicsUncheckedCreateWithoutCategoriesInput[]
    connectOrCreate?: ComicsCreateOrConnectWithoutCategoriesInput | ComicsCreateOrConnectWithoutCategoriesInput[]
    upsert?: ComicsUpsertWithWhereUniqueWithoutCategoriesInput | ComicsUpsertWithWhereUniqueWithoutCategoriesInput[]
    set?: ComicsWhereUniqueInput | ComicsWhereUniqueInput[]
    disconnect?: ComicsWhereUniqueInput | ComicsWhereUniqueInput[]
    delete?: ComicsWhereUniqueInput | ComicsWhereUniqueInput[]
    connect?: ComicsWhereUniqueInput | ComicsWhereUniqueInput[]
    update?: ComicsUpdateWithWhereUniqueWithoutCategoriesInput | ComicsUpdateWithWhereUniqueWithoutCategoriesInput[]
    updateMany?: ComicsUpdateManyWithWhereWithoutCategoriesInput | ComicsUpdateManyWithWhereWithoutCategoriesInput[]
    deleteMany?: ComicsScalarWhereInput | ComicsScalarWhereInput[]
  }

  export type ComicsCreateNestedManyWithoutAuthorsInput = {
    create?: XOR<ComicsCreateWithoutAuthorsInput, ComicsUncheckedCreateWithoutAuthorsInput> | ComicsCreateWithoutAuthorsInput[] | ComicsUncheckedCreateWithoutAuthorsInput[]
    connectOrCreate?: ComicsCreateOrConnectWithoutAuthorsInput | ComicsCreateOrConnectWithoutAuthorsInput[]
    connect?: ComicsWhereUniqueInput | ComicsWhereUniqueInput[]
  }

  export type ComicsUncheckedCreateNestedManyWithoutAuthorsInput = {
    create?: XOR<ComicsCreateWithoutAuthorsInput, ComicsUncheckedCreateWithoutAuthorsInput> | ComicsCreateWithoutAuthorsInput[] | ComicsUncheckedCreateWithoutAuthorsInput[]
    connectOrCreate?: ComicsCreateOrConnectWithoutAuthorsInput | ComicsCreateOrConnectWithoutAuthorsInput[]
    connect?: ComicsWhereUniqueInput | ComicsWhereUniqueInput[]
  }

  export type ComicsUpdateManyWithoutAuthorsNestedInput = {
    create?: XOR<ComicsCreateWithoutAuthorsInput, ComicsUncheckedCreateWithoutAuthorsInput> | ComicsCreateWithoutAuthorsInput[] | ComicsUncheckedCreateWithoutAuthorsInput[]
    connectOrCreate?: ComicsCreateOrConnectWithoutAuthorsInput | ComicsCreateOrConnectWithoutAuthorsInput[]
    upsert?: ComicsUpsertWithWhereUniqueWithoutAuthorsInput | ComicsUpsertWithWhereUniqueWithoutAuthorsInput[]
    set?: ComicsWhereUniqueInput | ComicsWhereUniqueInput[]
    disconnect?: ComicsWhereUniqueInput | ComicsWhereUniqueInput[]
    delete?: ComicsWhereUniqueInput | ComicsWhereUniqueInput[]
    connect?: ComicsWhereUniqueInput | ComicsWhereUniqueInput[]
    update?: ComicsUpdateWithWhereUniqueWithoutAuthorsInput | ComicsUpdateWithWhereUniqueWithoutAuthorsInput[]
    updateMany?: ComicsUpdateManyWithWhereWithoutAuthorsInput | ComicsUpdateManyWithWhereWithoutAuthorsInput[]
    deleteMany?: ComicsScalarWhereInput | ComicsScalarWhereInput[]
  }

  export type ComicsUncheckedUpdateManyWithoutAuthorsNestedInput = {
    create?: XOR<ComicsCreateWithoutAuthorsInput, ComicsUncheckedCreateWithoutAuthorsInput> | ComicsCreateWithoutAuthorsInput[] | ComicsUncheckedCreateWithoutAuthorsInput[]
    connectOrCreate?: ComicsCreateOrConnectWithoutAuthorsInput | ComicsCreateOrConnectWithoutAuthorsInput[]
    upsert?: ComicsUpsertWithWhereUniqueWithoutAuthorsInput | ComicsUpsertWithWhereUniqueWithoutAuthorsInput[]
    set?: ComicsWhereUniqueInput | ComicsWhereUniqueInput[]
    disconnect?: ComicsWhereUniqueInput | ComicsWhereUniqueInput[]
    delete?: ComicsWhereUniqueInput | ComicsWhereUniqueInput[]
    connect?: ComicsWhereUniqueInput | ComicsWhereUniqueInput[]
    update?: ComicsUpdateWithWhereUniqueWithoutAuthorsInput | ComicsUpdateWithWhereUniqueWithoutAuthorsInput[]
    updateMany?: ComicsUpdateManyWithWhereWithoutAuthorsInput | ComicsUpdateManyWithWhereWithoutAuthorsInput[]
    deleteMany?: ComicsScalarWhereInput | ComicsScalarWhereInput[]
  }

  export type CategoriesCreateNestedManyWithoutComicsInput = {
    create?: XOR<CategoriesCreateWithoutComicsInput, CategoriesUncheckedCreateWithoutComicsInput> | CategoriesCreateWithoutComicsInput[] | CategoriesUncheckedCreateWithoutComicsInput[]
    connectOrCreate?: CategoriesCreateOrConnectWithoutComicsInput | CategoriesCreateOrConnectWithoutComicsInput[]
    connect?: CategoriesWhereUniqueInput | CategoriesWhereUniqueInput[]
  }

  export type AuthorsCreateNestedManyWithoutComicsInput = {
    create?: XOR<AuthorsCreateWithoutComicsInput, AuthorsUncheckedCreateWithoutComicsInput> | AuthorsCreateWithoutComicsInput[] | AuthorsUncheckedCreateWithoutComicsInput[]
    connectOrCreate?: AuthorsCreateOrConnectWithoutComicsInput | AuthorsCreateOrConnectWithoutComicsInput[]
    connect?: AuthorsWhereUniqueInput | AuthorsWhereUniqueInput[]
  }

  export type VolumesCreateNestedManyWithoutComicInput = {
    create?: XOR<VolumesCreateWithoutComicInput, VolumesUncheckedCreateWithoutComicInput> | VolumesCreateWithoutComicInput[] | VolumesUncheckedCreateWithoutComicInput[]
    connectOrCreate?: VolumesCreateOrConnectWithoutComicInput | VolumesCreateOrConnectWithoutComicInput[]
    createMany?: VolumesCreateManyComicInputEnvelope
    connect?: VolumesWhereUniqueInput | VolumesWhereUniqueInput[]
  }

  export type FavoritesCreateNestedManyWithoutComicInput = {
    create?: XOR<FavoritesCreateWithoutComicInput, FavoritesUncheckedCreateWithoutComicInput> | FavoritesCreateWithoutComicInput[] | FavoritesUncheckedCreateWithoutComicInput[]
    connectOrCreate?: FavoritesCreateOrConnectWithoutComicInput | FavoritesCreateOrConnectWithoutComicInput[]
    createMany?: FavoritesCreateManyComicInputEnvelope
    connect?: FavoritesWhereUniqueInput | FavoritesWhereUniqueInput[]
  }

  export type RatesCreateNestedManyWithoutComicInput = {
    create?: XOR<RatesCreateWithoutComicInput, RatesUncheckedCreateWithoutComicInput> | RatesCreateWithoutComicInput[] | RatesUncheckedCreateWithoutComicInput[]
    connectOrCreate?: RatesCreateOrConnectWithoutComicInput | RatesCreateOrConnectWithoutComicInput[]
    createMany?: RatesCreateManyComicInputEnvelope
    connect?: RatesWhereUniqueInput | RatesWhereUniqueInput[]
  }

  export type ViewsCreateNestedManyWithoutComicInput = {
    create?: XOR<ViewsCreateWithoutComicInput, ViewsUncheckedCreateWithoutComicInput> | ViewsCreateWithoutComicInput[] | ViewsUncheckedCreateWithoutComicInput[]
    connectOrCreate?: ViewsCreateOrConnectWithoutComicInput | ViewsCreateOrConnectWithoutComicInput[]
    createMany?: ViewsCreateManyComicInputEnvelope
    connect?: ViewsWhereUniqueInput | ViewsWhereUniqueInput[]
  }

  export type CommentsCreateNestedManyWithoutComicInput = {
    create?: XOR<CommentsCreateWithoutComicInput, CommentsUncheckedCreateWithoutComicInput> | CommentsCreateWithoutComicInput[] | CommentsUncheckedCreateWithoutComicInput[]
    connectOrCreate?: CommentsCreateOrConnectWithoutComicInput | CommentsCreateOrConnectWithoutComicInput[]
    createMany?: CommentsCreateManyComicInputEnvelope
    connect?: CommentsWhereUniqueInput | CommentsWhereUniqueInput[]
  }

  export type Unlock_comicCreateNestedManyWithoutComicInput = {
    create?: XOR<Unlock_comicCreateWithoutComicInput, Unlock_comicUncheckedCreateWithoutComicInput> | Unlock_comicCreateWithoutComicInput[] | Unlock_comicUncheckedCreateWithoutComicInput[]
    connectOrCreate?: Unlock_comicCreateOrConnectWithoutComicInput | Unlock_comicCreateOrConnectWithoutComicInput[]
    createMany?: Unlock_comicCreateManyComicInputEnvelope
    connect?: Unlock_comicWhereUniqueInput | Unlock_comicWhereUniqueInput[]
  }

  export type UsersCreateNestedOneWithoutComicsInput = {
    create?: XOR<UsersCreateWithoutComicsInput, UsersUncheckedCreateWithoutComicsInput>
    connectOrCreate?: UsersCreateOrConnectWithoutComicsInput
    connect?: UsersWhereUniqueInput
  }

  export type CategoriesUncheckedCreateNestedManyWithoutComicsInput = {
    create?: XOR<CategoriesCreateWithoutComicsInput, CategoriesUncheckedCreateWithoutComicsInput> | CategoriesCreateWithoutComicsInput[] | CategoriesUncheckedCreateWithoutComicsInput[]
    connectOrCreate?: CategoriesCreateOrConnectWithoutComicsInput | CategoriesCreateOrConnectWithoutComicsInput[]
    connect?: CategoriesWhereUniqueInput | CategoriesWhereUniqueInput[]
  }

  export type AuthorsUncheckedCreateNestedManyWithoutComicsInput = {
    create?: XOR<AuthorsCreateWithoutComicsInput, AuthorsUncheckedCreateWithoutComicsInput> | AuthorsCreateWithoutComicsInput[] | AuthorsUncheckedCreateWithoutComicsInput[]
    connectOrCreate?: AuthorsCreateOrConnectWithoutComicsInput | AuthorsCreateOrConnectWithoutComicsInput[]
    connect?: AuthorsWhereUniqueInput | AuthorsWhereUniqueInput[]
  }

  export type VolumesUncheckedCreateNestedManyWithoutComicInput = {
    create?: XOR<VolumesCreateWithoutComicInput, VolumesUncheckedCreateWithoutComicInput> | VolumesCreateWithoutComicInput[] | VolumesUncheckedCreateWithoutComicInput[]
    connectOrCreate?: VolumesCreateOrConnectWithoutComicInput | VolumesCreateOrConnectWithoutComicInput[]
    createMany?: VolumesCreateManyComicInputEnvelope
    connect?: VolumesWhereUniqueInput | VolumesWhereUniqueInput[]
  }

  export type FavoritesUncheckedCreateNestedManyWithoutComicInput = {
    create?: XOR<FavoritesCreateWithoutComicInput, FavoritesUncheckedCreateWithoutComicInput> | FavoritesCreateWithoutComicInput[] | FavoritesUncheckedCreateWithoutComicInput[]
    connectOrCreate?: FavoritesCreateOrConnectWithoutComicInput | FavoritesCreateOrConnectWithoutComicInput[]
    createMany?: FavoritesCreateManyComicInputEnvelope
    connect?: FavoritesWhereUniqueInput | FavoritesWhereUniqueInput[]
  }

  export type RatesUncheckedCreateNestedManyWithoutComicInput = {
    create?: XOR<RatesCreateWithoutComicInput, RatesUncheckedCreateWithoutComicInput> | RatesCreateWithoutComicInput[] | RatesUncheckedCreateWithoutComicInput[]
    connectOrCreate?: RatesCreateOrConnectWithoutComicInput | RatesCreateOrConnectWithoutComicInput[]
    createMany?: RatesCreateManyComicInputEnvelope
    connect?: RatesWhereUniqueInput | RatesWhereUniqueInput[]
  }

  export type ViewsUncheckedCreateNestedManyWithoutComicInput = {
    create?: XOR<ViewsCreateWithoutComicInput, ViewsUncheckedCreateWithoutComicInput> | ViewsCreateWithoutComicInput[] | ViewsUncheckedCreateWithoutComicInput[]
    connectOrCreate?: ViewsCreateOrConnectWithoutComicInput | ViewsCreateOrConnectWithoutComicInput[]
    createMany?: ViewsCreateManyComicInputEnvelope
    connect?: ViewsWhereUniqueInput | ViewsWhereUniqueInput[]
  }

  export type CommentsUncheckedCreateNestedManyWithoutComicInput = {
    create?: XOR<CommentsCreateWithoutComicInput, CommentsUncheckedCreateWithoutComicInput> | CommentsCreateWithoutComicInput[] | CommentsUncheckedCreateWithoutComicInput[]
    connectOrCreate?: CommentsCreateOrConnectWithoutComicInput | CommentsCreateOrConnectWithoutComicInput[]
    createMany?: CommentsCreateManyComicInputEnvelope
    connect?: CommentsWhereUniqueInput | CommentsWhereUniqueInput[]
  }

  export type Unlock_comicUncheckedCreateNestedManyWithoutComicInput = {
    create?: XOR<Unlock_comicCreateWithoutComicInput, Unlock_comicUncheckedCreateWithoutComicInput> | Unlock_comicCreateWithoutComicInput[] | Unlock_comicUncheckedCreateWithoutComicInput[]
    connectOrCreate?: Unlock_comicCreateOrConnectWithoutComicInput | Unlock_comicCreateOrConnectWithoutComicInput[]
    createMany?: Unlock_comicCreateManyComicInputEnvelope
    connect?: Unlock_comicWhereUniqueInput | Unlock_comicWhereUniqueInput[]
  }

  export type DecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type CategoriesUpdateManyWithoutComicsNestedInput = {
    create?: XOR<CategoriesCreateWithoutComicsInput, CategoriesUncheckedCreateWithoutComicsInput> | CategoriesCreateWithoutComicsInput[] | CategoriesUncheckedCreateWithoutComicsInput[]
    connectOrCreate?: CategoriesCreateOrConnectWithoutComicsInput | CategoriesCreateOrConnectWithoutComicsInput[]
    upsert?: CategoriesUpsertWithWhereUniqueWithoutComicsInput | CategoriesUpsertWithWhereUniqueWithoutComicsInput[]
    set?: CategoriesWhereUniqueInput | CategoriesWhereUniqueInput[]
    disconnect?: CategoriesWhereUniqueInput | CategoriesWhereUniqueInput[]
    delete?: CategoriesWhereUniqueInput | CategoriesWhereUniqueInput[]
    connect?: CategoriesWhereUniqueInput | CategoriesWhereUniqueInput[]
    update?: CategoriesUpdateWithWhereUniqueWithoutComicsInput | CategoriesUpdateWithWhereUniqueWithoutComicsInput[]
    updateMany?: CategoriesUpdateManyWithWhereWithoutComicsInput | CategoriesUpdateManyWithWhereWithoutComicsInput[]
    deleteMany?: CategoriesScalarWhereInput | CategoriesScalarWhereInput[]
  }

  export type AuthorsUpdateManyWithoutComicsNestedInput = {
    create?: XOR<AuthorsCreateWithoutComicsInput, AuthorsUncheckedCreateWithoutComicsInput> | AuthorsCreateWithoutComicsInput[] | AuthorsUncheckedCreateWithoutComicsInput[]
    connectOrCreate?: AuthorsCreateOrConnectWithoutComicsInput | AuthorsCreateOrConnectWithoutComicsInput[]
    upsert?: AuthorsUpsertWithWhereUniqueWithoutComicsInput | AuthorsUpsertWithWhereUniqueWithoutComicsInput[]
    set?: AuthorsWhereUniqueInput | AuthorsWhereUniqueInput[]
    disconnect?: AuthorsWhereUniqueInput | AuthorsWhereUniqueInput[]
    delete?: AuthorsWhereUniqueInput | AuthorsWhereUniqueInput[]
    connect?: AuthorsWhereUniqueInput | AuthorsWhereUniqueInput[]
    update?: AuthorsUpdateWithWhereUniqueWithoutComicsInput | AuthorsUpdateWithWhereUniqueWithoutComicsInput[]
    updateMany?: AuthorsUpdateManyWithWhereWithoutComicsInput | AuthorsUpdateManyWithWhereWithoutComicsInput[]
    deleteMany?: AuthorsScalarWhereInput | AuthorsScalarWhereInput[]
  }

  export type VolumesUpdateManyWithoutComicNestedInput = {
    create?: XOR<VolumesCreateWithoutComicInput, VolumesUncheckedCreateWithoutComicInput> | VolumesCreateWithoutComicInput[] | VolumesUncheckedCreateWithoutComicInput[]
    connectOrCreate?: VolumesCreateOrConnectWithoutComicInput | VolumesCreateOrConnectWithoutComicInput[]
    upsert?: VolumesUpsertWithWhereUniqueWithoutComicInput | VolumesUpsertWithWhereUniqueWithoutComicInput[]
    createMany?: VolumesCreateManyComicInputEnvelope
    set?: VolumesWhereUniqueInput | VolumesWhereUniqueInput[]
    disconnect?: VolumesWhereUniqueInput | VolumesWhereUniqueInput[]
    delete?: VolumesWhereUniqueInput | VolumesWhereUniqueInput[]
    connect?: VolumesWhereUniqueInput | VolumesWhereUniqueInput[]
    update?: VolumesUpdateWithWhereUniqueWithoutComicInput | VolumesUpdateWithWhereUniqueWithoutComicInput[]
    updateMany?: VolumesUpdateManyWithWhereWithoutComicInput | VolumesUpdateManyWithWhereWithoutComicInput[]
    deleteMany?: VolumesScalarWhereInput | VolumesScalarWhereInput[]
  }

  export type FavoritesUpdateManyWithoutComicNestedInput = {
    create?: XOR<FavoritesCreateWithoutComicInput, FavoritesUncheckedCreateWithoutComicInput> | FavoritesCreateWithoutComicInput[] | FavoritesUncheckedCreateWithoutComicInput[]
    connectOrCreate?: FavoritesCreateOrConnectWithoutComicInput | FavoritesCreateOrConnectWithoutComicInput[]
    upsert?: FavoritesUpsertWithWhereUniqueWithoutComicInput | FavoritesUpsertWithWhereUniqueWithoutComicInput[]
    createMany?: FavoritesCreateManyComicInputEnvelope
    set?: FavoritesWhereUniqueInput | FavoritesWhereUniqueInput[]
    disconnect?: FavoritesWhereUniqueInput | FavoritesWhereUniqueInput[]
    delete?: FavoritesWhereUniqueInput | FavoritesWhereUniqueInput[]
    connect?: FavoritesWhereUniqueInput | FavoritesWhereUniqueInput[]
    update?: FavoritesUpdateWithWhereUniqueWithoutComicInput | FavoritesUpdateWithWhereUniqueWithoutComicInput[]
    updateMany?: FavoritesUpdateManyWithWhereWithoutComicInput | FavoritesUpdateManyWithWhereWithoutComicInput[]
    deleteMany?: FavoritesScalarWhereInput | FavoritesScalarWhereInput[]
  }

  export type RatesUpdateManyWithoutComicNestedInput = {
    create?: XOR<RatesCreateWithoutComicInput, RatesUncheckedCreateWithoutComicInput> | RatesCreateWithoutComicInput[] | RatesUncheckedCreateWithoutComicInput[]
    connectOrCreate?: RatesCreateOrConnectWithoutComicInput | RatesCreateOrConnectWithoutComicInput[]
    upsert?: RatesUpsertWithWhereUniqueWithoutComicInput | RatesUpsertWithWhereUniqueWithoutComicInput[]
    createMany?: RatesCreateManyComicInputEnvelope
    set?: RatesWhereUniqueInput | RatesWhereUniqueInput[]
    disconnect?: RatesWhereUniqueInput | RatesWhereUniqueInput[]
    delete?: RatesWhereUniqueInput | RatesWhereUniqueInput[]
    connect?: RatesWhereUniqueInput | RatesWhereUniqueInput[]
    update?: RatesUpdateWithWhereUniqueWithoutComicInput | RatesUpdateWithWhereUniqueWithoutComicInput[]
    updateMany?: RatesUpdateManyWithWhereWithoutComicInput | RatesUpdateManyWithWhereWithoutComicInput[]
    deleteMany?: RatesScalarWhereInput | RatesScalarWhereInput[]
  }

  export type ViewsUpdateManyWithoutComicNestedInput = {
    create?: XOR<ViewsCreateWithoutComicInput, ViewsUncheckedCreateWithoutComicInput> | ViewsCreateWithoutComicInput[] | ViewsUncheckedCreateWithoutComicInput[]
    connectOrCreate?: ViewsCreateOrConnectWithoutComicInput | ViewsCreateOrConnectWithoutComicInput[]
    upsert?: ViewsUpsertWithWhereUniqueWithoutComicInput | ViewsUpsertWithWhereUniqueWithoutComicInput[]
    createMany?: ViewsCreateManyComicInputEnvelope
    set?: ViewsWhereUniqueInput | ViewsWhereUniqueInput[]
    disconnect?: ViewsWhereUniqueInput | ViewsWhereUniqueInput[]
    delete?: ViewsWhereUniqueInput | ViewsWhereUniqueInput[]
    connect?: ViewsWhereUniqueInput | ViewsWhereUniqueInput[]
    update?: ViewsUpdateWithWhereUniqueWithoutComicInput | ViewsUpdateWithWhereUniqueWithoutComicInput[]
    updateMany?: ViewsUpdateManyWithWhereWithoutComicInput | ViewsUpdateManyWithWhereWithoutComicInput[]
    deleteMany?: ViewsScalarWhereInput | ViewsScalarWhereInput[]
  }

  export type CommentsUpdateManyWithoutComicNestedInput = {
    create?: XOR<CommentsCreateWithoutComicInput, CommentsUncheckedCreateWithoutComicInput> | CommentsCreateWithoutComicInput[] | CommentsUncheckedCreateWithoutComicInput[]
    connectOrCreate?: CommentsCreateOrConnectWithoutComicInput | CommentsCreateOrConnectWithoutComicInput[]
    upsert?: CommentsUpsertWithWhereUniqueWithoutComicInput | CommentsUpsertWithWhereUniqueWithoutComicInput[]
    createMany?: CommentsCreateManyComicInputEnvelope
    set?: CommentsWhereUniqueInput | CommentsWhereUniqueInput[]
    disconnect?: CommentsWhereUniqueInput | CommentsWhereUniqueInput[]
    delete?: CommentsWhereUniqueInput | CommentsWhereUniqueInput[]
    connect?: CommentsWhereUniqueInput | CommentsWhereUniqueInput[]
    update?: CommentsUpdateWithWhereUniqueWithoutComicInput | CommentsUpdateWithWhereUniqueWithoutComicInput[]
    updateMany?: CommentsUpdateManyWithWhereWithoutComicInput | CommentsUpdateManyWithWhereWithoutComicInput[]
    deleteMany?: CommentsScalarWhereInput | CommentsScalarWhereInput[]
  }

  export type Unlock_comicUpdateManyWithoutComicNestedInput = {
    create?: XOR<Unlock_comicCreateWithoutComicInput, Unlock_comicUncheckedCreateWithoutComicInput> | Unlock_comicCreateWithoutComicInput[] | Unlock_comicUncheckedCreateWithoutComicInput[]
    connectOrCreate?: Unlock_comicCreateOrConnectWithoutComicInput | Unlock_comicCreateOrConnectWithoutComicInput[]
    upsert?: Unlock_comicUpsertWithWhereUniqueWithoutComicInput | Unlock_comicUpsertWithWhereUniqueWithoutComicInput[]
    createMany?: Unlock_comicCreateManyComicInputEnvelope
    set?: Unlock_comicWhereUniqueInput | Unlock_comicWhereUniqueInput[]
    disconnect?: Unlock_comicWhereUniqueInput | Unlock_comicWhereUniqueInput[]
    delete?: Unlock_comicWhereUniqueInput | Unlock_comicWhereUniqueInput[]
    connect?: Unlock_comicWhereUniqueInput | Unlock_comicWhereUniqueInput[]
    update?: Unlock_comicUpdateWithWhereUniqueWithoutComicInput | Unlock_comicUpdateWithWhereUniqueWithoutComicInput[]
    updateMany?: Unlock_comicUpdateManyWithWhereWithoutComicInput | Unlock_comicUpdateManyWithWhereWithoutComicInput[]
    deleteMany?: Unlock_comicScalarWhereInput | Unlock_comicScalarWhereInput[]
  }

  export type UsersUpdateOneRequiredWithoutComicsNestedInput = {
    create?: XOR<UsersCreateWithoutComicsInput, UsersUncheckedCreateWithoutComicsInput>
    connectOrCreate?: UsersCreateOrConnectWithoutComicsInput
    upsert?: UsersUpsertWithoutComicsInput
    connect?: UsersWhereUniqueInput
    update?: XOR<XOR<UsersUpdateToOneWithWhereWithoutComicsInput, UsersUpdateWithoutComicsInput>, UsersUncheckedUpdateWithoutComicsInput>
  }

  export type CategoriesUncheckedUpdateManyWithoutComicsNestedInput = {
    create?: XOR<CategoriesCreateWithoutComicsInput, CategoriesUncheckedCreateWithoutComicsInput> | CategoriesCreateWithoutComicsInput[] | CategoriesUncheckedCreateWithoutComicsInput[]
    connectOrCreate?: CategoriesCreateOrConnectWithoutComicsInput | CategoriesCreateOrConnectWithoutComicsInput[]
    upsert?: CategoriesUpsertWithWhereUniqueWithoutComicsInput | CategoriesUpsertWithWhereUniqueWithoutComicsInput[]
    set?: CategoriesWhereUniqueInput | CategoriesWhereUniqueInput[]
    disconnect?: CategoriesWhereUniqueInput | CategoriesWhereUniqueInput[]
    delete?: CategoriesWhereUniqueInput | CategoriesWhereUniqueInput[]
    connect?: CategoriesWhereUniqueInput | CategoriesWhereUniqueInput[]
    update?: CategoriesUpdateWithWhereUniqueWithoutComicsInput | CategoriesUpdateWithWhereUniqueWithoutComicsInput[]
    updateMany?: CategoriesUpdateManyWithWhereWithoutComicsInput | CategoriesUpdateManyWithWhereWithoutComicsInput[]
    deleteMany?: CategoriesScalarWhereInput | CategoriesScalarWhereInput[]
  }

  export type AuthorsUncheckedUpdateManyWithoutComicsNestedInput = {
    create?: XOR<AuthorsCreateWithoutComicsInput, AuthorsUncheckedCreateWithoutComicsInput> | AuthorsCreateWithoutComicsInput[] | AuthorsUncheckedCreateWithoutComicsInput[]
    connectOrCreate?: AuthorsCreateOrConnectWithoutComicsInput | AuthorsCreateOrConnectWithoutComicsInput[]
    upsert?: AuthorsUpsertWithWhereUniqueWithoutComicsInput | AuthorsUpsertWithWhereUniqueWithoutComicsInput[]
    set?: AuthorsWhereUniqueInput | AuthorsWhereUniqueInput[]
    disconnect?: AuthorsWhereUniqueInput | AuthorsWhereUniqueInput[]
    delete?: AuthorsWhereUniqueInput | AuthorsWhereUniqueInput[]
    connect?: AuthorsWhereUniqueInput | AuthorsWhereUniqueInput[]
    update?: AuthorsUpdateWithWhereUniqueWithoutComicsInput | AuthorsUpdateWithWhereUniqueWithoutComicsInput[]
    updateMany?: AuthorsUpdateManyWithWhereWithoutComicsInput | AuthorsUpdateManyWithWhereWithoutComicsInput[]
    deleteMany?: AuthorsScalarWhereInput | AuthorsScalarWhereInput[]
  }

  export type VolumesUncheckedUpdateManyWithoutComicNestedInput = {
    create?: XOR<VolumesCreateWithoutComicInput, VolumesUncheckedCreateWithoutComicInput> | VolumesCreateWithoutComicInput[] | VolumesUncheckedCreateWithoutComicInput[]
    connectOrCreate?: VolumesCreateOrConnectWithoutComicInput | VolumesCreateOrConnectWithoutComicInput[]
    upsert?: VolumesUpsertWithWhereUniqueWithoutComicInput | VolumesUpsertWithWhereUniqueWithoutComicInput[]
    createMany?: VolumesCreateManyComicInputEnvelope
    set?: VolumesWhereUniqueInput | VolumesWhereUniqueInput[]
    disconnect?: VolumesWhereUniqueInput | VolumesWhereUniqueInput[]
    delete?: VolumesWhereUniqueInput | VolumesWhereUniqueInput[]
    connect?: VolumesWhereUniqueInput | VolumesWhereUniqueInput[]
    update?: VolumesUpdateWithWhereUniqueWithoutComicInput | VolumesUpdateWithWhereUniqueWithoutComicInput[]
    updateMany?: VolumesUpdateManyWithWhereWithoutComicInput | VolumesUpdateManyWithWhereWithoutComicInput[]
    deleteMany?: VolumesScalarWhereInput | VolumesScalarWhereInput[]
  }

  export type FavoritesUncheckedUpdateManyWithoutComicNestedInput = {
    create?: XOR<FavoritesCreateWithoutComicInput, FavoritesUncheckedCreateWithoutComicInput> | FavoritesCreateWithoutComicInput[] | FavoritesUncheckedCreateWithoutComicInput[]
    connectOrCreate?: FavoritesCreateOrConnectWithoutComicInput | FavoritesCreateOrConnectWithoutComicInput[]
    upsert?: FavoritesUpsertWithWhereUniqueWithoutComicInput | FavoritesUpsertWithWhereUniqueWithoutComicInput[]
    createMany?: FavoritesCreateManyComicInputEnvelope
    set?: FavoritesWhereUniqueInput | FavoritesWhereUniqueInput[]
    disconnect?: FavoritesWhereUniqueInput | FavoritesWhereUniqueInput[]
    delete?: FavoritesWhereUniqueInput | FavoritesWhereUniqueInput[]
    connect?: FavoritesWhereUniqueInput | FavoritesWhereUniqueInput[]
    update?: FavoritesUpdateWithWhereUniqueWithoutComicInput | FavoritesUpdateWithWhereUniqueWithoutComicInput[]
    updateMany?: FavoritesUpdateManyWithWhereWithoutComicInput | FavoritesUpdateManyWithWhereWithoutComicInput[]
    deleteMany?: FavoritesScalarWhereInput | FavoritesScalarWhereInput[]
  }

  export type RatesUncheckedUpdateManyWithoutComicNestedInput = {
    create?: XOR<RatesCreateWithoutComicInput, RatesUncheckedCreateWithoutComicInput> | RatesCreateWithoutComicInput[] | RatesUncheckedCreateWithoutComicInput[]
    connectOrCreate?: RatesCreateOrConnectWithoutComicInput | RatesCreateOrConnectWithoutComicInput[]
    upsert?: RatesUpsertWithWhereUniqueWithoutComicInput | RatesUpsertWithWhereUniqueWithoutComicInput[]
    createMany?: RatesCreateManyComicInputEnvelope
    set?: RatesWhereUniqueInput | RatesWhereUniqueInput[]
    disconnect?: RatesWhereUniqueInput | RatesWhereUniqueInput[]
    delete?: RatesWhereUniqueInput | RatesWhereUniqueInput[]
    connect?: RatesWhereUniqueInput | RatesWhereUniqueInput[]
    update?: RatesUpdateWithWhereUniqueWithoutComicInput | RatesUpdateWithWhereUniqueWithoutComicInput[]
    updateMany?: RatesUpdateManyWithWhereWithoutComicInput | RatesUpdateManyWithWhereWithoutComicInput[]
    deleteMany?: RatesScalarWhereInput | RatesScalarWhereInput[]
  }

  export type ViewsUncheckedUpdateManyWithoutComicNestedInput = {
    create?: XOR<ViewsCreateWithoutComicInput, ViewsUncheckedCreateWithoutComicInput> | ViewsCreateWithoutComicInput[] | ViewsUncheckedCreateWithoutComicInput[]
    connectOrCreate?: ViewsCreateOrConnectWithoutComicInput | ViewsCreateOrConnectWithoutComicInput[]
    upsert?: ViewsUpsertWithWhereUniqueWithoutComicInput | ViewsUpsertWithWhereUniqueWithoutComicInput[]
    createMany?: ViewsCreateManyComicInputEnvelope
    set?: ViewsWhereUniqueInput | ViewsWhereUniqueInput[]
    disconnect?: ViewsWhereUniqueInput | ViewsWhereUniqueInput[]
    delete?: ViewsWhereUniqueInput | ViewsWhereUniqueInput[]
    connect?: ViewsWhereUniqueInput | ViewsWhereUniqueInput[]
    update?: ViewsUpdateWithWhereUniqueWithoutComicInput | ViewsUpdateWithWhereUniqueWithoutComicInput[]
    updateMany?: ViewsUpdateManyWithWhereWithoutComicInput | ViewsUpdateManyWithWhereWithoutComicInput[]
    deleteMany?: ViewsScalarWhereInput | ViewsScalarWhereInput[]
  }

  export type CommentsUncheckedUpdateManyWithoutComicNestedInput = {
    create?: XOR<CommentsCreateWithoutComicInput, CommentsUncheckedCreateWithoutComicInput> | CommentsCreateWithoutComicInput[] | CommentsUncheckedCreateWithoutComicInput[]
    connectOrCreate?: CommentsCreateOrConnectWithoutComicInput | CommentsCreateOrConnectWithoutComicInput[]
    upsert?: CommentsUpsertWithWhereUniqueWithoutComicInput | CommentsUpsertWithWhereUniqueWithoutComicInput[]
    createMany?: CommentsCreateManyComicInputEnvelope
    set?: CommentsWhereUniqueInput | CommentsWhereUniqueInput[]
    disconnect?: CommentsWhereUniqueInput | CommentsWhereUniqueInput[]
    delete?: CommentsWhereUniqueInput | CommentsWhereUniqueInput[]
    connect?: CommentsWhereUniqueInput | CommentsWhereUniqueInput[]
    update?: CommentsUpdateWithWhereUniqueWithoutComicInput | CommentsUpdateWithWhereUniqueWithoutComicInput[]
    updateMany?: CommentsUpdateManyWithWhereWithoutComicInput | CommentsUpdateManyWithWhereWithoutComicInput[]
    deleteMany?: CommentsScalarWhereInput | CommentsScalarWhereInput[]
  }

  export type Unlock_comicUncheckedUpdateManyWithoutComicNestedInput = {
    create?: XOR<Unlock_comicCreateWithoutComicInput, Unlock_comicUncheckedCreateWithoutComicInput> | Unlock_comicCreateWithoutComicInput[] | Unlock_comicUncheckedCreateWithoutComicInput[]
    connectOrCreate?: Unlock_comicCreateOrConnectWithoutComicInput | Unlock_comicCreateOrConnectWithoutComicInput[]
    upsert?: Unlock_comicUpsertWithWhereUniqueWithoutComicInput | Unlock_comicUpsertWithWhereUniqueWithoutComicInput[]
    createMany?: Unlock_comicCreateManyComicInputEnvelope
    set?: Unlock_comicWhereUniqueInput | Unlock_comicWhereUniqueInput[]
    disconnect?: Unlock_comicWhereUniqueInput | Unlock_comicWhereUniqueInput[]
    delete?: Unlock_comicWhereUniqueInput | Unlock_comicWhereUniqueInput[]
    connect?: Unlock_comicWhereUniqueInput | Unlock_comicWhereUniqueInput[]
    update?: Unlock_comicUpdateWithWhereUniqueWithoutComicInput | Unlock_comicUpdateWithWhereUniqueWithoutComicInput[]
    updateMany?: Unlock_comicUpdateManyWithWhereWithoutComicInput | Unlock_comicUpdateManyWithWhereWithoutComicInput[]
    deleteMany?: Unlock_comicScalarWhereInput | Unlock_comicScalarWhereInput[]
  }

  export type ComicsCreateNestedOneWithoutVolumesInput = {
    create?: XOR<ComicsCreateWithoutVolumesInput, ComicsUncheckedCreateWithoutVolumesInput>
    connectOrCreate?: ComicsCreateOrConnectWithoutVolumesInput
    connect?: ComicsWhereUniqueInput
  }

  export type ChaptersCreateNestedManyWithoutVolumeInput = {
    create?: XOR<ChaptersCreateWithoutVolumeInput, ChaptersUncheckedCreateWithoutVolumeInput> | ChaptersCreateWithoutVolumeInput[] | ChaptersUncheckedCreateWithoutVolumeInput[]
    connectOrCreate?: ChaptersCreateOrConnectWithoutVolumeInput | ChaptersCreateOrConnectWithoutVolumeInput[]
    createMany?: ChaptersCreateManyVolumeInputEnvelope
    connect?: ChaptersWhereUniqueInput | ChaptersWhereUniqueInput[]
  }

  export type Unlock_volumeCreateNestedManyWithoutVolumeInput = {
    create?: XOR<Unlock_volumeCreateWithoutVolumeInput, Unlock_volumeUncheckedCreateWithoutVolumeInput> | Unlock_volumeCreateWithoutVolumeInput[] | Unlock_volumeUncheckedCreateWithoutVolumeInput[]
    connectOrCreate?: Unlock_volumeCreateOrConnectWithoutVolumeInput | Unlock_volumeCreateOrConnectWithoutVolumeInput[]
    createMany?: Unlock_volumeCreateManyVolumeInputEnvelope
    connect?: Unlock_volumeWhereUniqueInput | Unlock_volumeWhereUniqueInput[]
  }

  export type ChaptersUncheckedCreateNestedManyWithoutVolumeInput = {
    create?: XOR<ChaptersCreateWithoutVolumeInput, ChaptersUncheckedCreateWithoutVolumeInput> | ChaptersCreateWithoutVolumeInput[] | ChaptersUncheckedCreateWithoutVolumeInput[]
    connectOrCreate?: ChaptersCreateOrConnectWithoutVolumeInput | ChaptersCreateOrConnectWithoutVolumeInput[]
    createMany?: ChaptersCreateManyVolumeInputEnvelope
    connect?: ChaptersWhereUniqueInput | ChaptersWhereUniqueInput[]
  }

  export type Unlock_volumeUncheckedCreateNestedManyWithoutVolumeInput = {
    create?: XOR<Unlock_volumeCreateWithoutVolumeInput, Unlock_volumeUncheckedCreateWithoutVolumeInput> | Unlock_volumeCreateWithoutVolumeInput[] | Unlock_volumeUncheckedCreateWithoutVolumeInput[]
    connectOrCreate?: Unlock_volumeCreateOrConnectWithoutVolumeInput | Unlock_volumeCreateOrConnectWithoutVolumeInput[]
    createMany?: Unlock_volumeCreateManyVolumeInputEnvelope
    connect?: Unlock_volumeWhereUniqueInput | Unlock_volumeWhereUniqueInput[]
  }

  export type ComicsUpdateOneRequiredWithoutVolumesNestedInput = {
    create?: XOR<ComicsCreateWithoutVolumesInput, ComicsUncheckedCreateWithoutVolumesInput>
    connectOrCreate?: ComicsCreateOrConnectWithoutVolumesInput
    upsert?: ComicsUpsertWithoutVolumesInput
    connect?: ComicsWhereUniqueInput
    update?: XOR<XOR<ComicsUpdateToOneWithWhereWithoutVolumesInput, ComicsUpdateWithoutVolumesInput>, ComicsUncheckedUpdateWithoutVolumesInput>
  }

  export type ChaptersUpdateManyWithoutVolumeNestedInput = {
    create?: XOR<ChaptersCreateWithoutVolumeInput, ChaptersUncheckedCreateWithoutVolumeInput> | ChaptersCreateWithoutVolumeInput[] | ChaptersUncheckedCreateWithoutVolumeInput[]
    connectOrCreate?: ChaptersCreateOrConnectWithoutVolumeInput | ChaptersCreateOrConnectWithoutVolumeInput[]
    upsert?: ChaptersUpsertWithWhereUniqueWithoutVolumeInput | ChaptersUpsertWithWhereUniqueWithoutVolumeInput[]
    createMany?: ChaptersCreateManyVolumeInputEnvelope
    set?: ChaptersWhereUniqueInput | ChaptersWhereUniqueInput[]
    disconnect?: ChaptersWhereUniqueInput | ChaptersWhereUniqueInput[]
    delete?: ChaptersWhereUniqueInput | ChaptersWhereUniqueInput[]
    connect?: ChaptersWhereUniqueInput | ChaptersWhereUniqueInput[]
    update?: ChaptersUpdateWithWhereUniqueWithoutVolumeInput | ChaptersUpdateWithWhereUniqueWithoutVolumeInput[]
    updateMany?: ChaptersUpdateManyWithWhereWithoutVolumeInput | ChaptersUpdateManyWithWhereWithoutVolumeInput[]
    deleteMany?: ChaptersScalarWhereInput | ChaptersScalarWhereInput[]
  }

  export type Unlock_volumeUpdateManyWithoutVolumeNestedInput = {
    create?: XOR<Unlock_volumeCreateWithoutVolumeInput, Unlock_volumeUncheckedCreateWithoutVolumeInput> | Unlock_volumeCreateWithoutVolumeInput[] | Unlock_volumeUncheckedCreateWithoutVolumeInput[]
    connectOrCreate?: Unlock_volumeCreateOrConnectWithoutVolumeInput | Unlock_volumeCreateOrConnectWithoutVolumeInput[]
    upsert?: Unlock_volumeUpsertWithWhereUniqueWithoutVolumeInput | Unlock_volumeUpsertWithWhereUniqueWithoutVolumeInput[]
    createMany?: Unlock_volumeCreateManyVolumeInputEnvelope
    set?: Unlock_volumeWhereUniqueInput | Unlock_volumeWhereUniqueInput[]
    disconnect?: Unlock_volumeWhereUniqueInput | Unlock_volumeWhereUniqueInput[]
    delete?: Unlock_volumeWhereUniqueInput | Unlock_volumeWhereUniqueInput[]
    connect?: Unlock_volumeWhereUniqueInput | Unlock_volumeWhereUniqueInput[]
    update?: Unlock_volumeUpdateWithWhereUniqueWithoutVolumeInput | Unlock_volumeUpdateWithWhereUniqueWithoutVolumeInput[]
    updateMany?: Unlock_volumeUpdateManyWithWhereWithoutVolumeInput | Unlock_volumeUpdateManyWithWhereWithoutVolumeInput[]
    deleteMany?: Unlock_volumeScalarWhereInput | Unlock_volumeScalarWhereInput[]
  }

  export type ChaptersUncheckedUpdateManyWithoutVolumeNestedInput = {
    create?: XOR<ChaptersCreateWithoutVolumeInput, ChaptersUncheckedCreateWithoutVolumeInput> | ChaptersCreateWithoutVolumeInput[] | ChaptersUncheckedCreateWithoutVolumeInput[]
    connectOrCreate?: ChaptersCreateOrConnectWithoutVolumeInput | ChaptersCreateOrConnectWithoutVolumeInput[]
    upsert?: ChaptersUpsertWithWhereUniqueWithoutVolumeInput | ChaptersUpsertWithWhereUniqueWithoutVolumeInput[]
    createMany?: ChaptersCreateManyVolumeInputEnvelope
    set?: ChaptersWhereUniqueInput | ChaptersWhereUniqueInput[]
    disconnect?: ChaptersWhereUniqueInput | ChaptersWhereUniqueInput[]
    delete?: ChaptersWhereUniqueInput | ChaptersWhereUniqueInput[]
    connect?: ChaptersWhereUniqueInput | ChaptersWhereUniqueInput[]
    update?: ChaptersUpdateWithWhereUniqueWithoutVolumeInput | ChaptersUpdateWithWhereUniqueWithoutVolumeInput[]
    updateMany?: ChaptersUpdateManyWithWhereWithoutVolumeInput | ChaptersUpdateManyWithWhereWithoutVolumeInput[]
    deleteMany?: ChaptersScalarWhereInput | ChaptersScalarWhereInput[]
  }

  export type Unlock_volumeUncheckedUpdateManyWithoutVolumeNestedInput = {
    create?: XOR<Unlock_volumeCreateWithoutVolumeInput, Unlock_volumeUncheckedCreateWithoutVolumeInput> | Unlock_volumeCreateWithoutVolumeInput[] | Unlock_volumeUncheckedCreateWithoutVolumeInput[]
    connectOrCreate?: Unlock_volumeCreateOrConnectWithoutVolumeInput | Unlock_volumeCreateOrConnectWithoutVolumeInput[]
    upsert?: Unlock_volumeUpsertWithWhereUniqueWithoutVolumeInput | Unlock_volumeUpsertWithWhereUniqueWithoutVolumeInput[]
    createMany?: Unlock_volumeCreateManyVolumeInputEnvelope
    set?: Unlock_volumeWhereUniqueInput | Unlock_volumeWhereUniqueInput[]
    disconnect?: Unlock_volumeWhereUniqueInput | Unlock_volumeWhereUniqueInput[]
    delete?: Unlock_volumeWhereUniqueInput | Unlock_volumeWhereUniqueInput[]
    connect?: Unlock_volumeWhereUniqueInput | Unlock_volumeWhereUniqueInput[]
    update?: Unlock_volumeUpdateWithWhereUniqueWithoutVolumeInput | Unlock_volumeUpdateWithWhereUniqueWithoutVolumeInput[]
    updateMany?: Unlock_volumeUpdateManyWithWhereWithoutVolumeInput | Unlock_volumeUpdateManyWithWhereWithoutVolumeInput[]
    deleteMany?: Unlock_volumeScalarWhereInput | Unlock_volumeScalarWhereInput[]
  }

  export type VolumesCreateNestedOneWithoutChaptersInput = {
    create?: XOR<VolumesCreateWithoutChaptersInput, VolumesUncheckedCreateWithoutChaptersInput>
    connectOrCreate?: VolumesCreateOrConnectWithoutChaptersInput
    connect?: VolumesWhereUniqueInput
  }

  export type ErrorsCreateNestedManyWithoutChapterInput = {
    create?: XOR<ErrorsCreateWithoutChapterInput, ErrorsUncheckedCreateWithoutChapterInput> | ErrorsCreateWithoutChapterInput[] | ErrorsUncheckedCreateWithoutChapterInput[]
    connectOrCreate?: ErrorsCreateOrConnectWithoutChapterInput | ErrorsCreateOrConnectWithoutChapterInput[]
    createMany?: ErrorsCreateManyChapterInputEnvelope
    connect?: ErrorsWhereUniqueInput | ErrorsWhereUniqueInput[]
  }

  export type ViewsCreateNestedManyWithoutChapterInput = {
    create?: XOR<ViewsCreateWithoutChapterInput, ViewsUncheckedCreateWithoutChapterInput> | ViewsCreateWithoutChapterInput[] | ViewsUncheckedCreateWithoutChapterInput[]
    connectOrCreate?: ViewsCreateOrConnectWithoutChapterInput | ViewsCreateOrConnectWithoutChapterInput[]
    createMany?: ViewsCreateManyChapterInputEnvelope
    connect?: ViewsWhereUniqueInput | ViewsWhereUniqueInput[]
  }

  export type CommentsCreateNestedManyWithoutChapterInput = {
    create?: XOR<CommentsCreateWithoutChapterInput, CommentsUncheckedCreateWithoutChapterInput> | CommentsCreateWithoutChapterInput[] | CommentsUncheckedCreateWithoutChapterInput[]
    connectOrCreate?: CommentsCreateOrConnectWithoutChapterInput | CommentsCreateOrConnectWithoutChapterInput[]
    createMany?: CommentsCreateManyChapterInputEnvelope
    connect?: CommentsWhereUniqueInput | CommentsWhereUniqueInput[]
  }

  export type Unlock_chapterCreateNestedManyWithoutChapterInput = {
    create?: XOR<Unlock_chapterCreateWithoutChapterInput, Unlock_chapterUncheckedCreateWithoutChapterInput> | Unlock_chapterCreateWithoutChapterInput[] | Unlock_chapterUncheckedCreateWithoutChapterInput[]
    connectOrCreate?: Unlock_chapterCreateOrConnectWithoutChapterInput | Unlock_chapterCreateOrConnectWithoutChapterInput[]
    createMany?: Unlock_chapterCreateManyChapterInputEnvelope
    connect?: Unlock_chapterWhereUniqueInput | Unlock_chapterWhereUniqueInput[]
  }

  export type ErrorsUncheckedCreateNestedManyWithoutChapterInput = {
    create?: XOR<ErrorsCreateWithoutChapterInput, ErrorsUncheckedCreateWithoutChapterInput> | ErrorsCreateWithoutChapterInput[] | ErrorsUncheckedCreateWithoutChapterInput[]
    connectOrCreate?: ErrorsCreateOrConnectWithoutChapterInput | ErrorsCreateOrConnectWithoutChapterInput[]
    createMany?: ErrorsCreateManyChapterInputEnvelope
    connect?: ErrorsWhereUniqueInput | ErrorsWhereUniqueInput[]
  }

  export type ViewsUncheckedCreateNestedManyWithoutChapterInput = {
    create?: XOR<ViewsCreateWithoutChapterInput, ViewsUncheckedCreateWithoutChapterInput> | ViewsCreateWithoutChapterInput[] | ViewsUncheckedCreateWithoutChapterInput[]
    connectOrCreate?: ViewsCreateOrConnectWithoutChapterInput | ViewsCreateOrConnectWithoutChapterInput[]
    createMany?: ViewsCreateManyChapterInputEnvelope
    connect?: ViewsWhereUniqueInput | ViewsWhereUniqueInput[]
  }

  export type CommentsUncheckedCreateNestedManyWithoutChapterInput = {
    create?: XOR<CommentsCreateWithoutChapterInput, CommentsUncheckedCreateWithoutChapterInput> | CommentsCreateWithoutChapterInput[] | CommentsUncheckedCreateWithoutChapterInput[]
    connectOrCreate?: CommentsCreateOrConnectWithoutChapterInput | CommentsCreateOrConnectWithoutChapterInput[]
    createMany?: CommentsCreateManyChapterInputEnvelope
    connect?: CommentsWhereUniqueInput | CommentsWhereUniqueInput[]
  }

  export type Unlock_chapterUncheckedCreateNestedManyWithoutChapterInput = {
    create?: XOR<Unlock_chapterCreateWithoutChapterInput, Unlock_chapterUncheckedCreateWithoutChapterInput> | Unlock_chapterCreateWithoutChapterInput[] | Unlock_chapterUncheckedCreateWithoutChapterInput[]
    connectOrCreate?: Unlock_chapterCreateOrConnectWithoutChapterInput | Unlock_chapterCreateOrConnectWithoutChapterInput[]
    createMany?: Unlock_chapterCreateManyChapterInputEnvelope
    connect?: Unlock_chapterWhereUniqueInput | Unlock_chapterWhereUniqueInput[]
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type VolumesUpdateOneRequiredWithoutChaptersNestedInput = {
    create?: XOR<VolumesCreateWithoutChaptersInput, VolumesUncheckedCreateWithoutChaptersInput>
    connectOrCreate?: VolumesCreateOrConnectWithoutChaptersInput
    upsert?: VolumesUpsertWithoutChaptersInput
    connect?: VolumesWhereUniqueInput
    update?: XOR<XOR<VolumesUpdateToOneWithWhereWithoutChaptersInput, VolumesUpdateWithoutChaptersInput>, VolumesUncheckedUpdateWithoutChaptersInput>
  }

  export type ErrorsUpdateManyWithoutChapterNestedInput = {
    create?: XOR<ErrorsCreateWithoutChapterInput, ErrorsUncheckedCreateWithoutChapterInput> | ErrorsCreateWithoutChapterInput[] | ErrorsUncheckedCreateWithoutChapterInput[]
    connectOrCreate?: ErrorsCreateOrConnectWithoutChapterInput | ErrorsCreateOrConnectWithoutChapterInput[]
    upsert?: ErrorsUpsertWithWhereUniqueWithoutChapterInput | ErrorsUpsertWithWhereUniqueWithoutChapterInput[]
    createMany?: ErrorsCreateManyChapterInputEnvelope
    set?: ErrorsWhereUniqueInput | ErrorsWhereUniqueInput[]
    disconnect?: ErrorsWhereUniqueInput | ErrorsWhereUniqueInput[]
    delete?: ErrorsWhereUniqueInput | ErrorsWhereUniqueInput[]
    connect?: ErrorsWhereUniqueInput | ErrorsWhereUniqueInput[]
    update?: ErrorsUpdateWithWhereUniqueWithoutChapterInput | ErrorsUpdateWithWhereUniqueWithoutChapterInput[]
    updateMany?: ErrorsUpdateManyWithWhereWithoutChapterInput | ErrorsUpdateManyWithWhereWithoutChapterInput[]
    deleteMany?: ErrorsScalarWhereInput | ErrorsScalarWhereInput[]
  }

  export type ViewsUpdateManyWithoutChapterNestedInput = {
    create?: XOR<ViewsCreateWithoutChapterInput, ViewsUncheckedCreateWithoutChapterInput> | ViewsCreateWithoutChapterInput[] | ViewsUncheckedCreateWithoutChapterInput[]
    connectOrCreate?: ViewsCreateOrConnectWithoutChapterInput | ViewsCreateOrConnectWithoutChapterInput[]
    upsert?: ViewsUpsertWithWhereUniqueWithoutChapterInput | ViewsUpsertWithWhereUniqueWithoutChapterInput[]
    createMany?: ViewsCreateManyChapterInputEnvelope
    set?: ViewsWhereUniqueInput | ViewsWhereUniqueInput[]
    disconnect?: ViewsWhereUniqueInput | ViewsWhereUniqueInput[]
    delete?: ViewsWhereUniqueInput | ViewsWhereUniqueInput[]
    connect?: ViewsWhereUniqueInput | ViewsWhereUniqueInput[]
    update?: ViewsUpdateWithWhereUniqueWithoutChapterInput | ViewsUpdateWithWhereUniqueWithoutChapterInput[]
    updateMany?: ViewsUpdateManyWithWhereWithoutChapterInput | ViewsUpdateManyWithWhereWithoutChapterInput[]
    deleteMany?: ViewsScalarWhereInput | ViewsScalarWhereInput[]
  }

  export type CommentsUpdateManyWithoutChapterNestedInput = {
    create?: XOR<CommentsCreateWithoutChapterInput, CommentsUncheckedCreateWithoutChapterInput> | CommentsCreateWithoutChapterInput[] | CommentsUncheckedCreateWithoutChapterInput[]
    connectOrCreate?: CommentsCreateOrConnectWithoutChapterInput | CommentsCreateOrConnectWithoutChapterInput[]
    upsert?: CommentsUpsertWithWhereUniqueWithoutChapterInput | CommentsUpsertWithWhereUniqueWithoutChapterInput[]
    createMany?: CommentsCreateManyChapterInputEnvelope
    set?: CommentsWhereUniqueInput | CommentsWhereUniqueInput[]
    disconnect?: CommentsWhereUniqueInput | CommentsWhereUniqueInput[]
    delete?: CommentsWhereUniqueInput | CommentsWhereUniqueInput[]
    connect?: CommentsWhereUniqueInput | CommentsWhereUniqueInput[]
    update?: CommentsUpdateWithWhereUniqueWithoutChapterInput | CommentsUpdateWithWhereUniqueWithoutChapterInput[]
    updateMany?: CommentsUpdateManyWithWhereWithoutChapterInput | CommentsUpdateManyWithWhereWithoutChapterInput[]
    deleteMany?: CommentsScalarWhereInput | CommentsScalarWhereInput[]
  }

  export type Unlock_chapterUpdateManyWithoutChapterNestedInput = {
    create?: XOR<Unlock_chapterCreateWithoutChapterInput, Unlock_chapterUncheckedCreateWithoutChapterInput> | Unlock_chapterCreateWithoutChapterInput[] | Unlock_chapterUncheckedCreateWithoutChapterInput[]
    connectOrCreate?: Unlock_chapterCreateOrConnectWithoutChapterInput | Unlock_chapterCreateOrConnectWithoutChapterInput[]
    upsert?: Unlock_chapterUpsertWithWhereUniqueWithoutChapterInput | Unlock_chapterUpsertWithWhereUniqueWithoutChapterInput[]
    createMany?: Unlock_chapterCreateManyChapterInputEnvelope
    set?: Unlock_chapterWhereUniqueInput | Unlock_chapterWhereUniqueInput[]
    disconnect?: Unlock_chapterWhereUniqueInput | Unlock_chapterWhereUniqueInput[]
    delete?: Unlock_chapterWhereUniqueInput | Unlock_chapterWhereUniqueInput[]
    connect?: Unlock_chapterWhereUniqueInput | Unlock_chapterWhereUniqueInput[]
    update?: Unlock_chapterUpdateWithWhereUniqueWithoutChapterInput | Unlock_chapterUpdateWithWhereUniqueWithoutChapterInput[]
    updateMany?: Unlock_chapterUpdateManyWithWhereWithoutChapterInput | Unlock_chapterUpdateManyWithWhereWithoutChapterInput[]
    deleteMany?: Unlock_chapterScalarWhereInput | Unlock_chapterScalarWhereInput[]
  }

  export type ErrorsUncheckedUpdateManyWithoutChapterNestedInput = {
    create?: XOR<ErrorsCreateWithoutChapterInput, ErrorsUncheckedCreateWithoutChapterInput> | ErrorsCreateWithoutChapterInput[] | ErrorsUncheckedCreateWithoutChapterInput[]
    connectOrCreate?: ErrorsCreateOrConnectWithoutChapterInput | ErrorsCreateOrConnectWithoutChapterInput[]
    upsert?: ErrorsUpsertWithWhereUniqueWithoutChapterInput | ErrorsUpsertWithWhereUniqueWithoutChapterInput[]
    createMany?: ErrorsCreateManyChapterInputEnvelope
    set?: ErrorsWhereUniqueInput | ErrorsWhereUniqueInput[]
    disconnect?: ErrorsWhereUniqueInput | ErrorsWhereUniqueInput[]
    delete?: ErrorsWhereUniqueInput | ErrorsWhereUniqueInput[]
    connect?: ErrorsWhereUniqueInput | ErrorsWhereUniqueInput[]
    update?: ErrorsUpdateWithWhereUniqueWithoutChapterInput | ErrorsUpdateWithWhereUniqueWithoutChapterInput[]
    updateMany?: ErrorsUpdateManyWithWhereWithoutChapterInput | ErrorsUpdateManyWithWhereWithoutChapterInput[]
    deleteMany?: ErrorsScalarWhereInput | ErrorsScalarWhereInput[]
  }

  export type ViewsUncheckedUpdateManyWithoutChapterNestedInput = {
    create?: XOR<ViewsCreateWithoutChapterInput, ViewsUncheckedCreateWithoutChapterInput> | ViewsCreateWithoutChapterInput[] | ViewsUncheckedCreateWithoutChapterInput[]
    connectOrCreate?: ViewsCreateOrConnectWithoutChapterInput | ViewsCreateOrConnectWithoutChapterInput[]
    upsert?: ViewsUpsertWithWhereUniqueWithoutChapterInput | ViewsUpsertWithWhereUniqueWithoutChapterInput[]
    createMany?: ViewsCreateManyChapterInputEnvelope
    set?: ViewsWhereUniqueInput | ViewsWhereUniqueInput[]
    disconnect?: ViewsWhereUniqueInput | ViewsWhereUniqueInput[]
    delete?: ViewsWhereUniqueInput | ViewsWhereUniqueInput[]
    connect?: ViewsWhereUniqueInput | ViewsWhereUniqueInput[]
    update?: ViewsUpdateWithWhereUniqueWithoutChapterInput | ViewsUpdateWithWhereUniqueWithoutChapterInput[]
    updateMany?: ViewsUpdateManyWithWhereWithoutChapterInput | ViewsUpdateManyWithWhereWithoutChapterInput[]
    deleteMany?: ViewsScalarWhereInput | ViewsScalarWhereInput[]
  }

  export type CommentsUncheckedUpdateManyWithoutChapterNestedInput = {
    create?: XOR<CommentsCreateWithoutChapterInput, CommentsUncheckedCreateWithoutChapterInput> | CommentsCreateWithoutChapterInput[] | CommentsUncheckedCreateWithoutChapterInput[]
    connectOrCreate?: CommentsCreateOrConnectWithoutChapterInput | CommentsCreateOrConnectWithoutChapterInput[]
    upsert?: CommentsUpsertWithWhereUniqueWithoutChapterInput | CommentsUpsertWithWhereUniqueWithoutChapterInput[]
    createMany?: CommentsCreateManyChapterInputEnvelope
    set?: CommentsWhereUniqueInput | CommentsWhereUniqueInput[]
    disconnect?: CommentsWhereUniqueInput | CommentsWhereUniqueInput[]
    delete?: CommentsWhereUniqueInput | CommentsWhereUniqueInput[]
    connect?: CommentsWhereUniqueInput | CommentsWhereUniqueInput[]
    update?: CommentsUpdateWithWhereUniqueWithoutChapterInput | CommentsUpdateWithWhereUniqueWithoutChapterInput[]
    updateMany?: CommentsUpdateManyWithWhereWithoutChapterInput | CommentsUpdateManyWithWhereWithoutChapterInput[]
    deleteMany?: CommentsScalarWhereInput | CommentsScalarWhereInput[]
  }

  export type Unlock_chapterUncheckedUpdateManyWithoutChapterNestedInput = {
    create?: XOR<Unlock_chapterCreateWithoutChapterInput, Unlock_chapterUncheckedCreateWithoutChapterInput> | Unlock_chapterCreateWithoutChapterInput[] | Unlock_chapterUncheckedCreateWithoutChapterInput[]
    connectOrCreate?: Unlock_chapterCreateOrConnectWithoutChapterInput | Unlock_chapterCreateOrConnectWithoutChapterInput[]
    upsert?: Unlock_chapterUpsertWithWhereUniqueWithoutChapterInput | Unlock_chapterUpsertWithWhereUniqueWithoutChapterInput[]
    createMany?: Unlock_chapterCreateManyChapterInputEnvelope
    set?: Unlock_chapterWhereUniqueInput | Unlock_chapterWhereUniqueInput[]
    disconnect?: Unlock_chapterWhereUniqueInput | Unlock_chapterWhereUniqueInput[]
    delete?: Unlock_chapterWhereUniqueInput | Unlock_chapterWhereUniqueInput[]
    connect?: Unlock_chapterWhereUniqueInput | Unlock_chapterWhereUniqueInput[]
    update?: Unlock_chapterUpdateWithWhereUniqueWithoutChapterInput | Unlock_chapterUpdateWithWhereUniqueWithoutChapterInput[]
    updateMany?: Unlock_chapterUpdateManyWithWhereWithoutChapterInput | Unlock_chapterUpdateManyWithWhereWithoutChapterInput[]
    deleteMany?: Unlock_chapterScalarWhereInput | Unlock_chapterScalarWhereInput[]
  }

  export type UsersCreateNestedManyWithoutUserRoleInput = {
    create?: XOR<UsersCreateWithoutUserRoleInput, UsersUncheckedCreateWithoutUserRoleInput> | UsersCreateWithoutUserRoleInput[] | UsersUncheckedCreateWithoutUserRoleInput[]
    connectOrCreate?: UsersCreateOrConnectWithoutUserRoleInput | UsersCreateOrConnectWithoutUserRoleInput[]
    connect?: UsersWhereUniqueInput | UsersWhereUniqueInput[]
  }

  export type UsersUncheckedCreateNestedManyWithoutUserRoleInput = {
    create?: XOR<UsersCreateWithoutUserRoleInput, UsersUncheckedCreateWithoutUserRoleInput> | UsersCreateWithoutUserRoleInput[] | UsersUncheckedCreateWithoutUserRoleInput[]
    connectOrCreate?: UsersCreateOrConnectWithoutUserRoleInput | UsersCreateOrConnectWithoutUserRoleInput[]
    connect?: UsersWhereUniqueInput | UsersWhereUniqueInput[]
  }

  export type UsersUpdateManyWithoutUserRoleNestedInput = {
    create?: XOR<UsersCreateWithoutUserRoleInput, UsersUncheckedCreateWithoutUserRoleInput> | UsersCreateWithoutUserRoleInput[] | UsersUncheckedCreateWithoutUserRoleInput[]
    connectOrCreate?: UsersCreateOrConnectWithoutUserRoleInput | UsersCreateOrConnectWithoutUserRoleInput[]
    upsert?: UsersUpsertWithWhereUniqueWithoutUserRoleInput | UsersUpsertWithWhereUniqueWithoutUserRoleInput[]
    set?: UsersWhereUniqueInput | UsersWhereUniqueInput[]
    disconnect?: UsersWhereUniqueInput | UsersWhereUniqueInput[]
    delete?: UsersWhereUniqueInput | UsersWhereUniqueInput[]
    connect?: UsersWhereUniqueInput | UsersWhereUniqueInput[]
    update?: UsersUpdateWithWhereUniqueWithoutUserRoleInput | UsersUpdateWithWhereUniqueWithoutUserRoleInput[]
    updateMany?: UsersUpdateManyWithWhereWithoutUserRoleInput | UsersUpdateManyWithWhereWithoutUserRoleInput[]
    deleteMany?: UsersScalarWhereInput | UsersScalarWhereInput[]
  }

  export type UsersUncheckedUpdateManyWithoutUserRoleNestedInput = {
    create?: XOR<UsersCreateWithoutUserRoleInput, UsersUncheckedCreateWithoutUserRoleInput> | UsersCreateWithoutUserRoleInput[] | UsersUncheckedCreateWithoutUserRoleInput[]
    connectOrCreate?: UsersCreateOrConnectWithoutUserRoleInput | UsersCreateOrConnectWithoutUserRoleInput[]
    upsert?: UsersUpsertWithWhereUniqueWithoutUserRoleInput | UsersUpsertWithWhereUniqueWithoutUserRoleInput[]
    set?: UsersWhereUniqueInput | UsersWhereUniqueInput[]
    disconnect?: UsersWhereUniqueInput | UsersWhereUniqueInput[]
    delete?: UsersWhereUniqueInput | UsersWhereUniqueInput[]
    connect?: UsersWhereUniqueInput | UsersWhereUniqueInput[]
    update?: UsersUpdateWithWhereUniqueWithoutUserRoleInput | UsersUpdateWithWhereUniqueWithoutUserRoleInput[]
    updateMany?: UsersUpdateManyWithWhereWithoutUserRoleInput | UsersUpdateManyWithWhereWithoutUserRoleInput[]
    deleteMany?: UsersScalarWhereInput | UsersScalarWhereInput[]
  }

  export type ComicsCreateNestedManyWithoutUserInput = {
    create?: XOR<ComicsCreateWithoutUserInput, ComicsUncheckedCreateWithoutUserInput> | ComicsCreateWithoutUserInput[] | ComicsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ComicsCreateOrConnectWithoutUserInput | ComicsCreateOrConnectWithoutUserInput[]
    createMany?: ComicsCreateManyUserInputEnvelope
    connect?: ComicsWhereUniqueInput | ComicsWhereUniqueInput[]
  }

  export type RolesCreateNestedManyWithoutUsersInput = {
    create?: XOR<RolesCreateWithoutUsersInput, RolesUncheckedCreateWithoutUsersInput> | RolesCreateWithoutUsersInput[] | RolesUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: RolesCreateOrConnectWithoutUsersInput | RolesCreateOrConnectWithoutUsersInput[]
    connect?: RolesWhereUniqueInput | RolesWhereUniqueInput[]
  }

  export type FavoritesCreateNestedManyWithoutUserInput = {
    create?: XOR<FavoritesCreateWithoutUserInput, FavoritesUncheckedCreateWithoutUserInput> | FavoritesCreateWithoutUserInput[] | FavoritesUncheckedCreateWithoutUserInput[]
    connectOrCreate?: FavoritesCreateOrConnectWithoutUserInput | FavoritesCreateOrConnectWithoutUserInput[]
    createMany?: FavoritesCreateManyUserInputEnvelope
    connect?: FavoritesWhereUniqueInput | FavoritesWhereUniqueInput[]
  }

  export type RatesCreateNestedManyWithoutUserInput = {
    create?: XOR<RatesCreateWithoutUserInput, RatesUncheckedCreateWithoutUserInput> | RatesCreateWithoutUserInput[] | RatesUncheckedCreateWithoutUserInput[]
    connectOrCreate?: RatesCreateOrConnectWithoutUserInput | RatesCreateOrConnectWithoutUserInput[]
    createMany?: RatesCreateManyUserInputEnvelope
    connect?: RatesWhereUniqueInput | RatesWhereUniqueInput[]
  }

  export type ErrorsCreateNestedManyWithoutUserInput = {
    create?: XOR<ErrorsCreateWithoutUserInput, ErrorsUncheckedCreateWithoutUserInput> | ErrorsCreateWithoutUserInput[] | ErrorsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ErrorsCreateOrConnectWithoutUserInput | ErrorsCreateOrConnectWithoutUserInput[]
    createMany?: ErrorsCreateManyUserInputEnvelope
    connect?: ErrorsWhereUniqueInput | ErrorsWhereUniqueInput[]
  }

  export type ViewsCreateNestedManyWithoutUserInput = {
    create?: XOR<ViewsCreateWithoutUserInput, ViewsUncheckedCreateWithoutUserInput> | ViewsCreateWithoutUserInput[] | ViewsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ViewsCreateOrConnectWithoutUserInput | ViewsCreateOrConnectWithoutUserInput[]
    createMany?: ViewsCreateManyUserInputEnvelope
    connect?: ViewsWhereUniqueInput | ViewsWhereUniqueInput[]
  }

  export type CommentsCreateNestedManyWithoutUserInput = {
    create?: XOR<CommentsCreateWithoutUserInput, CommentsUncheckedCreateWithoutUserInput> | CommentsCreateWithoutUserInput[] | CommentsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CommentsCreateOrConnectWithoutUserInput | CommentsCreateOrConnectWithoutUserInput[]
    createMany?: CommentsCreateManyUserInputEnvelope
    connect?: CommentsWhereUniqueInput | CommentsWhereUniqueInput[]
  }

  export type NotificationsCreateNestedManyWithoutUserInput = {
    create?: XOR<NotificationsCreateWithoutUserInput, NotificationsUncheckedCreateWithoutUserInput> | NotificationsCreateWithoutUserInput[] | NotificationsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationsCreateOrConnectWithoutUserInput | NotificationsCreateOrConnectWithoutUserInput[]
    createMany?: NotificationsCreateManyUserInputEnvelope
    connect?: NotificationsWhereUniqueInput | NotificationsWhereUniqueInput[]
  }

  export type WalletsCreateNestedOneWithoutUserInput = {
    create?: XOR<WalletsCreateWithoutUserInput, WalletsUncheckedCreateWithoutUserInput>
    connectOrCreate?: WalletsCreateOrConnectWithoutUserInput
    connect?: WalletsWhereUniqueInput
  }

  export type Unlock_comicCreateNestedManyWithoutUserInput = {
    create?: XOR<Unlock_comicCreateWithoutUserInput, Unlock_comicUncheckedCreateWithoutUserInput> | Unlock_comicCreateWithoutUserInput[] | Unlock_comicUncheckedCreateWithoutUserInput[]
    connectOrCreate?: Unlock_comicCreateOrConnectWithoutUserInput | Unlock_comicCreateOrConnectWithoutUserInput[]
    createMany?: Unlock_comicCreateManyUserInputEnvelope
    connect?: Unlock_comicWhereUniqueInput | Unlock_comicWhereUniqueInput[]
  }

  export type Unlock_volumeCreateNestedManyWithoutUserInput = {
    create?: XOR<Unlock_volumeCreateWithoutUserInput, Unlock_volumeUncheckedCreateWithoutUserInput> | Unlock_volumeCreateWithoutUserInput[] | Unlock_volumeUncheckedCreateWithoutUserInput[]
    connectOrCreate?: Unlock_volumeCreateOrConnectWithoutUserInput | Unlock_volumeCreateOrConnectWithoutUserInput[]
    createMany?: Unlock_volumeCreateManyUserInputEnvelope
    connect?: Unlock_volumeWhereUniqueInput | Unlock_volumeWhereUniqueInput[]
  }

  export type Unlock_chapterCreateNestedManyWithoutUserInput = {
    create?: XOR<Unlock_chapterCreateWithoutUserInput, Unlock_chapterUncheckedCreateWithoutUserInput> | Unlock_chapterCreateWithoutUserInput[] | Unlock_chapterUncheckedCreateWithoutUserInput[]
    connectOrCreate?: Unlock_chapterCreateOrConnectWithoutUserInput | Unlock_chapterCreateOrConnectWithoutUserInput[]
    createMany?: Unlock_chapterCreateManyUserInputEnvelope
    connect?: Unlock_chapterWhereUniqueInput | Unlock_chapterWhereUniqueInput[]
  }

  export type ComicsUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<ComicsCreateWithoutUserInput, ComicsUncheckedCreateWithoutUserInput> | ComicsCreateWithoutUserInput[] | ComicsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ComicsCreateOrConnectWithoutUserInput | ComicsCreateOrConnectWithoutUserInput[]
    createMany?: ComicsCreateManyUserInputEnvelope
    connect?: ComicsWhereUniqueInput | ComicsWhereUniqueInput[]
  }

  export type RolesUncheckedCreateNestedManyWithoutUsersInput = {
    create?: XOR<RolesCreateWithoutUsersInput, RolesUncheckedCreateWithoutUsersInput> | RolesCreateWithoutUsersInput[] | RolesUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: RolesCreateOrConnectWithoutUsersInput | RolesCreateOrConnectWithoutUsersInput[]
    connect?: RolesWhereUniqueInput | RolesWhereUniqueInput[]
  }

  export type FavoritesUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<FavoritesCreateWithoutUserInput, FavoritesUncheckedCreateWithoutUserInput> | FavoritesCreateWithoutUserInput[] | FavoritesUncheckedCreateWithoutUserInput[]
    connectOrCreate?: FavoritesCreateOrConnectWithoutUserInput | FavoritesCreateOrConnectWithoutUserInput[]
    createMany?: FavoritesCreateManyUserInputEnvelope
    connect?: FavoritesWhereUniqueInput | FavoritesWhereUniqueInput[]
  }

  export type RatesUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<RatesCreateWithoutUserInput, RatesUncheckedCreateWithoutUserInput> | RatesCreateWithoutUserInput[] | RatesUncheckedCreateWithoutUserInput[]
    connectOrCreate?: RatesCreateOrConnectWithoutUserInput | RatesCreateOrConnectWithoutUserInput[]
    createMany?: RatesCreateManyUserInputEnvelope
    connect?: RatesWhereUniqueInput | RatesWhereUniqueInput[]
  }

  export type ErrorsUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<ErrorsCreateWithoutUserInput, ErrorsUncheckedCreateWithoutUserInput> | ErrorsCreateWithoutUserInput[] | ErrorsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ErrorsCreateOrConnectWithoutUserInput | ErrorsCreateOrConnectWithoutUserInput[]
    createMany?: ErrorsCreateManyUserInputEnvelope
    connect?: ErrorsWhereUniqueInput | ErrorsWhereUniqueInput[]
  }

  export type ViewsUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<ViewsCreateWithoutUserInput, ViewsUncheckedCreateWithoutUserInput> | ViewsCreateWithoutUserInput[] | ViewsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ViewsCreateOrConnectWithoutUserInput | ViewsCreateOrConnectWithoutUserInput[]
    createMany?: ViewsCreateManyUserInputEnvelope
    connect?: ViewsWhereUniqueInput | ViewsWhereUniqueInput[]
  }

  export type CommentsUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<CommentsCreateWithoutUserInput, CommentsUncheckedCreateWithoutUserInput> | CommentsCreateWithoutUserInput[] | CommentsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CommentsCreateOrConnectWithoutUserInput | CommentsCreateOrConnectWithoutUserInput[]
    createMany?: CommentsCreateManyUserInputEnvelope
    connect?: CommentsWhereUniqueInput | CommentsWhereUniqueInput[]
  }

  export type NotificationsUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<NotificationsCreateWithoutUserInput, NotificationsUncheckedCreateWithoutUserInput> | NotificationsCreateWithoutUserInput[] | NotificationsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationsCreateOrConnectWithoutUserInput | NotificationsCreateOrConnectWithoutUserInput[]
    createMany?: NotificationsCreateManyUserInputEnvelope
    connect?: NotificationsWhereUniqueInput | NotificationsWhereUniqueInput[]
  }

  export type WalletsUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<WalletsCreateWithoutUserInput, WalletsUncheckedCreateWithoutUserInput>
    connectOrCreate?: WalletsCreateOrConnectWithoutUserInput
    connect?: WalletsWhereUniqueInput
  }

  export type Unlock_comicUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<Unlock_comicCreateWithoutUserInput, Unlock_comicUncheckedCreateWithoutUserInput> | Unlock_comicCreateWithoutUserInput[] | Unlock_comicUncheckedCreateWithoutUserInput[]
    connectOrCreate?: Unlock_comicCreateOrConnectWithoutUserInput | Unlock_comicCreateOrConnectWithoutUserInput[]
    createMany?: Unlock_comicCreateManyUserInputEnvelope
    connect?: Unlock_comicWhereUniqueInput | Unlock_comicWhereUniqueInput[]
  }

  export type Unlock_volumeUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<Unlock_volumeCreateWithoutUserInput, Unlock_volumeUncheckedCreateWithoutUserInput> | Unlock_volumeCreateWithoutUserInput[] | Unlock_volumeUncheckedCreateWithoutUserInput[]
    connectOrCreate?: Unlock_volumeCreateOrConnectWithoutUserInput | Unlock_volumeCreateOrConnectWithoutUserInput[]
    createMany?: Unlock_volumeCreateManyUserInputEnvelope
    connect?: Unlock_volumeWhereUniqueInput | Unlock_volumeWhereUniqueInput[]
  }

  export type Unlock_chapterUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<Unlock_chapterCreateWithoutUserInput, Unlock_chapterUncheckedCreateWithoutUserInput> | Unlock_chapterCreateWithoutUserInput[] | Unlock_chapterUncheckedCreateWithoutUserInput[]
    connectOrCreate?: Unlock_chapterCreateOrConnectWithoutUserInput | Unlock_chapterCreateOrConnectWithoutUserInput[]
    createMany?: Unlock_chapterCreateManyUserInputEnvelope
    connect?: Unlock_chapterWhereUniqueInput | Unlock_chapterWhereUniqueInput[]
  }

  export type ComicsUpdateManyWithoutUserNestedInput = {
    create?: XOR<ComicsCreateWithoutUserInput, ComicsUncheckedCreateWithoutUserInput> | ComicsCreateWithoutUserInput[] | ComicsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ComicsCreateOrConnectWithoutUserInput | ComicsCreateOrConnectWithoutUserInput[]
    upsert?: ComicsUpsertWithWhereUniqueWithoutUserInput | ComicsUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ComicsCreateManyUserInputEnvelope
    set?: ComicsWhereUniqueInput | ComicsWhereUniqueInput[]
    disconnect?: ComicsWhereUniqueInput | ComicsWhereUniqueInput[]
    delete?: ComicsWhereUniqueInput | ComicsWhereUniqueInput[]
    connect?: ComicsWhereUniqueInput | ComicsWhereUniqueInput[]
    update?: ComicsUpdateWithWhereUniqueWithoutUserInput | ComicsUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ComicsUpdateManyWithWhereWithoutUserInput | ComicsUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ComicsScalarWhereInput | ComicsScalarWhereInput[]
  }

  export type RolesUpdateManyWithoutUsersNestedInput = {
    create?: XOR<RolesCreateWithoutUsersInput, RolesUncheckedCreateWithoutUsersInput> | RolesCreateWithoutUsersInput[] | RolesUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: RolesCreateOrConnectWithoutUsersInput | RolesCreateOrConnectWithoutUsersInput[]
    upsert?: RolesUpsertWithWhereUniqueWithoutUsersInput | RolesUpsertWithWhereUniqueWithoutUsersInput[]
    set?: RolesWhereUniqueInput | RolesWhereUniqueInput[]
    disconnect?: RolesWhereUniqueInput | RolesWhereUniqueInput[]
    delete?: RolesWhereUniqueInput | RolesWhereUniqueInput[]
    connect?: RolesWhereUniqueInput | RolesWhereUniqueInput[]
    update?: RolesUpdateWithWhereUniqueWithoutUsersInput | RolesUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: RolesUpdateManyWithWhereWithoutUsersInput | RolesUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: RolesScalarWhereInput | RolesScalarWhereInput[]
  }

  export type FavoritesUpdateManyWithoutUserNestedInput = {
    create?: XOR<FavoritesCreateWithoutUserInput, FavoritesUncheckedCreateWithoutUserInput> | FavoritesCreateWithoutUserInput[] | FavoritesUncheckedCreateWithoutUserInput[]
    connectOrCreate?: FavoritesCreateOrConnectWithoutUserInput | FavoritesCreateOrConnectWithoutUserInput[]
    upsert?: FavoritesUpsertWithWhereUniqueWithoutUserInput | FavoritesUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: FavoritesCreateManyUserInputEnvelope
    set?: FavoritesWhereUniqueInput | FavoritesWhereUniqueInput[]
    disconnect?: FavoritesWhereUniqueInput | FavoritesWhereUniqueInput[]
    delete?: FavoritesWhereUniqueInput | FavoritesWhereUniqueInput[]
    connect?: FavoritesWhereUniqueInput | FavoritesWhereUniqueInput[]
    update?: FavoritesUpdateWithWhereUniqueWithoutUserInput | FavoritesUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: FavoritesUpdateManyWithWhereWithoutUserInput | FavoritesUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: FavoritesScalarWhereInput | FavoritesScalarWhereInput[]
  }

  export type RatesUpdateManyWithoutUserNestedInput = {
    create?: XOR<RatesCreateWithoutUserInput, RatesUncheckedCreateWithoutUserInput> | RatesCreateWithoutUserInput[] | RatesUncheckedCreateWithoutUserInput[]
    connectOrCreate?: RatesCreateOrConnectWithoutUserInput | RatesCreateOrConnectWithoutUserInput[]
    upsert?: RatesUpsertWithWhereUniqueWithoutUserInput | RatesUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: RatesCreateManyUserInputEnvelope
    set?: RatesWhereUniqueInput | RatesWhereUniqueInput[]
    disconnect?: RatesWhereUniqueInput | RatesWhereUniqueInput[]
    delete?: RatesWhereUniqueInput | RatesWhereUniqueInput[]
    connect?: RatesWhereUniqueInput | RatesWhereUniqueInput[]
    update?: RatesUpdateWithWhereUniqueWithoutUserInput | RatesUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: RatesUpdateManyWithWhereWithoutUserInput | RatesUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: RatesScalarWhereInput | RatesScalarWhereInput[]
  }

  export type ErrorsUpdateManyWithoutUserNestedInput = {
    create?: XOR<ErrorsCreateWithoutUserInput, ErrorsUncheckedCreateWithoutUserInput> | ErrorsCreateWithoutUserInput[] | ErrorsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ErrorsCreateOrConnectWithoutUserInput | ErrorsCreateOrConnectWithoutUserInput[]
    upsert?: ErrorsUpsertWithWhereUniqueWithoutUserInput | ErrorsUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ErrorsCreateManyUserInputEnvelope
    set?: ErrorsWhereUniqueInput | ErrorsWhereUniqueInput[]
    disconnect?: ErrorsWhereUniqueInput | ErrorsWhereUniqueInput[]
    delete?: ErrorsWhereUniqueInput | ErrorsWhereUniqueInput[]
    connect?: ErrorsWhereUniqueInput | ErrorsWhereUniqueInput[]
    update?: ErrorsUpdateWithWhereUniqueWithoutUserInput | ErrorsUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ErrorsUpdateManyWithWhereWithoutUserInput | ErrorsUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ErrorsScalarWhereInput | ErrorsScalarWhereInput[]
  }

  export type ViewsUpdateManyWithoutUserNestedInput = {
    create?: XOR<ViewsCreateWithoutUserInput, ViewsUncheckedCreateWithoutUserInput> | ViewsCreateWithoutUserInput[] | ViewsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ViewsCreateOrConnectWithoutUserInput | ViewsCreateOrConnectWithoutUserInput[]
    upsert?: ViewsUpsertWithWhereUniqueWithoutUserInput | ViewsUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ViewsCreateManyUserInputEnvelope
    set?: ViewsWhereUniqueInput | ViewsWhereUniqueInput[]
    disconnect?: ViewsWhereUniqueInput | ViewsWhereUniqueInput[]
    delete?: ViewsWhereUniqueInput | ViewsWhereUniqueInput[]
    connect?: ViewsWhereUniqueInput | ViewsWhereUniqueInput[]
    update?: ViewsUpdateWithWhereUniqueWithoutUserInput | ViewsUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ViewsUpdateManyWithWhereWithoutUserInput | ViewsUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ViewsScalarWhereInput | ViewsScalarWhereInput[]
  }

  export type CommentsUpdateManyWithoutUserNestedInput = {
    create?: XOR<CommentsCreateWithoutUserInput, CommentsUncheckedCreateWithoutUserInput> | CommentsCreateWithoutUserInput[] | CommentsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CommentsCreateOrConnectWithoutUserInput | CommentsCreateOrConnectWithoutUserInput[]
    upsert?: CommentsUpsertWithWhereUniqueWithoutUserInput | CommentsUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: CommentsCreateManyUserInputEnvelope
    set?: CommentsWhereUniqueInput | CommentsWhereUniqueInput[]
    disconnect?: CommentsWhereUniqueInput | CommentsWhereUniqueInput[]
    delete?: CommentsWhereUniqueInput | CommentsWhereUniqueInput[]
    connect?: CommentsWhereUniqueInput | CommentsWhereUniqueInput[]
    update?: CommentsUpdateWithWhereUniqueWithoutUserInput | CommentsUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: CommentsUpdateManyWithWhereWithoutUserInput | CommentsUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: CommentsScalarWhereInput | CommentsScalarWhereInput[]
  }

  export type NotificationsUpdateManyWithoutUserNestedInput = {
    create?: XOR<NotificationsCreateWithoutUserInput, NotificationsUncheckedCreateWithoutUserInput> | NotificationsCreateWithoutUserInput[] | NotificationsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationsCreateOrConnectWithoutUserInput | NotificationsCreateOrConnectWithoutUserInput[]
    upsert?: NotificationsUpsertWithWhereUniqueWithoutUserInput | NotificationsUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: NotificationsCreateManyUserInputEnvelope
    set?: NotificationsWhereUniqueInput | NotificationsWhereUniqueInput[]
    disconnect?: NotificationsWhereUniqueInput | NotificationsWhereUniqueInput[]
    delete?: NotificationsWhereUniqueInput | NotificationsWhereUniqueInput[]
    connect?: NotificationsWhereUniqueInput | NotificationsWhereUniqueInput[]
    update?: NotificationsUpdateWithWhereUniqueWithoutUserInput | NotificationsUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: NotificationsUpdateManyWithWhereWithoutUserInput | NotificationsUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: NotificationsScalarWhereInput | NotificationsScalarWhereInput[]
  }

  export type WalletsUpdateOneWithoutUserNestedInput = {
    create?: XOR<WalletsCreateWithoutUserInput, WalletsUncheckedCreateWithoutUserInput>
    connectOrCreate?: WalletsCreateOrConnectWithoutUserInput
    upsert?: WalletsUpsertWithoutUserInput
    disconnect?: WalletsWhereInput | boolean
    delete?: WalletsWhereInput | boolean
    connect?: WalletsWhereUniqueInput
    update?: XOR<XOR<WalletsUpdateToOneWithWhereWithoutUserInput, WalletsUpdateWithoutUserInput>, WalletsUncheckedUpdateWithoutUserInput>
  }

  export type Unlock_comicUpdateManyWithoutUserNestedInput = {
    create?: XOR<Unlock_comicCreateWithoutUserInput, Unlock_comicUncheckedCreateWithoutUserInput> | Unlock_comicCreateWithoutUserInput[] | Unlock_comicUncheckedCreateWithoutUserInput[]
    connectOrCreate?: Unlock_comicCreateOrConnectWithoutUserInput | Unlock_comicCreateOrConnectWithoutUserInput[]
    upsert?: Unlock_comicUpsertWithWhereUniqueWithoutUserInput | Unlock_comicUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: Unlock_comicCreateManyUserInputEnvelope
    set?: Unlock_comicWhereUniqueInput | Unlock_comicWhereUniqueInput[]
    disconnect?: Unlock_comicWhereUniqueInput | Unlock_comicWhereUniqueInput[]
    delete?: Unlock_comicWhereUniqueInput | Unlock_comicWhereUniqueInput[]
    connect?: Unlock_comicWhereUniqueInput | Unlock_comicWhereUniqueInput[]
    update?: Unlock_comicUpdateWithWhereUniqueWithoutUserInput | Unlock_comicUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: Unlock_comicUpdateManyWithWhereWithoutUserInput | Unlock_comicUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: Unlock_comicScalarWhereInput | Unlock_comicScalarWhereInput[]
  }

  export type Unlock_volumeUpdateManyWithoutUserNestedInput = {
    create?: XOR<Unlock_volumeCreateWithoutUserInput, Unlock_volumeUncheckedCreateWithoutUserInput> | Unlock_volumeCreateWithoutUserInput[] | Unlock_volumeUncheckedCreateWithoutUserInput[]
    connectOrCreate?: Unlock_volumeCreateOrConnectWithoutUserInput | Unlock_volumeCreateOrConnectWithoutUserInput[]
    upsert?: Unlock_volumeUpsertWithWhereUniqueWithoutUserInput | Unlock_volumeUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: Unlock_volumeCreateManyUserInputEnvelope
    set?: Unlock_volumeWhereUniqueInput | Unlock_volumeWhereUniqueInput[]
    disconnect?: Unlock_volumeWhereUniqueInput | Unlock_volumeWhereUniqueInput[]
    delete?: Unlock_volumeWhereUniqueInput | Unlock_volumeWhereUniqueInput[]
    connect?: Unlock_volumeWhereUniqueInput | Unlock_volumeWhereUniqueInput[]
    update?: Unlock_volumeUpdateWithWhereUniqueWithoutUserInput | Unlock_volumeUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: Unlock_volumeUpdateManyWithWhereWithoutUserInput | Unlock_volumeUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: Unlock_volumeScalarWhereInput | Unlock_volumeScalarWhereInput[]
  }

  export type Unlock_chapterUpdateManyWithoutUserNestedInput = {
    create?: XOR<Unlock_chapterCreateWithoutUserInput, Unlock_chapterUncheckedCreateWithoutUserInput> | Unlock_chapterCreateWithoutUserInput[] | Unlock_chapterUncheckedCreateWithoutUserInput[]
    connectOrCreate?: Unlock_chapterCreateOrConnectWithoutUserInput | Unlock_chapterCreateOrConnectWithoutUserInput[]
    upsert?: Unlock_chapterUpsertWithWhereUniqueWithoutUserInput | Unlock_chapterUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: Unlock_chapterCreateManyUserInputEnvelope
    set?: Unlock_chapterWhereUniqueInput | Unlock_chapterWhereUniqueInput[]
    disconnect?: Unlock_chapterWhereUniqueInput | Unlock_chapterWhereUniqueInput[]
    delete?: Unlock_chapterWhereUniqueInput | Unlock_chapterWhereUniqueInput[]
    connect?: Unlock_chapterWhereUniqueInput | Unlock_chapterWhereUniqueInput[]
    update?: Unlock_chapterUpdateWithWhereUniqueWithoutUserInput | Unlock_chapterUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: Unlock_chapterUpdateManyWithWhereWithoutUserInput | Unlock_chapterUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: Unlock_chapterScalarWhereInput | Unlock_chapterScalarWhereInput[]
  }

  export type ComicsUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<ComicsCreateWithoutUserInput, ComicsUncheckedCreateWithoutUserInput> | ComicsCreateWithoutUserInput[] | ComicsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ComicsCreateOrConnectWithoutUserInput | ComicsCreateOrConnectWithoutUserInput[]
    upsert?: ComicsUpsertWithWhereUniqueWithoutUserInput | ComicsUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ComicsCreateManyUserInputEnvelope
    set?: ComicsWhereUniqueInput | ComicsWhereUniqueInput[]
    disconnect?: ComicsWhereUniqueInput | ComicsWhereUniqueInput[]
    delete?: ComicsWhereUniqueInput | ComicsWhereUniqueInput[]
    connect?: ComicsWhereUniqueInput | ComicsWhereUniqueInput[]
    update?: ComicsUpdateWithWhereUniqueWithoutUserInput | ComicsUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ComicsUpdateManyWithWhereWithoutUserInput | ComicsUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ComicsScalarWhereInput | ComicsScalarWhereInput[]
  }

  export type RolesUncheckedUpdateManyWithoutUsersNestedInput = {
    create?: XOR<RolesCreateWithoutUsersInput, RolesUncheckedCreateWithoutUsersInput> | RolesCreateWithoutUsersInput[] | RolesUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: RolesCreateOrConnectWithoutUsersInput | RolesCreateOrConnectWithoutUsersInput[]
    upsert?: RolesUpsertWithWhereUniqueWithoutUsersInput | RolesUpsertWithWhereUniqueWithoutUsersInput[]
    set?: RolesWhereUniqueInput | RolesWhereUniqueInput[]
    disconnect?: RolesWhereUniqueInput | RolesWhereUniqueInput[]
    delete?: RolesWhereUniqueInput | RolesWhereUniqueInput[]
    connect?: RolesWhereUniqueInput | RolesWhereUniqueInput[]
    update?: RolesUpdateWithWhereUniqueWithoutUsersInput | RolesUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: RolesUpdateManyWithWhereWithoutUsersInput | RolesUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: RolesScalarWhereInput | RolesScalarWhereInput[]
  }

  export type FavoritesUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<FavoritesCreateWithoutUserInput, FavoritesUncheckedCreateWithoutUserInput> | FavoritesCreateWithoutUserInput[] | FavoritesUncheckedCreateWithoutUserInput[]
    connectOrCreate?: FavoritesCreateOrConnectWithoutUserInput | FavoritesCreateOrConnectWithoutUserInput[]
    upsert?: FavoritesUpsertWithWhereUniqueWithoutUserInput | FavoritesUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: FavoritesCreateManyUserInputEnvelope
    set?: FavoritesWhereUniqueInput | FavoritesWhereUniqueInput[]
    disconnect?: FavoritesWhereUniqueInput | FavoritesWhereUniqueInput[]
    delete?: FavoritesWhereUniqueInput | FavoritesWhereUniqueInput[]
    connect?: FavoritesWhereUniqueInput | FavoritesWhereUniqueInput[]
    update?: FavoritesUpdateWithWhereUniqueWithoutUserInput | FavoritesUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: FavoritesUpdateManyWithWhereWithoutUserInput | FavoritesUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: FavoritesScalarWhereInput | FavoritesScalarWhereInput[]
  }

  export type RatesUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<RatesCreateWithoutUserInput, RatesUncheckedCreateWithoutUserInput> | RatesCreateWithoutUserInput[] | RatesUncheckedCreateWithoutUserInput[]
    connectOrCreate?: RatesCreateOrConnectWithoutUserInput | RatesCreateOrConnectWithoutUserInput[]
    upsert?: RatesUpsertWithWhereUniqueWithoutUserInput | RatesUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: RatesCreateManyUserInputEnvelope
    set?: RatesWhereUniqueInput | RatesWhereUniqueInput[]
    disconnect?: RatesWhereUniqueInput | RatesWhereUniqueInput[]
    delete?: RatesWhereUniqueInput | RatesWhereUniqueInput[]
    connect?: RatesWhereUniqueInput | RatesWhereUniqueInput[]
    update?: RatesUpdateWithWhereUniqueWithoutUserInput | RatesUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: RatesUpdateManyWithWhereWithoutUserInput | RatesUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: RatesScalarWhereInput | RatesScalarWhereInput[]
  }

  export type ErrorsUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<ErrorsCreateWithoutUserInput, ErrorsUncheckedCreateWithoutUserInput> | ErrorsCreateWithoutUserInput[] | ErrorsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ErrorsCreateOrConnectWithoutUserInput | ErrorsCreateOrConnectWithoutUserInput[]
    upsert?: ErrorsUpsertWithWhereUniqueWithoutUserInput | ErrorsUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ErrorsCreateManyUserInputEnvelope
    set?: ErrorsWhereUniqueInput | ErrorsWhereUniqueInput[]
    disconnect?: ErrorsWhereUniqueInput | ErrorsWhereUniqueInput[]
    delete?: ErrorsWhereUniqueInput | ErrorsWhereUniqueInput[]
    connect?: ErrorsWhereUniqueInput | ErrorsWhereUniqueInput[]
    update?: ErrorsUpdateWithWhereUniqueWithoutUserInput | ErrorsUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ErrorsUpdateManyWithWhereWithoutUserInput | ErrorsUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ErrorsScalarWhereInput | ErrorsScalarWhereInput[]
  }

  export type ViewsUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<ViewsCreateWithoutUserInput, ViewsUncheckedCreateWithoutUserInput> | ViewsCreateWithoutUserInput[] | ViewsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ViewsCreateOrConnectWithoutUserInput | ViewsCreateOrConnectWithoutUserInput[]
    upsert?: ViewsUpsertWithWhereUniqueWithoutUserInput | ViewsUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ViewsCreateManyUserInputEnvelope
    set?: ViewsWhereUniqueInput | ViewsWhereUniqueInput[]
    disconnect?: ViewsWhereUniqueInput | ViewsWhereUniqueInput[]
    delete?: ViewsWhereUniqueInput | ViewsWhereUniqueInput[]
    connect?: ViewsWhereUniqueInput | ViewsWhereUniqueInput[]
    update?: ViewsUpdateWithWhereUniqueWithoutUserInput | ViewsUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ViewsUpdateManyWithWhereWithoutUserInput | ViewsUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ViewsScalarWhereInput | ViewsScalarWhereInput[]
  }

  export type CommentsUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<CommentsCreateWithoutUserInput, CommentsUncheckedCreateWithoutUserInput> | CommentsCreateWithoutUserInput[] | CommentsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CommentsCreateOrConnectWithoutUserInput | CommentsCreateOrConnectWithoutUserInput[]
    upsert?: CommentsUpsertWithWhereUniqueWithoutUserInput | CommentsUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: CommentsCreateManyUserInputEnvelope
    set?: CommentsWhereUniqueInput | CommentsWhereUniqueInput[]
    disconnect?: CommentsWhereUniqueInput | CommentsWhereUniqueInput[]
    delete?: CommentsWhereUniqueInput | CommentsWhereUniqueInput[]
    connect?: CommentsWhereUniqueInput | CommentsWhereUniqueInput[]
    update?: CommentsUpdateWithWhereUniqueWithoutUserInput | CommentsUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: CommentsUpdateManyWithWhereWithoutUserInput | CommentsUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: CommentsScalarWhereInput | CommentsScalarWhereInput[]
  }

  export type NotificationsUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<NotificationsCreateWithoutUserInput, NotificationsUncheckedCreateWithoutUserInput> | NotificationsCreateWithoutUserInput[] | NotificationsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationsCreateOrConnectWithoutUserInput | NotificationsCreateOrConnectWithoutUserInput[]
    upsert?: NotificationsUpsertWithWhereUniqueWithoutUserInput | NotificationsUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: NotificationsCreateManyUserInputEnvelope
    set?: NotificationsWhereUniqueInput | NotificationsWhereUniqueInput[]
    disconnect?: NotificationsWhereUniqueInput | NotificationsWhereUniqueInput[]
    delete?: NotificationsWhereUniqueInput | NotificationsWhereUniqueInput[]
    connect?: NotificationsWhereUniqueInput | NotificationsWhereUniqueInput[]
    update?: NotificationsUpdateWithWhereUniqueWithoutUserInput | NotificationsUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: NotificationsUpdateManyWithWhereWithoutUserInput | NotificationsUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: NotificationsScalarWhereInput | NotificationsScalarWhereInput[]
  }

  export type WalletsUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<WalletsCreateWithoutUserInput, WalletsUncheckedCreateWithoutUserInput>
    connectOrCreate?: WalletsCreateOrConnectWithoutUserInput
    upsert?: WalletsUpsertWithoutUserInput
    disconnect?: WalletsWhereInput | boolean
    delete?: WalletsWhereInput | boolean
    connect?: WalletsWhereUniqueInput
    update?: XOR<XOR<WalletsUpdateToOneWithWhereWithoutUserInput, WalletsUpdateWithoutUserInput>, WalletsUncheckedUpdateWithoutUserInput>
  }

  export type Unlock_comicUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<Unlock_comicCreateWithoutUserInput, Unlock_comicUncheckedCreateWithoutUserInput> | Unlock_comicCreateWithoutUserInput[] | Unlock_comicUncheckedCreateWithoutUserInput[]
    connectOrCreate?: Unlock_comicCreateOrConnectWithoutUserInput | Unlock_comicCreateOrConnectWithoutUserInput[]
    upsert?: Unlock_comicUpsertWithWhereUniqueWithoutUserInput | Unlock_comicUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: Unlock_comicCreateManyUserInputEnvelope
    set?: Unlock_comicWhereUniqueInput | Unlock_comicWhereUniqueInput[]
    disconnect?: Unlock_comicWhereUniqueInput | Unlock_comicWhereUniqueInput[]
    delete?: Unlock_comicWhereUniqueInput | Unlock_comicWhereUniqueInput[]
    connect?: Unlock_comicWhereUniqueInput | Unlock_comicWhereUniqueInput[]
    update?: Unlock_comicUpdateWithWhereUniqueWithoutUserInput | Unlock_comicUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: Unlock_comicUpdateManyWithWhereWithoutUserInput | Unlock_comicUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: Unlock_comicScalarWhereInput | Unlock_comicScalarWhereInput[]
  }

  export type Unlock_volumeUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<Unlock_volumeCreateWithoutUserInput, Unlock_volumeUncheckedCreateWithoutUserInput> | Unlock_volumeCreateWithoutUserInput[] | Unlock_volumeUncheckedCreateWithoutUserInput[]
    connectOrCreate?: Unlock_volumeCreateOrConnectWithoutUserInput | Unlock_volumeCreateOrConnectWithoutUserInput[]
    upsert?: Unlock_volumeUpsertWithWhereUniqueWithoutUserInput | Unlock_volumeUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: Unlock_volumeCreateManyUserInputEnvelope
    set?: Unlock_volumeWhereUniqueInput | Unlock_volumeWhereUniqueInput[]
    disconnect?: Unlock_volumeWhereUniqueInput | Unlock_volumeWhereUniqueInput[]
    delete?: Unlock_volumeWhereUniqueInput | Unlock_volumeWhereUniqueInput[]
    connect?: Unlock_volumeWhereUniqueInput | Unlock_volumeWhereUniqueInput[]
    update?: Unlock_volumeUpdateWithWhereUniqueWithoutUserInput | Unlock_volumeUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: Unlock_volumeUpdateManyWithWhereWithoutUserInput | Unlock_volumeUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: Unlock_volumeScalarWhereInput | Unlock_volumeScalarWhereInput[]
  }

  export type Unlock_chapterUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<Unlock_chapterCreateWithoutUserInput, Unlock_chapterUncheckedCreateWithoutUserInput> | Unlock_chapterCreateWithoutUserInput[] | Unlock_chapterUncheckedCreateWithoutUserInput[]
    connectOrCreate?: Unlock_chapterCreateOrConnectWithoutUserInput | Unlock_chapterCreateOrConnectWithoutUserInput[]
    upsert?: Unlock_chapterUpsertWithWhereUniqueWithoutUserInput | Unlock_chapterUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: Unlock_chapterCreateManyUserInputEnvelope
    set?: Unlock_chapterWhereUniqueInput | Unlock_chapterWhereUniqueInput[]
    disconnect?: Unlock_chapterWhereUniqueInput | Unlock_chapterWhereUniqueInput[]
    delete?: Unlock_chapterWhereUniqueInput | Unlock_chapterWhereUniqueInput[]
    connect?: Unlock_chapterWhereUniqueInput | Unlock_chapterWhereUniqueInput[]
    update?: Unlock_chapterUpdateWithWhereUniqueWithoutUserInput | Unlock_chapterUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: Unlock_chapterUpdateManyWithWhereWithoutUserInput | Unlock_chapterUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: Unlock_chapterScalarWhereInput | Unlock_chapterScalarWhereInput[]
  }

  export type UsersCreateNestedOneWithoutFavoritesInput = {
    create?: XOR<UsersCreateWithoutFavoritesInput, UsersUncheckedCreateWithoutFavoritesInput>
    connectOrCreate?: UsersCreateOrConnectWithoutFavoritesInput
    connect?: UsersWhereUniqueInput
  }

  export type ComicsCreateNestedOneWithoutFavoritesInput = {
    create?: XOR<ComicsCreateWithoutFavoritesInput, ComicsUncheckedCreateWithoutFavoritesInput>
    connectOrCreate?: ComicsCreateOrConnectWithoutFavoritesInput
    connect?: ComicsWhereUniqueInput
  }

  export type UsersUpdateOneRequiredWithoutFavoritesNestedInput = {
    create?: XOR<UsersCreateWithoutFavoritesInput, UsersUncheckedCreateWithoutFavoritesInput>
    connectOrCreate?: UsersCreateOrConnectWithoutFavoritesInput
    upsert?: UsersUpsertWithoutFavoritesInput
    connect?: UsersWhereUniqueInput
    update?: XOR<XOR<UsersUpdateToOneWithWhereWithoutFavoritesInput, UsersUpdateWithoutFavoritesInput>, UsersUncheckedUpdateWithoutFavoritesInput>
  }

  export type ComicsUpdateOneRequiredWithoutFavoritesNestedInput = {
    create?: XOR<ComicsCreateWithoutFavoritesInput, ComicsUncheckedCreateWithoutFavoritesInput>
    connectOrCreate?: ComicsCreateOrConnectWithoutFavoritesInput
    upsert?: ComicsUpsertWithoutFavoritesInput
    connect?: ComicsWhereUniqueInput
    update?: XOR<XOR<ComicsUpdateToOneWithWhereWithoutFavoritesInput, ComicsUpdateWithoutFavoritesInput>, ComicsUncheckedUpdateWithoutFavoritesInput>
  }

  export type UsersCreateNestedOneWithoutRatesInput = {
    create?: XOR<UsersCreateWithoutRatesInput, UsersUncheckedCreateWithoutRatesInput>
    connectOrCreate?: UsersCreateOrConnectWithoutRatesInput
    connect?: UsersWhereUniqueInput
  }

  export type ComicsCreateNestedOneWithoutRatesInput = {
    create?: XOR<ComicsCreateWithoutRatesInput, ComicsUncheckedCreateWithoutRatesInput>
    connectOrCreate?: ComicsCreateOrConnectWithoutRatesInput
    connect?: ComicsWhereUniqueInput
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type UsersUpdateOneRequiredWithoutRatesNestedInput = {
    create?: XOR<UsersCreateWithoutRatesInput, UsersUncheckedCreateWithoutRatesInput>
    connectOrCreate?: UsersCreateOrConnectWithoutRatesInput
    upsert?: UsersUpsertWithoutRatesInput
    connect?: UsersWhereUniqueInput
    update?: XOR<XOR<UsersUpdateToOneWithWhereWithoutRatesInput, UsersUpdateWithoutRatesInput>, UsersUncheckedUpdateWithoutRatesInput>
  }

  export type ComicsUpdateOneRequiredWithoutRatesNestedInput = {
    create?: XOR<ComicsCreateWithoutRatesInput, ComicsUncheckedCreateWithoutRatesInput>
    connectOrCreate?: ComicsCreateOrConnectWithoutRatesInput
    upsert?: ComicsUpsertWithoutRatesInput
    connect?: ComicsWhereUniqueInput
    update?: XOR<XOR<ComicsUpdateToOneWithWhereWithoutRatesInput, ComicsUpdateWithoutRatesInput>, ComicsUncheckedUpdateWithoutRatesInput>
  }

  export type UsersCreateNestedOneWithoutErrorsInput = {
    create?: XOR<UsersCreateWithoutErrorsInput, UsersUncheckedCreateWithoutErrorsInput>
    connectOrCreate?: UsersCreateOrConnectWithoutErrorsInput
    connect?: UsersWhereUniqueInput
  }

  export type ChaptersCreateNestedOneWithoutErrorsInput = {
    create?: XOR<ChaptersCreateWithoutErrorsInput, ChaptersUncheckedCreateWithoutErrorsInput>
    connectOrCreate?: ChaptersCreateOrConnectWithoutErrorsInput
    connect?: ChaptersWhereUniqueInput
  }

  export type UsersUpdateOneRequiredWithoutErrorsNestedInput = {
    create?: XOR<UsersCreateWithoutErrorsInput, UsersUncheckedCreateWithoutErrorsInput>
    connectOrCreate?: UsersCreateOrConnectWithoutErrorsInput
    upsert?: UsersUpsertWithoutErrorsInput
    connect?: UsersWhereUniqueInput
    update?: XOR<XOR<UsersUpdateToOneWithWhereWithoutErrorsInput, UsersUpdateWithoutErrorsInput>, UsersUncheckedUpdateWithoutErrorsInput>
  }

  export type ChaptersUpdateOneRequiredWithoutErrorsNestedInput = {
    create?: XOR<ChaptersCreateWithoutErrorsInput, ChaptersUncheckedCreateWithoutErrorsInput>
    connectOrCreate?: ChaptersCreateOrConnectWithoutErrorsInput
    upsert?: ChaptersUpsertWithoutErrorsInput
    connect?: ChaptersWhereUniqueInput
    update?: XOR<XOR<ChaptersUpdateToOneWithWhereWithoutErrorsInput, ChaptersUpdateWithoutErrorsInput>, ChaptersUncheckedUpdateWithoutErrorsInput>
  }

  export type UsersCreateNestedOneWithoutViewsInput = {
    create?: XOR<UsersCreateWithoutViewsInput, UsersUncheckedCreateWithoutViewsInput>
    connectOrCreate?: UsersCreateOrConnectWithoutViewsInput
    connect?: UsersWhereUniqueInput
  }

  export type ComicsCreateNestedOneWithoutViewsInput = {
    create?: XOR<ComicsCreateWithoutViewsInput, ComicsUncheckedCreateWithoutViewsInput>
    connectOrCreate?: ComicsCreateOrConnectWithoutViewsInput
    connect?: ComicsWhereUniqueInput
  }

  export type ChaptersCreateNestedOneWithoutViewsInput = {
    create?: XOR<ChaptersCreateWithoutViewsInput, ChaptersUncheckedCreateWithoutViewsInput>
    connectOrCreate?: ChaptersCreateOrConnectWithoutViewsInput
    connect?: ChaptersWhereUniqueInput
  }

  export type UsersUpdateOneRequiredWithoutViewsNestedInput = {
    create?: XOR<UsersCreateWithoutViewsInput, UsersUncheckedCreateWithoutViewsInput>
    connectOrCreate?: UsersCreateOrConnectWithoutViewsInput
    upsert?: UsersUpsertWithoutViewsInput
    connect?: UsersWhereUniqueInput
    update?: XOR<XOR<UsersUpdateToOneWithWhereWithoutViewsInput, UsersUpdateWithoutViewsInput>, UsersUncheckedUpdateWithoutViewsInput>
  }

  export type ComicsUpdateOneRequiredWithoutViewsNestedInput = {
    create?: XOR<ComicsCreateWithoutViewsInput, ComicsUncheckedCreateWithoutViewsInput>
    connectOrCreate?: ComicsCreateOrConnectWithoutViewsInput
    upsert?: ComicsUpsertWithoutViewsInput
    connect?: ComicsWhereUniqueInput
    update?: XOR<XOR<ComicsUpdateToOneWithWhereWithoutViewsInput, ComicsUpdateWithoutViewsInput>, ComicsUncheckedUpdateWithoutViewsInput>
  }

  export type ChaptersUpdateOneRequiredWithoutViewsNestedInput = {
    create?: XOR<ChaptersCreateWithoutViewsInput, ChaptersUncheckedCreateWithoutViewsInput>
    connectOrCreate?: ChaptersCreateOrConnectWithoutViewsInput
    upsert?: ChaptersUpsertWithoutViewsInput
    connect?: ChaptersWhereUniqueInput
    update?: XOR<XOR<ChaptersUpdateToOneWithWhereWithoutViewsInput, ChaptersUpdateWithoutViewsInput>, ChaptersUncheckedUpdateWithoutViewsInput>
  }

  export type UsersCreateNestedOneWithoutComentsInput = {
    create?: XOR<UsersCreateWithoutComentsInput, UsersUncheckedCreateWithoutComentsInput>
    connectOrCreate?: UsersCreateOrConnectWithoutComentsInput
    connect?: UsersWhereUniqueInput
  }

  export type ChaptersCreateNestedOneWithoutComentsInput = {
    create?: XOR<ChaptersCreateWithoutComentsInput, ChaptersUncheckedCreateWithoutComentsInput>
    connectOrCreate?: ChaptersCreateOrConnectWithoutComentsInput
    connect?: ChaptersWhereUniqueInput
  }

  export type ComicsCreateNestedOneWithoutCommentInput = {
    create?: XOR<ComicsCreateWithoutCommentInput, ComicsUncheckedCreateWithoutCommentInput>
    connectOrCreate?: ComicsCreateOrConnectWithoutCommentInput
    connect?: ComicsWhereUniqueInput
  }

  export type NotificationsCreateNestedManyWithoutCommentInput = {
    create?: XOR<NotificationsCreateWithoutCommentInput, NotificationsUncheckedCreateWithoutCommentInput> | NotificationsCreateWithoutCommentInput[] | NotificationsUncheckedCreateWithoutCommentInput[]
    connectOrCreate?: NotificationsCreateOrConnectWithoutCommentInput | NotificationsCreateOrConnectWithoutCommentInput[]
    createMany?: NotificationsCreateManyCommentInputEnvelope
    connect?: NotificationsWhereUniqueInput | NotificationsWhereUniqueInput[]
  }

  export type NotificationsUncheckedCreateNestedManyWithoutCommentInput = {
    create?: XOR<NotificationsCreateWithoutCommentInput, NotificationsUncheckedCreateWithoutCommentInput> | NotificationsCreateWithoutCommentInput[] | NotificationsUncheckedCreateWithoutCommentInput[]
    connectOrCreate?: NotificationsCreateOrConnectWithoutCommentInput | NotificationsCreateOrConnectWithoutCommentInput[]
    createMany?: NotificationsCreateManyCommentInputEnvelope
    connect?: NotificationsWhereUniqueInput | NotificationsWhereUniqueInput[]
  }

  export type UsersUpdateOneRequiredWithoutComentsNestedInput = {
    create?: XOR<UsersCreateWithoutComentsInput, UsersUncheckedCreateWithoutComentsInput>
    connectOrCreate?: UsersCreateOrConnectWithoutComentsInput
    upsert?: UsersUpsertWithoutComentsInput
    connect?: UsersWhereUniqueInput
    update?: XOR<XOR<UsersUpdateToOneWithWhereWithoutComentsInput, UsersUpdateWithoutComentsInput>, UsersUncheckedUpdateWithoutComentsInput>
  }

  export type ChaptersUpdateOneWithoutComentsNestedInput = {
    create?: XOR<ChaptersCreateWithoutComentsInput, ChaptersUncheckedCreateWithoutComentsInput>
    connectOrCreate?: ChaptersCreateOrConnectWithoutComentsInput
    upsert?: ChaptersUpsertWithoutComentsInput
    disconnect?: ChaptersWhereInput | boolean
    delete?: ChaptersWhereInput | boolean
    connect?: ChaptersWhereUniqueInput
    update?: XOR<XOR<ChaptersUpdateToOneWithWhereWithoutComentsInput, ChaptersUpdateWithoutComentsInput>, ChaptersUncheckedUpdateWithoutComentsInput>
  }

  export type ComicsUpdateOneRequiredWithoutCommentNestedInput = {
    create?: XOR<ComicsCreateWithoutCommentInput, ComicsUncheckedCreateWithoutCommentInput>
    connectOrCreate?: ComicsCreateOrConnectWithoutCommentInput
    upsert?: ComicsUpsertWithoutCommentInput
    connect?: ComicsWhereUniqueInput
    update?: XOR<XOR<ComicsUpdateToOneWithWhereWithoutCommentInput, ComicsUpdateWithoutCommentInput>, ComicsUncheckedUpdateWithoutCommentInput>
  }

  export type NotificationsUpdateManyWithoutCommentNestedInput = {
    create?: XOR<NotificationsCreateWithoutCommentInput, NotificationsUncheckedCreateWithoutCommentInput> | NotificationsCreateWithoutCommentInput[] | NotificationsUncheckedCreateWithoutCommentInput[]
    connectOrCreate?: NotificationsCreateOrConnectWithoutCommentInput | NotificationsCreateOrConnectWithoutCommentInput[]
    upsert?: NotificationsUpsertWithWhereUniqueWithoutCommentInput | NotificationsUpsertWithWhereUniqueWithoutCommentInput[]
    createMany?: NotificationsCreateManyCommentInputEnvelope
    set?: NotificationsWhereUniqueInput | NotificationsWhereUniqueInput[]
    disconnect?: NotificationsWhereUniqueInput | NotificationsWhereUniqueInput[]
    delete?: NotificationsWhereUniqueInput | NotificationsWhereUniqueInput[]
    connect?: NotificationsWhereUniqueInput | NotificationsWhereUniqueInput[]
    update?: NotificationsUpdateWithWhereUniqueWithoutCommentInput | NotificationsUpdateWithWhereUniqueWithoutCommentInput[]
    updateMany?: NotificationsUpdateManyWithWhereWithoutCommentInput | NotificationsUpdateManyWithWhereWithoutCommentInput[]
    deleteMany?: NotificationsScalarWhereInput | NotificationsScalarWhereInput[]
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NotificationsUncheckedUpdateManyWithoutCommentNestedInput = {
    create?: XOR<NotificationsCreateWithoutCommentInput, NotificationsUncheckedCreateWithoutCommentInput> | NotificationsCreateWithoutCommentInput[] | NotificationsUncheckedCreateWithoutCommentInput[]
    connectOrCreate?: NotificationsCreateOrConnectWithoutCommentInput | NotificationsCreateOrConnectWithoutCommentInput[]
    upsert?: NotificationsUpsertWithWhereUniqueWithoutCommentInput | NotificationsUpsertWithWhereUniqueWithoutCommentInput[]
    createMany?: NotificationsCreateManyCommentInputEnvelope
    set?: NotificationsWhereUniqueInput | NotificationsWhereUniqueInput[]
    disconnect?: NotificationsWhereUniqueInput | NotificationsWhereUniqueInput[]
    delete?: NotificationsWhereUniqueInput | NotificationsWhereUniqueInput[]
    connect?: NotificationsWhereUniqueInput | NotificationsWhereUniqueInput[]
    update?: NotificationsUpdateWithWhereUniqueWithoutCommentInput | NotificationsUpdateWithWhereUniqueWithoutCommentInput[]
    updateMany?: NotificationsUpdateManyWithWhereWithoutCommentInput | NotificationsUpdateManyWithWhereWithoutCommentInput[]
    deleteMany?: NotificationsScalarWhereInput | NotificationsScalarWhereInput[]
  }

  export type UsersCreateNestedOneWithoutNotificationsInput = {
    create?: XOR<UsersCreateWithoutNotificationsInput, UsersUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: UsersCreateOrConnectWithoutNotificationsInput
    connect?: UsersWhereUniqueInput
  }

  export type CommentsCreateNestedOneWithoutNotificationInput = {
    create?: XOR<CommentsCreateWithoutNotificationInput, CommentsUncheckedCreateWithoutNotificationInput>
    connectOrCreate?: CommentsCreateOrConnectWithoutNotificationInput
    connect?: CommentsWhereUniqueInput
  }

  export type UsersUpdateOneRequiredWithoutNotificationsNestedInput = {
    create?: XOR<UsersCreateWithoutNotificationsInput, UsersUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: UsersCreateOrConnectWithoutNotificationsInput
    upsert?: UsersUpsertWithoutNotificationsInput
    connect?: UsersWhereUniqueInput
    update?: XOR<XOR<UsersUpdateToOneWithWhereWithoutNotificationsInput, UsersUpdateWithoutNotificationsInput>, UsersUncheckedUpdateWithoutNotificationsInput>
  }

  export type CommentsUpdateOneWithoutNotificationNestedInput = {
    create?: XOR<CommentsCreateWithoutNotificationInput, CommentsUncheckedCreateWithoutNotificationInput>
    connectOrCreate?: CommentsCreateOrConnectWithoutNotificationInput
    upsert?: CommentsUpsertWithoutNotificationInput
    disconnect?: CommentsWhereInput | boolean
    delete?: CommentsWhereInput | boolean
    connect?: CommentsWhereUniqueInput
    update?: XOR<XOR<CommentsUpdateToOneWithWhereWithoutNotificationInput, CommentsUpdateWithoutNotificationInput>, CommentsUncheckedUpdateWithoutNotificationInput>
  }

  export type UsersCreateNestedOneWithoutWalletsInput = {
    create?: XOR<UsersCreateWithoutWalletsInput, UsersUncheckedCreateWithoutWalletsInput>
    connectOrCreate?: UsersCreateOrConnectWithoutWalletsInput
    connect?: UsersWhereUniqueInput
  }

  export type TransactionsCreateNestedManyWithoutWalletInput = {
    create?: XOR<TransactionsCreateWithoutWalletInput, TransactionsUncheckedCreateWithoutWalletInput> | TransactionsCreateWithoutWalletInput[] | TransactionsUncheckedCreateWithoutWalletInput[]
    connectOrCreate?: TransactionsCreateOrConnectWithoutWalletInput | TransactionsCreateOrConnectWithoutWalletInput[]
    createMany?: TransactionsCreateManyWalletInputEnvelope
    connect?: TransactionsWhereUniqueInput | TransactionsWhereUniqueInput[]
  }

  export type TransactionsUncheckedCreateNestedManyWithoutWalletInput = {
    create?: XOR<TransactionsCreateWithoutWalletInput, TransactionsUncheckedCreateWithoutWalletInput> | TransactionsCreateWithoutWalletInput[] | TransactionsUncheckedCreateWithoutWalletInput[]
    connectOrCreate?: TransactionsCreateOrConnectWithoutWalletInput | TransactionsCreateOrConnectWithoutWalletInput[]
    createMany?: TransactionsCreateManyWalletInputEnvelope
    connect?: TransactionsWhereUniqueInput | TransactionsWhereUniqueInput[]
  }

  export type UsersUpdateOneRequiredWithoutWalletsNestedInput = {
    create?: XOR<UsersCreateWithoutWalletsInput, UsersUncheckedCreateWithoutWalletsInput>
    connectOrCreate?: UsersCreateOrConnectWithoutWalletsInput
    upsert?: UsersUpsertWithoutWalletsInput
    connect?: UsersWhereUniqueInput
    update?: XOR<XOR<UsersUpdateToOneWithWhereWithoutWalletsInput, UsersUpdateWithoutWalletsInput>, UsersUncheckedUpdateWithoutWalletsInput>
  }

  export type TransactionsUpdateManyWithoutWalletNestedInput = {
    create?: XOR<TransactionsCreateWithoutWalletInput, TransactionsUncheckedCreateWithoutWalletInput> | TransactionsCreateWithoutWalletInput[] | TransactionsUncheckedCreateWithoutWalletInput[]
    connectOrCreate?: TransactionsCreateOrConnectWithoutWalletInput | TransactionsCreateOrConnectWithoutWalletInput[]
    upsert?: TransactionsUpsertWithWhereUniqueWithoutWalletInput | TransactionsUpsertWithWhereUniqueWithoutWalletInput[]
    createMany?: TransactionsCreateManyWalletInputEnvelope
    set?: TransactionsWhereUniqueInput | TransactionsWhereUniqueInput[]
    disconnect?: TransactionsWhereUniqueInput | TransactionsWhereUniqueInput[]
    delete?: TransactionsWhereUniqueInput | TransactionsWhereUniqueInput[]
    connect?: TransactionsWhereUniqueInput | TransactionsWhereUniqueInput[]
    update?: TransactionsUpdateWithWhereUniqueWithoutWalletInput | TransactionsUpdateWithWhereUniqueWithoutWalletInput[]
    updateMany?: TransactionsUpdateManyWithWhereWithoutWalletInput | TransactionsUpdateManyWithWhereWithoutWalletInput[]
    deleteMany?: TransactionsScalarWhereInput | TransactionsScalarWhereInput[]
  }

  export type TransactionsUncheckedUpdateManyWithoutWalletNestedInput = {
    create?: XOR<TransactionsCreateWithoutWalletInput, TransactionsUncheckedCreateWithoutWalletInput> | TransactionsCreateWithoutWalletInput[] | TransactionsUncheckedCreateWithoutWalletInput[]
    connectOrCreate?: TransactionsCreateOrConnectWithoutWalletInput | TransactionsCreateOrConnectWithoutWalletInput[]
    upsert?: TransactionsUpsertWithWhereUniqueWithoutWalletInput | TransactionsUpsertWithWhereUniqueWithoutWalletInput[]
    createMany?: TransactionsCreateManyWalletInputEnvelope
    set?: TransactionsWhereUniqueInput | TransactionsWhereUniqueInput[]
    disconnect?: TransactionsWhereUniqueInput | TransactionsWhereUniqueInput[]
    delete?: TransactionsWhereUniqueInput | TransactionsWhereUniqueInput[]
    connect?: TransactionsWhereUniqueInput | TransactionsWhereUniqueInput[]
    update?: TransactionsUpdateWithWhereUniqueWithoutWalletInput | TransactionsUpdateWithWhereUniqueWithoutWalletInput[]
    updateMany?: TransactionsUpdateManyWithWhereWithoutWalletInput | TransactionsUpdateManyWithWhereWithoutWalletInput[]
    deleteMany?: TransactionsScalarWhereInput | TransactionsScalarWhereInput[]
  }

  export type WalletsCreateNestedOneWithoutTransactionsInput = {
    create?: XOR<WalletsCreateWithoutTransactionsInput, WalletsUncheckedCreateWithoutTransactionsInput>
    connectOrCreate?: WalletsCreateOrConnectWithoutTransactionsInput
    connect?: WalletsWhereUniqueInput
  }

  export type Unlock_comicCreateNestedManyWithoutTransactionInput = {
    create?: XOR<Unlock_comicCreateWithoutTransactionInput, Unlock_comicUncheckedCreateWithoutTransactionInput> | Unlock_comicCreateWithoutTransactionInput[] | Unlock_comicUncheckedCreateWithoutTransactionInput[]
    connectOrCreate?: Unlock_comicCreateOrConnectWithoutTransactionInput | Unlock_comicCreateOrConnectWithoutTransactionInput[]
    createMany?: Unlock_comicCreateManyTransactionInputEnvelope
    connect?: Unlock_comicWhereUniqueInput | Unlock_comicWhereUniqueInput[]
  }

  export type Unlock_volumeCreateNestedManyWithoutTransactionInput = {
    create?: XOR<Unlock_volumeCreateWithoutTransactionInput, Unlock_volumeUncheckedCreateWithoutTransactionInput> | Unlock_volumeCreateWithoutTransactionInput[] | Unlock_volumeUncheckedCreateWithoutTransactionInput[]
    connectOrCreate?: Unlock_volumeCreateOrConnectWithoutTransactionInput | Unlock_volumeCreateOrConnectWithoutTransactionInput[]
    createMany?: Unlock_volumeCreateManyTransactionInputEnvelope
    connect?: Unlock_volumeWhereUniqueInput | Unlock_volumeWhereUniqueInput[]
  }

  export type Unlock_chapterCreateNestedManyWithoutTransactionInput = {
    create?: XOR<Unlock_chapterCreateWithoutTransactionInput, Unlock_chapterUncheckedCreateWithoutTransactionInput> | Unlock_chapterCreateWithoutTransactionInput[] | Unlock_chapterUncheckedCreateWithoutTransactionInput[]
    connectOrCreate?: Unlock_chapterCreateOrConnectWithoutTransactionInput | Unlock_chapterCreateOrConnectWithoutTransactionInput[]
    createMany?: Unlock_chapterCreateManyTransactionInputEnvelope
    connect?: Unlock_chapterWhereUniqueInput | Unlock_chapterWhereUniqueInput[]
  }

  export type Unlock_comicUncheckedCreateNestedManyWithoutTransactionInput = {
    create?: XOR<Unlock_comicCreateWithoutTransactionInput, Unlock_comicUncheckedCreateWithoutTransactionInput> | Unlock_comicCreateWithoutTransactionInput[] | Unlock_comicUncheckedCreateWithoutTransactionInput[]
    connectOrCreate?: Unlock_comicCreateOrConnectWithoutTransactionInput | Unlock_comicCreateOrConnectWithoutTransactionInput[]
    createMany?: Unlock_comicCreateManyTransactionInputEnvelope
    connect?: Unlock_comicWhereUniqueInput | Unlock_comicWhereUniqueInput[]
  }

  export type Unlock_volumeUncheckedCreateNestedManyWithoutTransactionInput = {
    create?: XOR<Unlock_volumeCreateWithoutTransactionInput, Unlock_volumeUncheckedCreateWithoutTransactionInput> | Unlock_volumeCreateWithoutTransactionInput[] | Unlock_volumeUncheckedCreateWithoutTransactionInput[]
    connectOrCreate?: Unlock_volumeCreateOrConnectWithoutTransactionInput | Unlock_volumeCreateOrConnectWithoutTransactionInput[]
    createMany?: Unlock_volumeCreateManyTransactionInputEnvelope
    connect?: Unlock_volumeWhereUniqueInput | Unlock_volumeWhereUniqueInput[]
  }

  export type Unlock_chapterUncheckedCreateNestedManyWithoutTransactionInput = {
    create?: XOR<Unlock_chapterCreateWithoutTransactionInput, Unlock_chapterUncheckedCreateWithoutTransactionInput> | Unlock_chapterCreateWithoutTransactionInput[] | Unlock_chapterUncheckedCreateWithoutTransactionInput[]
    connectOrCreate?: Unlock_chapterCreateOrConnectWithoutTransactionInput | Unlock_chapterCreateOrConnectWithoutTransactionInput[]
    createMany?: Unlock_chapterCreateManyTransactionInputEnvelope
    connect?: Unlock_chapterWhereUniqueInput | Unlock_chapterWhereUniqueInput[]
  }

  export type WalletsUpdateOneRequiredWithoutTransactionsNestedInput = {
    create?: XOR<WalletsCreateWithoutTransactionsInput, WalletsUncheckedCreateWithoutTransactionsInput>
    connectOrCreate?: WalletsCreateOrConnectWithoutTransactionsInput
    upsert?: WalletsUpsertWithoutTransactionsInput
    connect?: WalletsWhereUniqueInput
    update?: XOR<XOR<WalletsUpdateToOneWithWhereWithoutTransactionsInput, WalletsUpdateWithoutTransactionsInput>, WalletsUncheckedUpdateWithoutTransactionsInput>
  }

  export type Unlock_comicUpdateManyWithoutTransactionNestedInput = {
    create?: XOR<Unlock_comicCreateWithoutTransactionInput, Unlock_comicUncheckedCreateWithoutTransactionInput> | Unlock_comicCreateWithoutTransactionInput[] | Unlock_comicUncheckedCreateWithoutTransactionInput[]
    connectOrCreate?: Unlock_comicCreateOrConnectWithoutTransactionInput | Unlock_comicCreateOrConnectWithoutTransactionInput[]
    upsert?: Unlock_comicUpsertWithWhereUniqueWithoutTransactionInput | Unlock_comicUpsertWithWhereUniqueWithoutTransactionInput[]
    createMany?: Unlock_comicCreateManyTransactionInputEnvelope
    set?: Unlock_comicWhereUniqueInput | Unlock_comicWhereUniqueInput[]
    disconnect?: Unlock_comicWhereUniqueInput | Unlock_comicWhereUniqueInput[]
    delete?: Unlock_comicWhereUniqueInput | Unlock_comicWhereUniqueInput[]
    connect?: Unlock_comicWhereUniqueInput | Unlock_comicWhereUniqueInput[]
    update?: Unlock_comicUpdateWithWhereUniqueWithoutTransactionInput | Unlock_comicUpdateWithWhereUniqueWithoutTransactionInput[]
    updateMany?: Unlock_comicUpdateManyWithWhereWithoutTransactionInput | Unlock_comicUpdateManyWithWhereWithoutTransactionInput[]
    deleteMany?: Unlock_comicScalarWhereInput | Unlock_comicScalarWhereInput[]
  }

  export type Unlock_volumeUpdateManyWithoutTransactionNestedInput = {
    create?: XOR<Unlock_volumeCreateWithoutTransactionInput, Unlock_volumeUncheckedCreateWithoutTransactionInput> | Unlock_volumeCreateWithoutTransactionInput[] | Unlock_volumeUncheckedCreateWithoutTransactionInput[]
    connectOrCreate?: Unlock_volumeCreateOrConnectWithoutTransactionInput | Unlock_volumeCreateOrConnectWithoutTransactionInput[]
    upsert?: Unlock_volumeUpsertWithWhereUniqueWithoutTransactionInput | Unlock_volumeUpsertWithWhereUniqueWithoutTransactionInput[]
    createMany?: Unlock_volumeCreateManyTransactionInputEnvelope
    set?: Unlock_volumeWhereUniqueInput | Unlock_volumeWhereUniqueInput[]
    disconnect?: Unlock_volumeWhereUniqueInput | Unlock_volumeWhereUniqueInput[]
    delete?: Unlock_volumeWhereUniqueInput | Unlock_volumeWhereUniqueInput[]
    connect?: Unlock_volumeWhereUniqueInput | Unlock_volumeWhereUniqueInput[]
    update?: Unlock_volumeUpdateWithWhereUniqueWithoutTransactionInput | Unlock_volumeUpdateWithWhereUniqueWithoutTransactionInput[]
    updateMany?: Unlock_volumeUpdateManyWithWhereWithoutTransactionInput | Unlock_volumeUpdateManyWithWhereWithoutTransactionInput[]
    deleteMany?: Unlock_volumeScalarWhereInput | Unlock_volumeScalarWhereInput[]
  }

  export type Unlock_chapterUpdateManyWithoutTransactionNestedInput = {
    create?: XOR<Unlock_chapterCreateWithoutTransactionInput, Unlock_chapterUncheckedCreateWithoutTransactionInput> | Unlock_chapterCreateWithoutTransactionInput[] | Unlock_chapterUncheckedCreateWithoutTransactionInput[]
    connectOrCreate?: Unlock_chapterCreateOrConnectWithoutTransactionInput | Unlock_chapterCreateOrConnectWithoutTransactionInput[]
    upsert?: Unlock_chapterUpsertWithWhereUniqueWithoutTransactionInput | Unlock_chapterUpsertWithWhereUniqueWithoutTransactionInput[]
    createMany?: Unlock_chapterCreateManyTransactionInputEnvelope
    set?: Unlock_chapterWhereUniqueInput | Unlock_chapterWhereUniqueInput[]
    disconnect?: Unlock_chapterWhereUniqueInput | Unlock_chapterWhereUniqueInput[]
    delete?: Unlock_chapterWhereUniqueInput | Unlock_chapterWhereUniqueInput[]
    connect?: Unlock_chapterWhereUniqueInput | Unlock_chapterWhereUniqueInput[]
    update?: Unlock_chapterUpdateWithWhereUniqueWithoutTransactionInput | Unlock_chapterUpdateWithWhereUniqueWithoutTransactionInput[]
    updateMany?: Unlock_chapterUpdateManyWithWhereWithoutTransactionInput | Unlock_chapterUpdateManyWithWhereWithoutTransactionInput[]
    deleteMany?: Unlock_chapterScalarWhereInput | Unlock_chapterScalarWhereInput[]
  }

  export type Unlock_comicUncheckedUpdateManyWithoutTransactionNestedInput = {
    create?: XOR<Unlock_comicCreateWithoutTransactionInput, Unlock_comicUncheckedCreateWithoutTransactionInput> | Unlock_comicCreateWithoutTransactionInput[] | Unlock_comicUncheckedCreateWithoutTransactionInput[]
    connectOrCreate?: Unlock_comicCreateOrConnectWithoutTransactionInput | Unlock_comicCreateOrConnectWithoutTransactionInput[]
    upsert?: Unlock_comicUpsertWithWhereUniqueWithoutTransactionInput | Unlock_comicUpsertWithWhereUniqueWithoutTransactionInput[]
    createMany?: Unlock_comicCreateManyTransactionInputEnvelope
    set?: Unlock_comicWhereUniqueInput | Unlock_comicWhereUniqueInput[]
    disconnect?: Unlock_comicWhereUniqueInput | Unlock_comicWhereUniqueInput[]
    delete?: Unlock_comicWhereUniqueInput | Unlock_comicWhereUniqueInput[]
    connect?: Unlock_comicWhereUniqueInput | Unlock_comicWhereUniqueInput[]
    update?: Unlock_comicUpdateWithWhereUniqueWithoutTransactionInput | Unlock_comicUpdateWithWhereUniqueWithoutTransactionInput[]
    updateMany?: Unlock_comicUpdateManyWithWhereWithoutTransactionInput | Unlock_comicUpdateManyWithWhereWithoutTransactionInput[]
    deleteMany?: Unlock_comicScalarWhereInput | Unlock_comicScalarWhereInput[]
  }

  export type Unlock_volumeUncheckedUpdateManyWithoutTransactionNestedInput = {
    create?: XOR<Unlock_volumeCreateWithoutTransactionInput, Unlock_volumeUncheckedCreateWithoutTransactionInput> | Unlock_volumeCreateWithoutTransactionInput[] | Unlock_volumeUncheckedCreateWithoutTransactionInput[]
    connectOrCreate?: Unlock_volumeCreateOrConnectWithoutTransactionInput | Unlock_volumeCreateOrConnectWithoutTransactionInput[]
    upsert?: Unlock_volumeUpsertWithWhereUniqueWithoutTransactionInput | Unlock_volumeUpsertWithWhereUniqueWithoutTransactionInput[]
    createMany?: Unlock_volumeCreateManyTransactionInputEnvelope
    set?: Unlock_volumeWhereUniqueInput | Unlock_volumeWhereUniqueInput[]
    disconnect?: Unlock_volumeWhereUniqueInput | Unlock_volumeWhereUniqueInput[]
    delete?: Unlock_volumeWhereUniqueInput | Unlock_volumeWhereUniqueInput[]
    connect?: Unlock_volumeWhereUniqueInput | Unlock_volumeWhereUniqueInput[]
    update?: Unlock_volumeUpdateWithWhereUniqueWithoutTransactionInput | Unlock_volumeUpdateWithWhereUniqueWithoutTransactionInput[]
    updateMany?: Unlock_volumeUpdateManyWithWhereWithoutTransactionInput | Unlock_volumeUpdateManyWithWhereWithoutTransactionInput[]
    deleteMany?: Unlock_volumeScalarWhereInput | Unlock_volumeScalarWhereInput[]
  }

  export type Unlock_chapterUncheckedUpdateManyWithoutTransactionNestedInput = {
    create?: XOR<Unlock_chapterCreateWithoutTransactionInput, Unlock_chapterUncheckedCreateWithoutTransactionInput> | Unlock_chapterCreateWithoutTransactionInput[] | Unlock_chapterUncheckedCreateWithoutTransactionInput[]
    connectOrCreate?: Unlock_chapterCreateOrConnectWithoutTransactionInput | Unlock_chapterCreateOrConnectWithoutTransactionInput[]
    upsert?: Unlock_chapterUpsertWithWhereUniqueWithoutTransactionInput | Unlock_chapterUpsertWithWhereUniqueWithoutTransactionInput[]
    createMany?: Unlock_chapterCreateManyTransactionInputEnvelope
    set?: Unlock_chapterWhereUniqueInput | Unlock_chapterWhereUniqueInput[]
    disconnect?: Unlock_chapterWhereUniqueInput | Unlock_chapterWhereUniqueInput[]
    delete?: Unlock_chapterWhereUniqueInput | Unlock_chapterWhereUniqueInput[]
    connect?: Unlock_chapterWhereUniqueInput | Unlock_chapterWhereUniqueInput[]
    update?: Unlock_chapterUpdateWithWhereUniqueWithoutTransactionInput | Unlock_chapterUpdateWithWhereUniqueWithoutTransactionInput[]
    updateMany?: Unlock_chapterUpdateManyWithWhereWithoutTransactionInput | Unlock_chapterUpdateManyWithWhereWithoutTransactionInput[]
    deleteMany?: Unlock_chapterScalarWhereInput | Unlock_chapterScalarWhereInput[]
  }

  export type UsersCreateNestedOneWithoutUnlock_comicInput = {
    create?: XOR<UsersCreateWithoutUnlock_comicInput, UsersUncheckedCreateWithoutUnlock_comicInput>
    connectOrCreate?: UsersCreateOrConnectWithoutUnlock_comicInput
    connect?: UsersWhereUniqueInput
  }

  export type ComicsCreateNestedOneWithoutUnlock_comicInput = {
    create?: XOR<ComicsCreateWithoutUnlock_comicInput, ComicsUncheckedCreateWithoutUnlock_comicInput>
    connectOrCreate?: ComicsCreateOrConnectWithoutUnlock_comicInput
    connect?: ComicsWhereUniqueInput
  }

  export type TransactionsCreateNestedOneWithoutUnlock_comicInput = {
    create?: XOR<TransactionsCreateWithoutUnlock_comicInput, TransactionsUncheckedCreateWithoutUnlock_comicInput>
    connectOrCreate?: TransactionsCreateOrConnectWithoutUnlock_comicInput
    connect?: TransactionsWhereUniqueInput
  }

  export type UsersUpdateOneRequiredWithoutUnlock_comicNestedInput = {
    create?: XOR<UsersCreateWithoutUnlock_comicInput, UsersUncheckedCreateWithoutUnlock_comicInput>
    connectOrCreate?: UsersCreateOrConnectWithoutUnlock_comicInput
    upsert?: UsersUpsertWithoutUnlock_comicInput
    connect?: UsersWhereUniqueInput
    update?: XOR<XOR<UsersUpdateToOneWithWhereWithoutUnlock_comicInput, UsersUpdateWithoutUnlock_comicInput>, UsersUncheckedUpdateWithoutUnlock_comicInput>
  }

  export type ComicsUpdateOneRequiredWithoutUnlock_comicNestedInput = {
    create?: XOR<ComicsCreateWithoutUnlock_comicInput, ComicsUncheckedCreateWithoutUnlock_comicInput>
    connectOrCreate?: ComicsCreateOrConnectWithoutUnlock_comicInput
    upsert?: ComicsUpsertWithoutUnlock_comicInput
    connect?: ComicsWhereUniqueInput
    update?: XOR<XOR<ComicsUpdateToOneWithWhereWithoutUnlock_comicInput, ComicsUpdateWithoutUnlock_comicInput>, ComicsUncheckedUpdateWithoutUnlock_comicInput>
  }

  export type TransactionsUpdateOneRequiredWithoutUnlock_comicNestedInput = {
    create?: XOR<TransactionsCreateWithoutUnlock_comicInput, TransactionsUncheckedCreateWithoutUnlock_comicInput>
    connectOrCreate?: TransactionsCreateOrConnectWithoutUnlock_comicInput
    upsert?: TransactionsUpsertWithoutUnlock_comicInput
    connect?: TransactionsWhereUniqueInput
    update?: XOR<XOR<TransactionsUpdateToOneWithWhereWithoutUnlock_comicInput, TransactionsUpdateWithoutUnlock_comicInput>, TransactionsUncheckedUpdateWithoutUnlock_comicInput>
  }

  export type UsersCreateNestedOneWithoutUnlock_volumeInput = {
    create?: XOR<UsersCreateWithoutUnlock_volumeInput, UsersUncheckedCreateWithoutUnlock_volumeInput>
    connectOrCreate?: UsersCreateOrConnectWithoutUnlock_volumeInput
    connect?: UsersWhereUniqueInput
  }

  export type VolumesCreateNestedOneWithoutUnlock_volumeInput = {
    create?: XOR<VolumesCreateWithoutUnlock_volumeInput, VolumesUncheckedCreateWithoutUnlock_volumeInput>
    connectOrCreate?: VolumesCreateOrConnectWithoutUnlock_volumeInput
    connect?: VolumesWhereUniqueInput
  }

  export type TransactionsCreateNestedOneWithoutUnlock_volumeInput = {
    create?: XOR<TransactionsCreateWithoutUnlock_volumeInput, TransactionsUncheckedCreateWithoutUnlock_volumeInput>
    connectOrCreate?: TransactionsCreateOrConnectWithoutUnlock_volumeInput
    connect?: TransactionsWhereUniqueInput
  }

  export type UsersUpdateOneRequiredWithoutUnlock_volumeNestedInput = {
    create?: XOR<UsersCreateWithoutUnlock_volumeInput, UsersUncheckedCreateWithoutUnlock_volumeInput>
    connectOrCreate?: UsersCreateOrConnectWithoutUnlock_volumeInput
    upsert?: UsersUpsertWithoutUnlock_volumeInput
    connect?: UsersWhereUniqueInput
    update?: XOR<XOR<UsersUpdateToOneWithWhereWithoutUnlock_volumeInput, UsersUpdateWithoutUnlock_volumeInput>, UsersUncheckedUpdateWithoutUnlock_volumeInput>
  }

  export type VolumesUpdateOneRequiredWithoutUnlock_volumeNestedInput = {
    create?: XOR<VolumesCreateWithoutUnlock_volumeInput, VolumesUncheckedCreateWithoutUnlock_volumeInput>
    connectOrCreate?: VolumesCreateOrConnectWithoutUnlock_volumeInput
    upsert?: VolumesUpsertWithoutUnlock_volumeInput
    connect?: VolumesWhereUniqueInput
    update?: XOR<XOR<VolumesUpdateToOneWithWhereWithoutUnlock_volumeInput, VolumesUpdateWithoutUnlock_volumeInput>, VolumesUncheckedUpdateWithoutUnlock_volumeInput>
  }

  export type TransactionsUpdateOneRequiredWithoutUnlock_volumeNestedInput = {
    create?: XOR<TransactionsCreateWithoutUnlock_volumeInput, TransactionsUncheckedCreateWithoutUnlock_volumeInput>
    connectOrCreate?: TransactionsCreateOrConnectWithoutUnlock_volumeInput
    upsert?: TransactionsUpsertWithoutUnlock_volumeInput
    connect?: TransactionsWhereUniqueInput
    update?: XOR<XOR<TransactionsUpdateToOneWithWhereWithoutUnlock_volumeInput, TransactionsUpdateWithoutUnlock_volumeInput>, TransactionsUncheckedUpdateWithoutUnlock_volumeInput>
  }

  export type UsersCreateNestedOneWithoutUnlock_chapterInput = {
    create?: XOR<UsersCreateWithoutUnlock_chapterInput, UsersUncheckedCreateWithoutUnlock_chapterInput>
    connectOrCreate?: UsersCreateOrConnectWithoutUnlock_chapterInput
    connect?: UsersWhereUniqueInput
  }

  export type ChaptersCreateNestedOneWithoutUnlock_chapterInput = {
    create?: XOR<ChaptersCreateWithoutUnlock_chapterInput, ChaptersUncheckedCreateWithoutUnlock_chapterInput>
    connectOrCreate?: ChaptersCreateOrConnectWithoutUnlock_chapterInput
    connect?: ChaptersWhereUniqueInput
  }

  export type TransactionsCreateNestedOneWithoutUnlock_chapterInput = {
    create?: XOR<TransactionsCreateWithoutUnlock_chapterInput, TransactionsUncheckedCreateWithoutUnlock_chapterInput>
    connectOrCreate?: TransactionsCreateOrConnectWithoutUnlock_chapterInput
    connect?: TransactionsWhereUniqueInput
  }

  export type UsersUpdateOneRequiredWithoutUnlock_chapterNestedInput = {
    create?: XOR<UsersCreateWithoutUnlock_chapterInput, UsersUncheckedCreateWithoutUnlock_chapterInput>
    connectOrCreate?: UsersCreateOrConnectWithoutUnlock_chapterInput
    upsert?: UsersUpsertWithoutUnlock_chapterInput
    connect?: UsersWhereUniqueInput
    update?: XOR<XOR<UsersUpdateToOneWithWhereWithoutUnlock_chapterInput, UsersUpdateWithoutUnlock_chapterInput>, UsersUncheckedUpdateWithoutUnlock_chapterInput>
  }

  export type ChaptersUpdateOneRequiredWithoutUnlock_chapterNestedInput = {
    create?: XOR<ChaptersCreateWithoutUnlock_chapterInput, ChaptersUncheckedCreateWithoutUnlock_chapterInput>
    connectOrCreate?: ChaptersCreateOrConnectWithoutUnlock_chapterInput
    upsert?: ChaptersUpsertWithoutUnlock_chapterInput
    connect?: ChaptersWhereUniqueInput
    update?: XOR<XOR<ChaptersUpdateToOneWithWhereWithoutUnlock_chapterInput, ChaptersUpdateWithoutUnlock_chapterInput>, ChaptersUncheckedUpdateWithoutUnlock_chapterInput>
  }

  export type TransactionsUpdateOneRequiredWithoutUnlock_chapterNestedInput = {
    create?: XOR<TransactionsCreateWithoutUnlock_chapterInput, TransactionsUncheckedCreateWithoutUnlock_chapterInput>
    connectOrCreate?: TransactionsCreateOrConnectWithoutUnlock_chapterInput
    upsert?: TransactionsUpsertWithoutUnlock_chapterInput
    connect?: TransactionsWhereUniqueInput
    update?: XOR<XOR<TransactionsUpdateToOneWithWhereWithoutUnlock_chapterInput, TransactionsUpdateWithoutUnlock_chapterInput>, TransactionsUncheckedUpdateWithoutUnlock_chapterInput>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedDecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[]
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[]
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedDecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[]
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[]
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type ComicsCreateWithoutCategoriesInput = {
    title: string
    description: string
    image: string
    keywords: string
    status: string
    price: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
    authors?: AuthorsCreateNestedManyWithoutComicsInput
    volumes?: VolumesCreateNestedManyWithoutComicInput
    favorites?: FavoritesCreateNestedManyWithoutComicInput
    rates?: RatesCreateNestedManyWithoutComicInput
    views?: ViewsCreateNestedManyWithoutComicInput
    comment?: CommentsCreateNestedManyWithoutComicInput
    unlock_comic?: Unlock_comicCreateNestedManyWithoutComicInput
    user: UsersCreateNestedOneWithoutComicsInput
  }

  export type ComicsUncheckedCreateWithoutCategoriesInput = {
    id?: number
    title: string
    description: string
    image: string
    keywords: string
    status: string
    price: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
    userId: number
    authors?: AuthorsUncheckedCreateNestedManyWithoutComicsInput
    volumes?: VolumesUncheckedCreateNestedManyWithoutComicInput
    favorites?: FavoritesUncheckedCreateNestedManyWithoutComicInput
    rates?: RatesUncheckedCreateNestedManyWithoutComicInput
    views?: ViewsUncheckedCreateNestedManyWithoutComicInput
    comment?: CommentsUncheckedCreateNestedManyWithoutComicInput
    unlock_comic?: Unlock_comicUncheckedCreateNestedManyWithoutComicInput
  }

  export type ComicsCreateOrConnectWithoutCategoriesInput = {
    where: ComicsWhereUniqueInput
    create: XOR<ComicsCreateWithoutCategoriesInput, ComicsUncheckedCreateWithoutCategoriesInput>
  }

  export type ComicsUpsertWithWhereUniqueWithoutCategoriesInput = {
    where: ComicsWhereUniqueInput
    update: XOR<ComicsUpdateWithoutCategoriesInput, ComicsUncheckedUpdateWithoutCategoriesInput>
    create: XOR<ComicsCreateWithoutCategoriesInput, ComicsUncheckedCreateWithoutCategoriesInput>
  }

  export type ComicsUpdateWithWhereUniqueWithoutCategoriesInput = {
    where: ComicsWhereUniqueInput
    data: XOR<ComicsUpdateWithoutCategoriesInput, ComicsUncheckedUpdateWithoutCategoriesInput>
  }

  export type ComicsUpdateManyWithWhereWithoutCategoriesInput = {
    where: ComicsScalarWhereInput
    data: XOR<ComicsUpdateManyMutationInput, ComicsUncheckedUpdateManyWithoutCategoriesInput>
  }

  export type ComicsScalarWhereInput = {
    AND?: ComicsScalarWhereInput | ComicsScalarWhereInput[]
    OR?: ComicsScalarWhereInput[]
    NOT?: ComicsScalarWhereInput | ComicsScalarWhereInput[]
    id?: IntFilter<"Comics"> | number
    title?: StringFilter<"Comics"> | string
    description?: StringFilter<"Comics"> | string
    image?: StringFilter<"Comics"> | string
    keywords?: StringFilter<"Comics"> | string
    status?: StringFilter<"Comics"> | string
    price?: DecimalFilter<"Comics"> | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFilter<"Comics"> | Date | string
    updatedAt?: DateTimeFilter<"Comics"> | Date | string
    userId?: IntFilter<"Comics"> | number
  }

  export type ComicsCreateWithoutAuthorsInput = {
    title: string
    description: string
    image: string
    keywords: string
    status: string
    price: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
    categories?: CategoriesCreateNestedManyWithoutComicsInput
    volumes?: VolumesCreateNestedManyWithoutComicInput
    favorites?: FavoritesCreateNestedManyWithoutComicInput
    rates?: RatesCreateNestedManyWithoutComicInput
    views?: ViewsCreateNestedManyWithoutComicInput
    comment?: CommentsCreateNestedManyWithoutComicInput
    unlock_comic?: Unlock_comicCreateNestedManyWithoutComicInput
    user: UsersCreateNestedOneWithoutComicsInput
  }

  export type ComicsUncheckedCreateWithoutAuthorsInput = {
    id?: number
    title: string
    description: string
    image: string
    keywords: string
    status: string
    price: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
    userId: number
    categories?: CategoriesUncheckedCreateNestedManyWithoutComicsInput
    volumes?: VolumesUncheckedCreateNestedManyWithoutComicInput
    favorites?: FavoritesUncheckedCreateNestedManyWithoutComicInput
    rates?: RatesUncheckedCreateNestedManyWithoutComicInput
    views?: ViewsUncheckedCreateNestedManyWithoutComicInput
    comment?: CommentsUncheckedCreateNestedManyWithoutComicInput
    unlock_comic?: Unlock_comicUncheckedCreateNestedManyWithoutComicInput
  }

  export type ComicsCreateOrConnectWithoutAuthorsInput = {
    where: ComicsWhereUniqueInput
    create: XOR<ComicsCreateWithoutAuthorsInput, ComicsUncheckedCreateWithoutAuthorsInput>
  }

  export type ComicsUpsertWithWhereUniqueWithoutAuthorsInput = {
    where: ComicsWhereUniqueInput
    update: XOR<ComicsUpdateWithoutAuthorsInput, ComicsUncheckedUpdateWithoutAuthorsInput>
    create: XOR<ComicsCreateWithoutAuthorsInput, ComicsUncheckedCreateWithoutAuthorsInput>
  }

  export type ComicsUpdateWithWhereUniqueWithoutAuthorsInput = {
    where: ComicsWhereUniqueInput
    data: XOR<ComicsUpdateWithoutAuthorsInput, ComicsUncheckedUpdateWithoutAuthorsInput>
  }

  export type ComicsUpdateManyWithWhereWithoutAuthorsInput = {
    where: ComicsScalarWhereInput
    data: XOR<ComicsUpdateManyMutationInput, ComicsUncheckedUpdateManyWithoutAuthorsInput>
  }

  export type CategoriesCreateWithoutComicsInput = {
    title: string
  }

  export type CategoriesUncheckedCreateWithoutComicsInput = {
    id?: number
    title: string
  }

  export type CategoriesCreateOrConnectWithoutComicsInput = {
    where: CategoriesWhereUniqueInput
    create: XOR<CategoriesCreateWithoutComicsInput, CategoriesUncheckedCreateWithoutComicsInput>
  }

  export type AuthorsCreateWithoutComicsInput = {
    name: string
    description: string
    keywords: string
  }

  export type AuthorsUncheckedCreateWithoutComicsInput = {
    id?: number
    name: string
    description: string
    keywords: string
  }

  export type AuthorsCreateOrConnectWithoutComicsInput = {
    where: AuthorsWhereUniqueInput
    create: XOR<AuthorsCreateWithoutComicsInput, AuthorsUncheckedCreateWithoutComicsInput>
  }

  export type VolumesCreateWithoutComicInput = {
    title: string
    description: string
    price: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
    chapters?: ChaptersCreateNestedManyWithoutVolumeInput
    unlock_volume?: Unlock_volumeCreateNestedManyWithoutVolumeInput
  }

  export type VolumesUncheckedCreateWithoutComicInput = {
    id?: number
    title: string
    description: string
    price: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
    chapters?: ChaptersUncheckedCreateNestedManyWithoutVolumeInput
    unlock_volume?: Unlock_volumeUncheckedCreateNestedManyWithoutVolumeInput
  }

  export type VolumesCreateOrConnectWithoutComicInput = {
    where: VolumesWhereUniqueInput
    create: XOR<VolumesCreateWithoutComicInput, VolumesUncheckedCreateWithoutComicInput>
  }

  export type VolumesCreateManyComicInputEnvelope = {
    data: VolumesCreateManyComicInput | VolumesCreateManyComicInput[]
    skipDuplicates?: boolean
  }

  export type FavoritesCreateWithoutComicInput = {
    addedAt?: Date | string
    user: UsersCreateNestedOneWithoutFavoritesInput
  }

  export type FavoritesUncheckedCreateWithoutComicInput = {
    userId: number
    addedAt?: Date | string
  }

  export type FavoritesCreateOrConnectWithoutComicInput = {
    where: FavoritesWhereUniqueInput
    create: XOR<FavoritesCreateWithoutComicInput, FavoritesUncheckedCreateWithoutComicInput>
  }

  export type FavoritesCreateManyComicInputEnvelope = {
    data: FavoritesCreateManyComicInput | FavoritesCreateManyComicInput[]
    skipDuplicates?: boolean
  }

  export type RatesCreateWithoutComicInput = {
    score?: number
    content: string
    createdAt?: Date | string
    user: UsersCreateNestedOneWithoutRatesInput
  }

  export type RatesUncheckedCreateWithoutComicInput = {
    userId: number
    score?: number
    content: string
    createdAt?: Date | string
  }

  export type RatesCreateOrConnectWithoutComicInput = {
    where: RatesWhereUniqueInput
    create: XOR<RatesCreateWithoutComicInput, RatesUncheckedCreateWithoutComicInput>
  }

  export type RatesCreateManyComicInputEnvelope = {
    data: RatesCreateManyComicInput | RatesCreateManyComicInput[]
    skipDuplicates?: boolean
  }

  export type ViewsCreateWithoutComicInput = {
    lastedAt?: Date | string
    user: UsersCreateNestedOneWithoutViewsInput
    chapter: ChaptersCreateNestedOneWithoutViewsInput
  }

  export type ViewsUncheckedCreateWithoutComicInput = {
    userId: number
    chapterId: number
    lastedAt?: Date | string
  }

  export type ViewsCreateOrConnectWithoutComicInput = {
    where: ViewsWhereUniqueInput
    create: XOR<ViewsCreateWithoutComicInput, ViewsUncheckedCreateWithoutComicInput>
  }

  export type ViewsCreateManyComicInputEnvelope = {
    data: ViewsCreateManyComicInput | ViewsCreateManyComicInput[]
    skipDuplicates?: boolean
  }

  export type CommentsCreateWithoutComicInput = {
    content: string
    createdAt?: Date | string
    user: UsersCreateNestedOneWithoutComentsInput
    chapter?: ChaptersCreateNestedOneWithoutComentsInput
    notification?: NotificationsCreateNestedManyWithoutCommentInput
  }

  export type CommentsUncheckedCreateWithoutComicInput = {
    id?: number
    content: string
    userId: number
    chapterId?: number | null
    createdAt?: Date | string
    notification?: NotificationsUncheckedCreateNestedManyWithoutCommentInput
  }

  export type CommentsCreateOrConnectWithoutComicInput = {
    where: CommentsWhereUniqueInput
    create: XOR<CommentsCreateWithoutComicInput, CommentsUncheckedCreateWithoutComicInput>
  }

  export type CommentsCreateManyComicInputEnvelope = {
    data: CommentsCreateManyComicInput | CommentsCreateManyComicInput[]
    skipDuplicates?: boolean
  }

  export type Unlock_comicCreateWithoutComicInput = {
    createdAt?: Date | string
    user: UsersCreateNestedOneWithoutUnlock_comicInput
    transaction: TransactionsCreateNestedOneWithoutUnlock_comicInput
  }

  export type Unlock_comicUncheckedCreateWithoutComicInput = {
    userId: number
    transactionId: number
    createdAt?: Date | string
  }

  export type Unlock_comicCreateOrConnectWithoutComicInput = {
    where: Unlock_comicWhereUniqueInput
    create: XOR<Unlock_comicCreateWithoutComicInput, Unlock_comicUncheckedCreateWithoutComicInput>
  }

  export type Unlock_comicCreateManyComicInputEnvelope = {
    data: Unlock_comicCreateManyComicInput | Unlock_comicCreateManyComicInput[]
    skipDuplicates?: boolean
  }

  export type UsersCreateWithoutComicsInput = {
    name: string
    email: string
    password: string
    description: string
    createdAt?: Date | string
    updatedAt?: Date | string
    isDisabled: boolean
    userRole?: RolesCreateNestedManyWithoutUsersInput
    favorites?: FavoritesCreateNestedManyWithoutUserInput
    rates?: RatesCreateNestedManyWithoutUserInput
    errors?: ErrorsCreateNestedManyWithoutUserInput
    views?: ViewsCreateNestedManyWithoutUserInput
    coments?: CommentsCreateNestedManyWithoutUserInput
    notifications?: NotificationsCreateNestedManyWithoutUserInput
    wallets?: WalletsCreateNestedOneWithoutUserInput
    unlock_comic?: Unlock_comicCreateNestedManyWithoutUserInput
    unlock_volume?: Unlock_volumeCreateNestedManyWithoutUserInput
    unlock_chapter?: Unlock_chapterCreateNestedManyWithoutUserInput
  }

  export type UsersUncheckedCreateWithoutComicsInput = {
    id?: number
    name: string
    email: string
    password: string
    description: string
    createdAt?: Date | string
    updatedAt?: Date | string
    isDisabled: boolean
    userRole?: RolesUncheckedCreateNestedManyWithoutUsersInput
    favorites?: FavoritesUncheckedCreateNestedManyWithoutUserInput
    rates?: RatesUncheckedCreateNestedManyWithoutUserInput
    errors?: ErrorsUncheckedCreateNestedManyWithoutUserInput
    views?: ViewsUncheckedCreateNestedManyWithoutUserInput
    coments?: CommentsUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationsUncheckedCreateNestedManyWithoutUserInput
    wallets?: WalletsUncheckedCreateNestedOneWithoutUserInput
    unlock_comic?: Unlock_comicUncheckedCreateNestedManyWithoutUserInput
    unlock_volume?: Unlock_volumeUncheckedCreateNestedManyWithoutUserInput
    unlock_chapter?: Unlock_chapterUncheckedCreateNestedManyWithoutUserInput
  }

  export type UsersCreateOrConnectWithoutComicsInput = {
    where: UsersWhereUniqueInput
    create: XOR<UsersCreateWithoutComicsInput, UsersUncheckedCreateWithoutComicsInput>
  }

  export type CategoriesUpsertWithWhereUniqueWithoutComicsInput = {
    where: CategoriesWhereUniqueInput
    update: XOR<CategoriesUpdateWithoutComicsInput, CategoriesUncheckedUpdateWithoutComicsInput>
    create: XOR<CategoriesCreateWithoutComicsInput, CategoriesUncheckedCreateWithoutComicsInput>
  }

  export type CategoriesUpdateWithWhereUniqueWithoutComicsInput = {
    where: CategoriesWhereUniqueInput
    data: XOR<CategoriesUpdateWithoutComicsInput, CategoriesUncheckedUpdateWithoutComicsInput>
  }

  export type CategoriesUpdateManyWithWhereWithoutComicsInput = {
    where: CategoriesScalarWhereInput
    data: XOR<CategoriesUpdateManyMutationInput, CategoriesUncheckedUpdateManyWithoutComicsInput>
  }

  export type CategoriesScalarWhereInput = {
    AND?: CategoriesScalarWhereInput | CategoriesScalarWhereInput[]
    OR?: CategoriesScalarWhereInput[]
    NOT?: CategoriesScalarWhereInput | CategoriesScalarWhereInput[]
    id?: IntFilter<"Categories"> | number
    title?: StringFilter<"Categories"> | string
  }

  export type AuthorsUpsertWithWhereUniqueWithoutComicsInput = {
    where: AuthorsWhereUniqueInput
    update: XOR<AuthorsUpdateWithoutComicsInput, AuthorsUncheckedUpdateWithoutComicsInput>
    create: XOR<AuthorsCreateWithoutComicsInput, AuthorsUncheckedCreateWithoutComicsInput>
  }

  export type AuthorsUpdateWithWhereUniqueWithoutComicsInput = {
    where: AuthorsWhereUniqueInput
    data: XOR<AuthorsUpdateWithoutComicsInput, AuthorsUncheckedUpdateWithoutComicsInput>
  }

  export type AuthorsUpdateManyWithWhereWithoutComicsInput = {
    where: AuthorsScalarWhereInput
    data: XOR<AuthorsUpdateManyMutationInput, AuthorsUncheckedUpdateManyWithoutComicsInput>
  }

  export type AuthorsScalarWhereInput = {
    AND?: AuthorsScalarWhereInput | AuthorsScalarWhereInput[]
    OR?: AuthorsScalarWhereInput[]
    NOT?: AuthorsScalarWhereInput | AuthorsScalarWhereInput[]
    id?: IntFilter<"Authors"> | number
    name?: StringFilter<"Authors"> | string
    description?: StringFilter<"Authors"> | string
    keywords?: StringFilter<"Authors"> | string
  }

  export type VolumesUpsertWithWhereUniqueWithoutComicInput = {
    where: VolumesWhereUniqueInput
    update: XOR<VolumesUpdateWithoutComicInput, VolumesUncheckedUpdateWithoutComicInput>
    create: XOR<VolumesCreateWithoutComicInput, VolumesUncheckedCreateWithoutComicInput>
  }

  export type VolumesUpdateWithWhereUniqueWithoutComicInput = {
    where: VolumesWhereUniqueInput
    data: XOR<VolumesUpdateWithoutComicInput, VolumesUncheckedUpdateWithoutComicInput>
  }

  export type VolumesUpdateManyWithWhereWithoutComicInput = {
    where: VolumesScalarWhereInput
    data: XOR<VolumesUpdateManyMutationInput, VolumesUncheckedUpdateManyWithoutComicInput>
  }

  export type VolumesScalarWhereInput = {
    AND?: VolumesScalarWhereInput | VolumesScalarWhereInput[]
    OR?: VolumesScalarWhereInput[]
    NOT?: VolumesScalarWhereInput | VolumesScalarWhereInput[]
    id?: IntFilter<"Volumes"> | number
    title?: StringFilter<"Volumes"> | string
    description?: StringFilter<"Volumes"> | string
    price?: DecimalFilter<"Volumes"> | Decimal | DecimalJsLike | number | string
    comicId?: IntFilter<"Volumes"> | number
    createdAt?: DateTimeFilter<"Volumes"> | Date | string
    updatedAt?: DateTimeFilter<"Volumes"> | Date | string
  }

  export type FavoritesUpsertWithWhereUniqueWithoutComicInput = {
    where: FavoritesWhereUniqueInput
    update: XOR<FavoritesUpdateWithoutComicInput, FavoritesUncheckedUpdateWithoutComicInput>
    create: XOR<FavoritesCreateWithoutComicInput, FavoritesUncheckedCreateWithoutComicInput>
  }

  export type FavoritesUpdateWithWhereUniqueWithoutComicInput = {
    where: FavoritesWhereUniqueInput
    data: XOR<FavoritesUpdateWithoutComicInput, FavoritesUncheckedUpdateWithoutComicInput>
  }

  export type FavoritesUpdateManyWithWhereWithoutComicInput = {
    where: FavoritesScalarWhereInput
    data: XOR<FavoritesUpdateManyMutationInput, FavoritesUncheckedUpdateManyWithoutComicInput>
  }

  export type FavoritesScalarWhereInput = {
    AND?: FavoritesScalarWhereInput | FavoritesScalarWhereInput[]
    OR?: FavoritesScalarWhereInput[]
    NOT?: FavoritesScalarWhereInput | FavoritesScalarWhereInput[]
    userId?: IntFilter<"Favorites"> | number
    comicId?: IntFilter<"Favorites"> | number
    addedAt?: DateTimeFilter<"Favorites"> | Date | string
  }

  export type RatesUpsertWithWhereUniqueWithoutComicInput = {
    where: RatesWhereUniqueInput
    update: XOR<RatesUpdateWithoutComicInput, RatesUncheckedUpdateWithoutComicInput>
    create: XOR<RatesCreateWithoutComicInput, RatesUncheckedCreateWithoutComicInput>
  }

  export type RatesUpdateWithWhereUniqueWithoutComicInput = {
    where: RatesWhereUniqueInput
    data: XOR<RatesUpdateWithoutComicInput, RatesUncheckedUpdateWithoutComicInput>
  }

  export type RatesUpdateManyWithWhereWithoutComicInput = {
    where: RatesScalarWhereInput
    data: XOR<RatesUpdateManyMutationInput, RatesUncheckedUpdateManyWithoutComicInput>
  }

  export type RatesScalarWhereInput = {
    AND?: RatesScalarWhereInput | RatesScalarWhereInput[]
    OR?: RatesScalarWhereInput[]
    NOT?: RatesScalarWhereInput | RatesScalarWhereInput[]
    userId?: IntFilter<"Rates"> | number
    comicId?: IntFilter<"Rates"> | number
    score?: FloatFilter<"Rates"> | number
    content?: StringFilter<"Rates"> | string
    createdAt?: DateTimeFilter<"Rates"> | Date | string
  }

  export type ViewsUpsertWithWhereUniqueWithoutComicInput = {
    where: ViewsWhereUniqueInput
    update: XOR<ViewsUpdateWithoutComicInput, ViewsUncheckedUpdateWithoutComicInput>
    create: XOR<ViewsCreateWithoutComicInput, ViewsUncheckedCreateWithoutComicInput>
  }

  export type ViewsUpdateWithWhereUniqueWithoutComicInput = {
    where: ViewsWhereUniqueInput
    data: XOR<ViewsUpdateWithoutComicInput, ViewsUncheckedUpdateWithoutComicInput>
  }

  export type ViewsUpdateManyWithWhereWithoutComicInput = {
    where: ViewsScalarWhereInput
    data: XOR<ViewsUpdateManyMutationInput, ViewsUncheckedUpdateManyWithoutComicInput>
  }

  export type ViewsScalarWhereInput = {
    AND?: ViewsScalarWhereInput | ViewsScalarWhereInput[]
    OR?: ViewsScalarWhereInput[]
    NOT?: ViewsScalarWhereInput | ViewsScalarWhereInput[]
    userId?: IntFilter<"Views"> | number
    comicId?: IntFilter<"Views"> | number
    chapterId?: IntFilter<"Views"> | number
    lastedAt?: DateTimeFilter<"Views"> | Date | string
  }

  export type CommentsUpsertWithWhereUniqueWithoutComicInput = {
    where: CommentsWhereUniqueInput
    update: XOR<CommentsUpdateWithoutComicInput, CommentsUncheckedUpdateWithoutComicInput>
    create: XOR<CommentsCreateWithoutComicInput, CommentsUncheckedCreateWithoutComicInput>
  }

  export type CommentsUpdateWithWhereUniqueWithoutComicInput = {
    where: CommentsWhereUniqueInput
    data: XOR<CommentsUpdateWithoutComicInput, CommentsUncheckedUpdateWithoutComicInput>
  }

  export type CommentsUpdateManyWithWhereWithoutComicInput = {
    where: CommentsScalarWhereInput
    data: XOR<CommentsUpdateManyMutationInput, CommentsUncheckedUpdateManyWithoutComicInput>
  }

  export type CommentsScalarWhereInput = {
    AND?: CommentsScalarWhereInput | CommentsScalarWhereInput[]
    OR?: CommentsScalarWhereInput[]
    NOT?: CommentsScalarWhereInput | CommentsScalarWhereInput[]
    id?: IntFilter<"Comments"> | number
    content?: StringFilter<"Comments"> | string
    userId?: IntFilter<"Comments"> | number
    chapterId?: IntNullableFilter<"Comments"> | number | null
    comicId?: IntFilter<"Comments"> | number
    createdAt?: DateTimeFilter<"Comments"> | Date | string
  }

  export type Unlock_comicUpsertWithWhereUniqueWithoutComicInput = {
    where: Unlock_comicWhereUniqueInput
    update: XOR<Unlock_comicUpdateWithoutComicInput, Unlock_comicUncheckedUpdateWithoutComicInput>
    create: XOR<Unlock_comicCreateWithoutComicInput, Unlock_comicUncheckedCreateWithoutComicInput>
  }

  export type Unlock_comicUpdateWithWhereUniqueWithoutComicInput = {
    where: Unlock_comicWhereUniqueInput
    data: XOR<Unlock_comicUpdateWithoutComicInput, Unlock_comicUncheckedUpdateWithoutComicInput>
  }

  export type Unlock_comicUpdateManyWithWhereWithoutComicInput = {
    where: Unlock_comicScalarWhereInput
    data: XOR<Unlock_comicUpdateManyMutationInput, Unlock_comicUncheckedUpdateManyWithoutComicInput>
  }

  export type Unlock_comicScalarWhereInput = {
    AND?: Unlock_comicScalarWhereInput | Unlock_comicScalarWhereInput[]
    OR?: Unlock_comicScalarWhereInput[]
    NOT?: Unlock_comicScalarWhereInput | Unlock_comicScalarWhereInput[]
    userId?: IntFilter<"Unlock_comic"> | number
    comicId?: IntFilter<"Unlock_comic"> | number
    transactionId?: IntFilter<"Unlock_comic"> | number
    createdAt?: DateTimeFilter<"Unlock_comic"> | Date | string
  }

  export type UsersUpsertWithoutComicsInput = {
    update: XOR<UsersUpdateWithoutComicsInput, UsersUncheckedUpdateWithoutComicsInput>
    create: XOR<UsersCreateWithoutComicsInput, UsersUncheckedCreateWithoutComicsInput>
    where?: UsersWhereInput
  }

  export type UsersUpdateToOneWithWhereWithoutComicsInput = {
    where?: UsersWhereInput
    data: XOR<UsersUpdateWithoutComicsInput, UsersUncheckedUpdateWithoutComicsInput>
  }

  export type UsersUpdateWithoutComicsInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDisabled?: BoolFieldUpdateOperationsInput | boolean
    userRole?: RolesUpdateManyWithoutUsersNestedInput
    favorites?: FavoritesUpdateManyWithoutUserNestedInput
    rates?: RatesUpdateManyWithoutUserNestedInput
    errors?: ErrorsUpdateManyWithoutUserNestedInput
    views?: ViewsUpdateManyWithoutUserNestedInput
    coments?: CommentsUpdateManyWithoutUserNestedInput
    notifications?: NotificationsUpdateManyWithoutUserNestedInput
    wallets?: WalletsUpdateOneWithoutUserNestedInput
    unlock_comic?: Unlock_comicUpdateManyWithoutUserNestedInput
    unlock_volume?: Unlock_volumeUpdateManyWithoutUserNestedInput
    unlock_chapter?: Unlock_chapterUpdateManyWithoutUserNestedInput
  }

  export type UsersUncheckedUpdateWithoutComicsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDisabled?: BoolFieldUpdateOperationsInput | boolean
    userRole?: RolesUncheckedUpdateManyWithoutUsersNestedInput
    favorites?: FavoritesUncheckedUpdateManyWithoutUserNestedInput
    rates?: RatesUncheckedUpdateManyWithoutUserNestedInput
    errors?: ErrorsUncheckedUpdateManyWithoutUserNestedInput
    views?: ViewsUncheckedUpdateManyWithoutUserNestedInput
    coments?: CommentsUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationsUncheckedUpdateManyWithoutUserNestedInput
    wallets?: WalletsUncheckedUpdateOneWithoutUserNestedInput
    unlock_comic?: Unlock_comicUncheckedUpdateManyWithoutUserNestedInput
    unlock_volume?: Unlock_volumeUncheckedUpdateManyWithoutUserNestedInput
    unlock_chapter?: Unlock_chapterUncheckedUpdateManyWithoutUserNestedInput
  }

  export type ComicsCreateWithoutVolumesInput = {
    title: string
    description: string
    image: string
    keywords: string
    status: string
    price: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
    categories?: CategoriesCreateNestedManyWithoutComicsInput
    authors?: AuthorsCreateNestedManyWithoutComicsInput
    favorites?: FavoritesCreateNestedManyWithoutComicInput
    rates?: RatesCreateNestedManyWithoutComicInput
    views?: ViewsCreateNestedManyWithoutComicInput
    comment?: CommentsCreateNestedManyWithoutComicInput
    unlock_comic?: Unlock_comicCreateNestedManyWithoutComicInput
    user: UsersCreateNestedOneWithoutComicsInput
  }

  export type ComicsUncheckedCreateWithoutVolumesInput = {
    id?: number
    title: string
    description: string
    image: string
    keywords: string
    status: string
    price: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
    userId: number
    categories?: CategoriesUncheckedCreateNestedManyWithoutComicsInput
    authors?: AuthorsUncheckedCreateNestedManyWithoutComicsInput
    favorites?: FavoritesUncheckedCreateNestedManyWithoutComicInput
    rates?: RatesUncheckedCreateNestedManyWithoutComicInput
    views?: ViewsUncheckedCreateNestedManyWithoutComicInput
    comment?: CommentsUncheckedCreateNestedManyWithoutComicInput
    unlock_comic?: Unlock_comicUncheckedCreateNestedManyWithoutComicInput
  }

  export type ComicsCreateOrConnectWithoutVolumesInput = {
    where: ComicsWhereUniqueInput
    create: XOR<ComicsCreateWithoutVolumesInput, ComicsUncheckedCreateWithoutVolumesInput>
  }

  export type ChaptersCreateWithoutVolumeInput = {
    title: string
    filePath: string
    content: string
    price: Decimal | DecimalJsLike | number | string
    lock: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    errors?: ErrorsCreateNestedManyWithoutChapterInput
    views?: ViewsCreateNestedManyWithoutChapterInput
    coments?: CommentsCreateNestedManyWithoutChapterInput
    unlock_chapter?: Unlock_chapterCreateNestedManyWithoutChapterInput
  }

  export type ChaptersUncheckedCreateWithoutVolumeInput = {
    id?: number
    title: string
    filePath: string
    content: string
    price: Decimal | DecimalJsLike | number | string
    lock: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    errors?: ErrorsUncheckedCreateNestedManyWithoutChapterInput
    views?: ViewsUncheckedCreateNestedManyWithoutChapterInput
    coments?: CommentsUncheckedCreateNestedManyWithoutChapterInput
    unlock_chapter?: Unlock_chapterUncheckedCreateNestedManyWithoutChapterInput
  }

  export type ChaptersCreateOrConnectWithoutVolumeInput = {
    where: ChaptersWhereUniqueInput
    create: XOR<ChaptersCreateWithoutVolumeInput, ChaptersUncheckedCreateWithoutVolumeInput>
  }

  export type ChaptersCreateManyVolumeInputEnvelope = {
    data: ChaptersCreateManyVolumeInput | ChaptersCreateManyVolumeInput[]
    skipDuplicates?: boolean
  }

  export type Unlock_volumeCreateWithoutVolumeInput = {
    createdAt?: Date | string
    user: UsersCreateNestedOneWithoutUnlock_volumeInput
    transaction: TransactionsCreateNestedOneWithoutUnlock_volumeInput
  }

  export type Unlock_volumeUncheckedCreateWithoutVolumeInput = {
    userId: number
    transactionId: number
    createdAt?: Date | string
  }

  export type Unlock_volumeCreateOrConnectWithoutVolumeInput = {
    where: Unlock_volumeWhereUniqueInput
    create: XOR<Unlock_volumeCreateWithoutVolumeInput, Unlock_volumeUncheckedCreateWithoutVolumeInput>
  }

  export type Unlock_volumeCreateManyVolumeInputEnvelope = {
    data: Unlock_volumeCreateManyVolumeInput | Unlock_volumeCreateManyVolumeInput[]
    skipDuplicates?: boolean
  }

  export type ComicsUpsertWithoutVolumesInput = {
    update: XOR<ComicsUpdateWithoutVolumesInput, ComicsUncheckedUpdateWithoutVolumesInput>
    create: XOR<ComicsCreateWithoutVolumesInput, ComicsUncheckedCreateWithoutVolumesInput>
    where?: ComicsWhereInput
  }

  export type ComicsUpdateToOneWithWhereWithoutVolumesInput = {
    where?: ComicsWhereInput
    data: XOR<ComicsUpdateWithoutVolumesInput, ComicsUncheckedUpdateWithoutVolumesInput>
  }

  export type ComicsUpdateWithoutVolumesInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    keywords?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    categories?: CategoriesUpdateManyWithoutComicsNestedInput
    authors?: AuthorsUpdateManyWithoutComicsNestedInput
    favorites?: FavoritesUpdateManyWithoutComicNestedInput
    rates?: RatesUpdateManyWithoutComicNestedInput
    views?: ViewsUpdateManyWithoutComicNestedInput
    comment?: CommentsUpdateManyWithoutComicNestedInput
    unlock_comic?: Unlock_comicUpdateManyWithoutComicNestedInput
    user?: UsersUpdateOneRequiredWithoutComicsNestedInput
  }

  export type ComicsUncheckedUpdateWithoutVolumesInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    keywords?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: IntFieldUpdateOperationsInput | number
    categories?: CategoriesUncheckedUpdateManyWithoutComicsNestedInput
    authors?: AuthorsUncheckedUpdateManyWithoutComicsNestedInput
    favorites?: FavoritesUncheckedUpdateManyWithoutComicNestedInput
    rates?: RatesUncheckedUpdateManyWithoutComicNestedInput
    views?: ViewsUncheckedUpdateManyWithoutComicNestedInput
    comment?: CommentsUncheckedUpdateManyWithoutComicNestedInput
    unlock_comic?: Unlock_comicUncheckedUpdateManyWithoutComicNestedInput
  }

  export type ChaptersUpsertWithWhereUniqueWithoutVolumeInput = {
    where: ChaptersWhereUniqueInput
    update: XOR<ChaptersUpdateWithoutVolumeInput, ChaptersUncheckedUpdateWithoutVolumeInput>
    create: XOR<ChaptersCreateWithoutVolumeInput, ChaptersUncheckedCreateWithoutVolumeInput>
  }

  export type ChaptersUpdateWithWhereUniqueWithoutVolumeInput = {
    where: ChaptersWhereUniqueInput
    data: XOR<ChaptersUpdateWithoutVolumeInput, ChaptersUncheckedUpdateWithoutVolumeInput>
  }

  export type ChaptersUpdateManyWithWhereWithoutVolumeInput = {
    where: ChaptersScalarWhereInput
    data: XOR<ChaptersUpdateManyMutationInput, ChaptersUncheckedUpdateManyWithoutVolumeInput>
  }

  export type ChaptersScalarWhereInput = {
    AND?: ChaptersScalarWhereInput | ChaptersScalarWhereInput[]
    OR?: ChaptersScalarWhereInput[]
    NOT?: ChaptersScalarWhereInput | ChaptersScalarWhereInput[]
    id?: IntFilter<"Chapters"> | number
    title?: StringFilter<"Chapters"> | string
    filePath?: StringFilter<"Chapters"> | string
    content?: StringFilter<"Chapters"> | string
    price?: DecimalFilter<"Chapters"> | Decimal | DecimalJsLike | number | string
    lock?: BoolFilter<"Chapters"> | boolean
    volumeId?: IntFilter<"Chapters"> | number
    createdAt?: DateTimeFilter<"Chapters"> | Date | string
    updatedAt?: DateTimeFilter<"Chapters"> | Date | string
  }

  export type Unlock_volumeUpsertWithWhereUniqueWithoutVolumeInput = {
    where: Unlock_volumeWhereUniqueInput
    update: XOR<Unlock_volumeUpdateWithoutVolumeInput, Unlock_volumeUncheckedUpdateWithoutVolumeInput>
    create: XOR<Unlock_volumeCreateWithoutVolumeInput, Unlock_volumeUncheckedCreateWithoutVolumeInput>
  }

  export type Unlock_volumeUpdateWithWhereUniqueWithoutVolumeInput = {
    where: Unlock_volumeWhereUniqueInput
    data: XOR<Unlock_volumeUpdateWithoutVolumeInput, Unlock_volumeUncheckedUpdateWithoutVolumeInput>
  }

  export type Unlock_volumeUpdateManyWithWhereWithoutVolumeInput = {
    where: Unlock_volumeScalarWhereInput
    data: XOR<Unlock_volumeUpdateManyMutationInput, Unlock_volumeUncheckedUpdateManyWithoutVolumeInput>
  }

  export type Unlock_volumeScalarWhereInput = {
    AND?: Unlock_volumeScalarWhereInput | Unlock_volumeScalarWhereInput[]
    OR?: Unlock_volumeScalarWhereInput[]
    NOT?: Unlock_volumeScalarWhereInput | Unlock_volumeScalarWhereInput[]
    userId?: IntFilter<"Unlock_volume"> | number
    volumeId?: IntFilter<"Unlock_volume"> | number
    transactionId?: IntFilter<"Unlock_volume"> | number
    createdAt?: DateTimeFilter<"Unlock_volume"> | Date | string
  }

  export type VolumesCreateWithoutChaptersInput = {
    title: string
    description: string
    price: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
    comic: ComicsCreateNestedOneWithoutVolumesInput
    unlock_volume?: Unlock_volumeCreateNestedManyWithoutVolumeInput
  }

  export type VolumesUncheckedCreateWithoutChaptersInput = {
    id?: number
    title: string
    description: string
    price: Decimal | DecimalJsLike | number | string
    comicId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    unlock_volume?: Unlock_volumeUncheckedCreateNestedManyWithoutVolumeInput
  }

  export type VolumesCreateOrConnectWithoutChaptersInput = {
    where: VolumesWhereUniqueInput
    create: XOR<VolumesCreateWithoutChaptersInput, VolumesUncheckedCreateWithoutChaptersInput>
  }

  export type ErrorsCreateWithoutChapterInput = {
    content: string
    status: string
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UsersCreateNestedOneWithoutErrorsInput
  }

  export type ErrorsUncheckedCreateWithoutChapterInput = {
    userId: number
    content: string
    status: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ErrorsCreateOrConnectWithoutChapterInput = {
    where: ErrorsWhereUniqueInput
    create: XOR<ErrorsCreateWithoutChapterInput, ErrorsUncheckedCreateWithoutChapterInput>
  }

  export type ErrorsCreateManyChapterInputEnvelope = {
    data: ErrorsCreateManyChapterInput | ErrorsCreateManyChapterInput[]
    skipDuplicates?: boolean
  }

  export type ViewsCreateWithoutChapterInput = {
    lastedAt?: Date | string
    user: UsersCreateNestedOneWithoutViewsInput
    comic: ComicsCreateNestedOneWithoutViewsInput
  }

  export type ViewsUncheckedCreateWithoutChapterInput = {
    userId: number
    comicId: number
    lastedAt?: Date | string
  }

  export type ViewsCreateOrConnectWithoutChapterInput = {
    where: ViewsWhereUniqueInput
    create: XOR<ViewsCreateWithoutChapterInput, ViewsUncheckedCreateWithoutChapterInput>
  }

  export type ViewsCreateManyChapterInputEnvelope = {
    data: ViewsCreateManyChapterInput | ViewsCreateManyChapterInput[]
    skipDuplicates?: boolean
  }

  export type CommentsCreateWithoutChapterInput = {
    content: string
    createdAt?: Date | string
    user: UsersCreateNestedOneWithoutComentsInput
    comic: ComicsCreateNestedOneWithoutCommentInput
    notification?: NotificationsCreateNestedManyWithoutCommentInput
  }

  export type CommentsUncheckedCreateWithoutChapterInput = {
    id?: number
    content: string
    userId: number
    comicId: number
    createdAt?: Date | string
    notification?: NotificationsUncheckedCreateNestedManyWithoutCommentInput
  }

  export type CommentsCreateOrConnectWithoutChapterInput = {
    where: CommentsWhereUniqueInput
    create: XOR<CommentsCreateWithoutChapterInput, CommentsUncheckedCreateWithoutChapterInput>
  }

  export type CommentsCreateManyChapterInputEnvelope = {
    data: CommentsCreateManyChapterInput | CommentsCreateManyChapterInput[]
    skipDuplicates?: boolean
  }

  export type Unlock_chapterCreateWithoutChapterInput = {
    createdAt?: Date | string
    user: UsersCreateNestedOneWithoutUnlock_chapterInput
    transaction: TransactionsCreateNestedOneWithoutUnlock_chapterInput
  }

  export type Unlock_chapterUncheckedCreateWithoutChapterInput = {
    userId: number
    transactionId: number
    createdAt?: Date | string
  }

  export type Unlock_chapterCreateOrConnectWithoutChapterInput = {
    where: Unlock_chapterWhereUniqueInput
    create: XOR<Unlock_chapterCreateWithoutChapterInput, Unlock_chapterUncheckedCreateWithoutChapterInput>
  }

  export type Unlock_chapterCreateManyChapterInputEnvelope = {
    data: Unlock_chapterCreateManyChapterInput | Unlock_chapterCreateManyChapterInput[]
    skipDuplicates?: boolean
  }

  export type VolumesUpsertWithoutChaptersInput = {
    update: XOR<VolumesUpdateWithoutChaptersInput, VolumesUncheckedUpdateWithoutChaptersInput>
    create: XOR<VolumesCreateWithoutChaptersInput, VolumesUncheckedCreateWithoutChaptersInput>
    where?: VolumesWhereInput
  }

  export type VolumesUpdateToOneWithWhereWithoutChaptersInput = {
    where?: VolumesWhereInput
    data: XOR<VolumesUpdateWithoutChaptersInput, VolumesUncheckedUpdateWithoutChaptersInput>
  }

  export type VolumesUpdateWithoutChaptersInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    comic?: ComicsUpdateOneRequiredWithoutVolumesNestedInput
    unlock_volume?: Unlock_volumeUpdateManyWithoutVolumeNestedInput
  }

  export type VolumesUncheckedUpdateWithoutChaptersInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    comicId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    unlock_volume?: Unlock_volumeUncheckedUpdateManyWithoutVolumeNestedInput
  }

  export type ErrorsUpsertWithWhereUniqueWithoutChapterInput = {
    where: ErrorsWhereUniqueInput
    update: XOR<ErrorsUpdateWithoutChapterInput, ErrorsUncheckedUpdateWithoutChapterInput>
    create: XOR<ErrorsCreateWithoutChapterInput, ErrorsUncheckedCreateWithoutChapterInput>
  }

  export type ErrorsUpdateWithWhereUniqueWithoutChapterInput = {
    where: ErrorsWhereUniqueInput
    data: XOR<ErrorsUpdateWithoutChapterInput, ErrorsUncheckedUpdateWithoutChapterInput>
  }

  export type ErrorsUpdateManyWithWhereWithoutChapterInput = {
    where: ErrorsScalarWhereInput
    data: XOR<ErrorsUpdateManyMutationInput, ErrorsUncheckedUpdateManyWithoutChapterInput>
  }

  export type ErrorsScalarWhereInput = {
    AND?: ErrorsScalarWhereInput | ErrorsScalarWhereInput[]
    OR?: ErrorsScalarWhereInput[]
    NOT?: ErrorsScalarWhereInput | ErrorsScalarWhereInput[]
    userId?: IntFilter<"Errors"> | number
    chapterId?: IntFilter<"Errors"> | number
    content?: StringFilter<"Errors"> | string
    status?: StringFilter<"Errors"> | string
    createdAt?: DateTimeFilter<"Errors"> | Date | string
    updatedAt?: DateTimeFilter<"Errors"> | Date | string
  }

  export type ViewsUpsertWithWhereUniqueWithoutChapterInput = {
    where: ViewsWhereUniqueInput
    update: XOR<ViewsUpdateWithoutChapterInput, ViewsUncheckedUpdateWithoutChapterInput>
    create: XOR<ViewsCreateWithoutChapterInput, ViewsUncheckedCreateWithoutChapterInput>
  }

  export type ViewsUpdateWithWhereUniqueWithoutChapterInput = {
    where: ViewsWhereUniqueInput
    data: XOR<ViewsUpdateWithoutChapterInput, ViewsUncheckedUpdateWithoutChapterInput>
  }

  export type ViewsUpdateManyWithWhereWithoutChapterInput = {
    where: ViewsScalarWhereInput
    data: XOR<ViewsUpdateManyMutationInput, ViewsUncheckedUpdateManyWithoutChapterInput>
  }

  export type CommentsUpsertWithWhereUniqueWithoutChapterInput = {
    where: CommentsWhereUniqueInput
    update: XOR<CommentsUpdateWithoutChapterInput, CommentsUncheckedUpdateWithoutChapterInput>
    create: XOR<CommentsCreateWithoutChapterInput, CommentsUncheckedCreateWithoutChapterInput>
  }

  export type CommentsUpdateWithWhereUniqueWithoutChapterInput = {
    where: CommentsWhereUniqueInput
    data: XOR<CommentsUpdateWithoutChapterInput, CommentsUncheckedUpdateWithoutChapterInput>
  }

  export type CommentsUpdateManyWithWhereWithoutChapterInput = {
    where: CommentsScalarWhereInput
    data: XOR<CommentsUpdateManyMutationInput, CommentsUncheckedUpdateManyWithoutChapterInput>
  }

  export type Unlock_chapterUpsertWithWhereUniqueWithoutChapterInput = {
    where: Unlock_chapterWhereUniqueInput
    update: XOR<Unlock_chapterUpdateWithoutChapterInput, Unlock_chapterUncheckedUpdateWithoutChapterInput>
    create: XOR<Unlock_chapterCreateWithoutChapterInput, Unlock_chapterUncheckedCreateWithoutChapterInput>
  }

  export type Unlock_chapterUpdateWithWhereUniqueWithoutChapterInput = {
    where: Unlock_chapterWhereUniqueInput
    data: XOR<Unlock_chapterUpdateWithoutChapterInput, Unlock_chapterUncheckedUpdateWithoutChapterInput>
  }

  export type Unlock_chapterUpdateManyWithWhereWithoutChapterInput = {
    where: Unlock_chapterScalarWhereInput
    data: XOR<Unlock_chapterUpdateManyMutationInput, Unlock_chapterUncheckedUpdateManyWithoutChapterInput>
  }

  export type Unlock_chapterScalarWhereInput = {
    AND?: Unlock_chapterScalarWhereInput | Unlock_chapterScalarWhereInput[]
    OR?: Unlock_chapterScalarWhereInput[]
    NOT?: Unlock_chapterScalarWhereInput | Unlock_chapterScalarWhereInput[]
    userId?: IntFilter<"Unlock_chapter"> | number
    chapterId?: IntFilter<"Unlock_chapter"> | number
    transactionId?: IntFilter<"Unlock_chapter"> | number
    createdAt?: DateTimeFilter<"Unlock_chapter"> | Date | string
  }

  export type UsersCreateWithoutUserRoleInput = {
    name: string
    email: string
    password: string
    description: string
    createdAt?: Date | string
    updatedAt?: Date | string
    isDisabled: boolean
    comics?: ComicsCreateNestedManyWithoutUserInput
    favorites?: FavoritesCreateNestedManyWithoutUserInput
    rates?: RatesCreateNestedManyWithoutUserInput
    errors?: ErrorsCreateNestedManyWithoutUserInput
    views?: ViewsCreateNestedManyWithoutUserInput
    coments?: CommentsCreateNestedManyWithoutUserInput
    notifications?: NotificationsCreateNestedManyWithoutUserInput
    wallets?: WalletsCreateNestedOneWithoutUserInput
    unlock_comic?: Unlock_comicCreateNestedManyWithoutUserInput
    unlock_volume?: Unlock_volumeCreateNestedManyWithoutUserInput
    unlock_chapter?: Unlock_chapterCreateNestedManyWithoutUserInput
  }

  export type UsersUncheckedCreateWithoutUserRoleInput = {
    id?: number
    name: string
    email: string
    password: string
    description: string
    createdAt?: Date | string
    updatedAt?: Date | string
    isDisabled: boolean
    comics?: ComicsUncheckedCreateNestedManyWithoutUserInput
    favorites?: FavoritesUncheckedCreateNestedManyWithoutUserInput
    rates?: RatesUncheckedCreateNestedManyWithoutUserInput
    errors?: ErrorsUncheckedCreateNestedManyWithoutUserInput
    views?: ViewsUncheckedCreateNestedManyWithoutUserInput
    coments?: CommentsUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationsUncheckedCreateNestedManyWithoutUserInput
    wallets?: WalletsUncheckedCreateNestedOneWithoutUserInput
    unlock_comic?: Unlock_comicUncheckedCreateNestedManyWithoutUserInput
    unlock_volume?: Unlock_volumeUncheckedCreateNestedManyWithoutUserInput
    unlock_chapter?: Unlock_chapterUncheckedCreateNestedManyWithoutUserInput
  }

  export type UsersCreateOrConnectWithoutUserRoleInput = {
    where: UsersWhereUniqueInput
    create: XOR<UsersCreateWithoutUserRoleInput, UsersUncheckedCreateWithoutUserRoleInput>
  }

  export type UsersUpsertWithWhereUniqueWithoutUserRoleInput = {
    where: UsersWhereUniqueInput
    update: XOR<UsersUpdateWithoutUserRoleInput, UsersUncheckedUpdateWithoutUserRoleInput>
    create: XOR<UsersCreateWithoutUserRoleInput, UsersUncheckedCreateWithoutUserRoleInput>
  }

  export type UsersUpdateWithWhereUniqueWithoutUserRoleInput = {
    where: UsersWhereUniqueInput
    data: XOR<UsersUpdateWithoutUserRoleInput, UsersUncheckedUpdateWithoutUserRoleInput>
  }

  export type UsersUpdateManyWithWhereWithoutUserRoleInput = {
    where: UsersScalarWhereInput
    data: XOR<UsersUpdateManyMutationInput, UsersUncheckedUpdateManyWithoutUserRoleInput>
  }

  export type UsersScalarWhereInput = {
    AND?: UsersScalarWhereInput | UsersScalarWhereInput[]
    OR?: UsersScalarWhereInput[]
    NOT?: UsersScalarWhereInput | UsersScalarWhereInput[]
    id?: IntFilter<"Users"> | number
    name?: StringFilter<"Users"> | string
    email?: StringFilter<"Users"> | string
    password?: StringFilter<"Users"> | string
    description?: StringFilter<"Users"> | string
    createdAt?: DateTimeFilter<"Users"> | Date | string
    updatedAt?: DateTimeFilter<"Users"> | Date | string
    isDisabled?: BoolFilter<"Users"> | boolean
  }

  export type ComicsCreateWithoutUserInput = {
    title: string
    description: string
    image: string
    keywords: string
    status: string
    price: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
    categories?: CategoriesCreateNestedManyWithoutComicsInput
    authors?: AuthorsCreateNestedManyWithoutComicsInput
    volumes?: VolumesCreateNestedManyWithoutComicInput
    favorites?: FavoritesCreateNestedManyWithoutComicInput
    rates?: RatesCreateNestedManyWithoutComicInput
    views?: ViewsCreateNestedManyWithoutComicInput
    comment?: CommentsCreateNestedManyWithoutComicInput
    unlock_comic?: Unlock_comicCreateNestedManyWithoutComicInput
  }

  export type ComicsUncheckedCreateWithoutUserInput = {
    id?: number
    title: string
    description: string
    image: string
    keywords: string
    status: string
    price: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
    categories?: CategoriesUncheckedCreateNestedManyWithoutComicsInput
    authors?: AuthorsUncheckedCreateNestedManyWithoutComicsInput
    volumes?: VolumesUncheckedCreateNestedManyWithoutComicInput
    favorites?: FavoritesUncheckedCreateNestedManyWithoutComicInput
    rates?: RatesUncheckedCreateNestedManyWithoutComicInput
    views?: ViewsUncheckedCreateNestedManyWithoutComicInput
    comment?: CommentsUncheckedCreateNestedManyWithoutComicInput
    unlock_comic?: Unlock_comicUncheckedCreateNestedManyWithoutComicInput
  }

  export type ComicsCreateOrConnectWithoutUserInput = {
    where: ComicsWhereUniqueInput
    create: XOR<ComicsCreateWithoutUserInput, ComicsUncheckedCreateWithoutUserInput>
  }

  export type ComicsCreateManyUserInputEnvelope = {
    data: ComicsCreateManyUserInput | ComicsCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type RolesCreateWithoutUsersInput = {
    title: string
    description: string
  }

  export type RolesUncheckedCreateWithoutUsersInput = {
    id?: number
    title: string
    description: string
  }

  export type RolesCreateOrConnectWithoutUsersInput = {
    where: RolesWhereUniqueInput
    create: XOR<RolesCreateWithoutUsersInput, RolesUncheckedCreateWithoutUsersInput>
  }

  export type FavoritesCreateWithoutUserInput = {
    addedAt?: Date | string
    comic: ComicsCreateNestedOneWithoutFavoritesInput
  }

  export type FavoritesUncheckedCreateWithoutUserInput = {
    comicId: number
    addedAt?: Date | string
  }

  export type FavoritesCreateOrConnectWithoutUserInput = {
    where: FavoritesWhereUniqueInput
    create: XOR<FavoritesCreateWithoutUserInput, FavoritesUncheckedCreateWithoutUserInput>
  }

  export type FavoritesCreateManyUserInputEnvelope = {
    data: FavoritesCreateManyUserInput | FavoritesCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type RatesCreateWithoutUserInput = {
    score?: number
    content: string
    createdAt?: Date | string
    comic: ComicsCreateNestedOneWithoutRatesInput
  }

  export type RatesUncheckedCreateWithoutUserInput = {
    comicId: number
    score?: number
    content: string
    createdAt?: Date | string
  }

  export type RatesCreateOrConnectWithoutUserInput = {
    where: RatesWhereUniqueInput
    create: XOR<RatesCreateWithoutUserInput, RatesUncheckedCreateWithoutUserInput>
  }

  export type RatesCreateManyUserInputEnvelope = {
    data: RatesCreateManyUserInput | RatesCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type ErrorsCreateWithoutUserInput = {
    content: string
    status: string
    createdAt?: Date | string
    updatedAt?: Date | string
    chapter: ChaptersCreateNestedOneWithoutErrorsInput
  }

  export type ErrorsUncheckedCreateWithoutUserInput = {
    chapterId: number
    content: string
    status: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ErrorsCreateOrConnectWithoutUserInput = {
    where: ErrorsWhereUniqueInput
    create: XOR<ErrorsCreateWithoutUserInput, ErrorsUncheckedCreateWithoutUserInput>
  }

  export type ErrorsCreateManyUserInputEnvelope = {
    data: ErrorsCreateManyUserInput | ErrorsCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type ViewsCreateWithoutUserInput = {
    lastedAt?: Date | string
    comic: ComicsCreateNestedOneWithoutViewsInput
    chapter: ChaptersCreateNestedOneWithoutViewsInput
  }

  export type ViewsUncheckedCreateWithoutUserInput = {
    comicId: number
    chapterId: number
    lastedAt?: Date | string
  }

  export type ViewsCreateOrConnectWithoutUserInput = {
    where: ViewsWhereUniqueInput
    create: XOR<ViewsCreateWithoutUserInput, ViewsUncheckedCreateWithoutUserInput>
  }

  export type ViewsCreateManyUserInputEnvelope = {
    data: ViewsCreateManyUserInput | ViewsCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type CommentsCreateWithoutUserInput = {
    content: string
    createdAt?: Date | string
    chapter?: ChaptersCreateNestedOneWithoutComentsInput
    comic: ComicsCreateNestedOneWithoutCommentInput
    notification?: NotificationsCreateNestedManyWithoutCommentInput
  }

  export type CommentsUncheckedCreateWithoutUserInput = {
    id?: number
    content: string
    chapterId?: number | null
    comicId: number
    createdAt?: Date | string
    notification?: NotificationsUncheckedCreateNestedManyWithoutCommentInput
  }

  export type CommentsCreateOrConnectWithoutUserInput = {
    where: CommentsWhereUniqueInput
    create: XOR<CommentsCreateWithoutUserInput, CommentsUncheckedCreateWithoutUserInput>
  }

  export type CommentsCreateManyUserInputEnvelope = {
    data: CommentsCreateManyUserInput | CommentsCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type NotificationsCreateWithoutUserInput = {
    content: string
    isRead: boolean
    createdAt?: Date | string
    comment?: CommentsCreateNestedOneWithoutNotificationInput
  }

  export type NotificationsUncheckedCreateWithoutUserInput = {
    id?: number
    commentId?: number | null
    content: string
    isRead: boolean
    createdAt?: Date | string
  }

  export type NotificationsCreateOrConnectWithoutUserInput = {
    where: NotificationsWhereUniqueInput
    create: XOR<NotificationsCreateWithoutUserInput, NotificationsUncheckedCreateWithoutUserInput>
  }

  export type NotificationsCreateManyUserInputEnvelope = {
    data: NotificationsCreateManyUserInput | NotificationsCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type WalletsCreateWithoutUserInput = {
    value: Decimal | DecimalJsLike | number | string
    updatedAt?: Date | string
    transactions?: TransactionsCreateNestedManyWithoutWalletInput
  }

  export type WalletsUncheckedCreateWithoutUserInput = {
    id?: number
    value: Decimal | DecimalJsLike | number | string
    updatedAt?: Date | string
    transactions?: TransactionsUncheckedCreateNestedManyWithoutWalletInput
  }

  export type WalletsCreateOrConnectWithoutUserInput = {
    where: WalletsWhereUniqueInput
    create: XOR<WalletsCreateWithoutUserInput, WalletsUncheckedCreateWithoutUserInput>
  }

  export type Unlock_comicCreateWithoutUserInput = {
    createdAt?: Date | string
    comic: ComicsCreateNestedOneWithoutUnlock_comicInput
    transaction: TransactionsCreateNestedOneWithoutUnlock_comicInput
  }

  export type Unlock_comicUncheckedCreateWithoutUserInput = {
    comicId: number
    transactionId: number
    createdAt?: Date | string
  }

  export type Unlock_comicCreateOrConnectWithoutUserInput = {
    where: Unlock_comicWhereUniqueInput
    create: XOR<Unlock_comicCreateWithoutUserInput, Unlock_comicUncheckedCreateWithoutUserInput>
  }

  export type Unlock_comicCreateManyUserInputEnvelope = {
    data: Unlock_comicCreateManyUserInput | Unlock_comicCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type Unlock_volumeCreateWithoutUserInput = {
    createdAt?: Date | string
    volume: VolumesCreateNestedOneWithoutUnlock_volumeInput
    transaction: TransactionsCreateNestedOneWithoutUnlock_volumeInput
  }

  export type Unlock_volumeUncheckedCreateWithoutUserInput = {
    volumeId: number
    transactionId: number
    createdAt?: Date | string
  }

  export type Unlock_volumeCreateOrConnectWithoutUserInput = {
    where: Unlock_volumeWhereUniqueInput
    create: XOR<Unlock_volumeCreateWithoutUserInput, Unlock_volumeUncheckedCreateWithoutUserInput>
  }

  export type Unlock_volumeCreateManyUserInputEnvelope = {
    data: Unlock_volumeCreateManyUserInput | Unlock_volumeCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type Unlock_chapterCreateWithoutUserInput = {
    createdAt?: Date | string
    chapter: ChaptersCreateNestedOneWithoutUnlock_chapterInput
    transaction: TransactionsCreateNestedOneWithoutUnlock_chapterInput
  }

  export type Unlock_chapterUncheckedCreateWithoutUserInput = {
    chapterId: number
    transactionId: number
    createdAt?: Date | string
  }

  export type Unlock_chapterCreateOrConnectWithoutUserInput = {
    where: Unlock_chapterWhereUniqueInput
    create: XOR<Unlock_chapterCreateWithoutUserInput, Unlock_chapterUncheckedCreateWithoutUserInput>
  }

  export type Unlock_chapterCreateManyUserInputEnvelope = {
    data: Unlock_chapterCreateManyUserInput | Unlock_chapterCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type ComicsUpsertWithWhereUniqueWithoutUserInput = {
    where: ComicsWhereUniqueInput
    update: XOR<ComicsUpdateWithoutUserInput, ComicsUncheckedUpdateWithoutUserInput>
    create: XOR<ComicsCreateWithoutUserInput, ComicsUncheckedCreateWithoutUserInput>
  }

  export type ComicsUpdateWithWhereUniqueWithoutUserInput = {
    where: ComicsWhereUniqueInput
    data: XOR<ComicsUpdateWithoutUserInput, ComicsUncheckedUpdateWithoutUserInput>
  }

  export type ComicsUpdateManyWithWhereWithoutUserInput = {
    where: ComicsScalarWhereInput
    data: XOR<ComicsUpdateManyMutationInput, ComicsUncheckedUpdateManyWithoutUserInput>
  }

  export type RolesUpsertWithWhereUniqueWithoutUsersInput = {
    where: RolesWhereUniqueInput
    update: XOR<RolesUpdateWithoutUsersInput, RolesUncheckedUpdateWithoutUsersInput>
    create: XOR<RolesCreateWithoutUsersInput, RolesUncheckedCreateWithoutUsersInput>
  }

  export type RolesUpdateWithWhereUniqueWithoutUsersInput = {
    where: RolesWhereUniqueInput
    data: XOR<RolesUpdateWithoutUsersInput, RolesUncheckedUpdateWithoutUsersInput>
  }

  export type RolesUpdateManyWithWhereWithoutUsersInput = {
    where: RolesScalarWhereInput
    data: XOR<RolesUpdateManyMutationInput, RolesUncheckedUpdateManyWithoutUsersInput>
  }

  export type RolesScalarWhereInput = {
    AND?: RolesScalarWhereInput | RolesScalarWhereInput[]
    OR?: RolesScalarWhereInput[]
    NOT?: RolesScalarWhereInput | RolesScalarWhereInput[]
    id?: IntFilter<"Roles"> | number
    title?: StringFilter<"Roles"> | string
    description?: StringFilter<"Roles"> | string
  }

  export type FavoritesUpsertWithWhereUniqueWithoutUserInput = {
    where: FavoritesWhereUniqueInput
    update: XOR<FavoritesUpdateWithoutUserInput, FavoritesUncheckedUpdateWithoutUserInput>
    create: XOR<FavoritesCreateWithoutUserInput, FavoritesUncheckedCreateWithoutUserInput>
  }

  export type FavoritesUpdateWithWhereUniqueWithoutUserInput = {
    where: FavoritesWhereUniqueInput
    data: XOR<FavoritesUpdateWithoutUserInput, FavoritesUncheckedUpdateWithoutUserInput>
  }

  export type FavoritesUpdateManyWithWhereWithoutUserInput = {
    where: FavoritesScalarWhereInput
    data: XOR<FavoritesUpdateManyMutationInput, FavoritesUncheckedUpdateManyWithoutUserInput>
  }

  export type RatesUpsertWithWhereUniqueWithoutUserInput = {
    where: RatesWhereUniqueInput
    update: XOR<RatesUpdateWithoutUserInput, RatesUncheckedUpdateWithoutUserInput>
    create: XOR<RatesCreateWithoutUserInput, RatesUncheckedCreateWithoutUserInput>
  }

  export type RatesUpdateWithWhereUniqueWithoutUserInput = {
    where: RatesWhereUniqueInput
    data: XOR<RatesUpdateWithoutUserInput, RatesUncheckedUpdateWithoutUserInput>
  }

  export type RatesUpdateManyWithWhereWithoutUserInput = {
    where: RatesScalarWhereInput
    data: XOR<RatesUpdateManyMutationInput, RatesUncheckedUpdateManyWithoutUserInput>
  }

  export type ErrorsUpsertWithWhereUniqueWithoutUserInput = {
    where: ErrorsWhereUniqueInput
    update: XOR<ErrorsUpdateWithoutUserInput, ErrorsUncheckedUpdateWithoutUserInput>
    create: XOR<ErrorsCreateWithoutUserInput, ErrorsUncheckedCreateWithoutUserInput>
  }

  export type ErrorsUpdateWithWhereUniqueWithoutUserInput = {
    where: ErrorsWhereUniqueInput
    data: XOR<ErrorsUpdateWithoutUserInput, ErrorsUncheckedUpdateWithoutUserInput>
  }

  export type ErrorsUpdateManyWithWhereWithoutUserInput = {
    where: ErrorsScalarWhereInput
    data: XOR<ErrorsUpdateManyMutationInput, ErrorsUncheckedUpdateManyWithoutUserInput>
  }

  export type ViewsUpsertWithWhereUniqueWithoutUserInput = {
    where: ViewsWhereUniqueInput
    update: XOR<ViewsUpdateWithoutUserInput, ViewsUncheckedUpdateWithoutUserInput>
    create: XOR<ViewsCreateWithoutUserInput, ViewsUncheckedCreateWithoutUserInput>
  }

  export type ViewsUpdateWithWhereUniqueWithoutUserInput = {
    where: ViewsWhereUniqueInput
    data: XOR<ViewsUpdateWithoutUserInput, ViewsUncheckedUpdateWithoutUserInput>
  }

  export type ViewsUpdateManyWithWhereWithoutUserInput = {
    where: ViewsScalarWhereInput
    data: XOR<ViewsUpdateManyMutationInput, ViewsUncheckedUpdateManyWithoutUserInput>
  }

  export type CommentsUpsertWithWhereUniqueWithoutUserInput = {
    where: CommentsWhereUniqueInput
    update: XOR<CommentsUpdateWithoutUserInput, CommentsUncheckedUpdateWithoutUserInput>
    create: XOR<CommentsCreateWithoutUserInput, CommentsUncheckedCreateWithoutUserInput>
  }

  export type CommentsUpdateWithWhereUniqueWithoutUserInput = {
    where: CommentsWhereUniqueInput
    data: XOR<CommentsUpdateWithoutUserInput, CommentsUncheckedUpdateWithoutUserInput>
  }

  export type CommentsUpdateManyWithWhereWithoutUserInput = {
    where: CommentsScalarWhereInput
    data: XOR<CommentsUpdateManyMutationInput, CommentsUncheckedUpdateManyWithoutUserInput>
  }

  export type NotificationsUpsertWithWhereUniqueWithoutUserInput = {
    where: NotificationsWhereUniqueInput
    update: XOR<NotificationsUpdateWithoutUserInput, NotificationsUncheckedUpdateWithoutUserInput>
    create: XOR<NotificationsCreateWithoutUserInput, NotificationsUncheckedCreateWithoutUserInput>
  }

  export type NotificationsUpdateWithWhereUniqueWithoutUserInput = {
    where: NotificationsWhereUniqueInput
    data: XOR<NotificationsUpdateWithoutUserInput, NotificationsUncheckedUpdateWithoutUserInput>
  }

  export type NotificationsUpdateManyWithWhereWithoutUserInput = {
    where: NotificationsScalarWhereInput
    data: XOR<NotificationsUpdateManyMutationInput, NotificationsUncheckedUpdateManyWithoutUserInput>
  }

  export type NotificationsScalarWhereInput = {
    AND?: NotificationsScalarWhereInput | NotificationsScalarWhereInput[]
    OR?: NotificationsScalarWhereInput[]
    NOT?: NotificationsScalarWhereInput | NotificationsScalarWhereInput[]
    id?: IntFilter<"Notifications"> | number
    userId?: IntFilter<"Notifications"> | number
    commentId?: IntNullableFilter<"Notifications"> | number | null
    content?: StringFilter<"Notifications"> | string
    isRead?: BoolFilter<"Notifications"> | boolean
    createdAt?: DateTimeFilter<"Notifications"> | Date | string
  }

  export type WalletsUpsertWithoutUserInput = {
    update: XOR<WalletsUpdateWithoutUserInput, WalletsUncheckedUpdateWithoutUserInput>
    create: XOR<WalletsCreateWithoutUserInput, WalletsUncheckedCreateWithoutUserInput>
    where?: WalletsWhereInput
  }

  export type WalletsUpdateToOneWithWhereWithoutUserInput = {
    where?: WalletsWhereInput
    data: XOR<WalletsUpdateWithoutUserInput, WalletsUncheckedUpdateWithoutUserInput>
  }

  export type WalletsUpdateWithoutUserInput = {
    value?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transactions?: TransactionsUpdateManyWithoutWalletNestedInput
  }

  export type WalletsUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    value?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transactions?: TransactionsUncheckedUpdateManyWithoutWalletNestedInput
  }

  export type Unlock_comicUpsertWithWhereUniqueWithoutUserInput = {
    where: Unlock_comicWhereUniqueInput
    update: XOR<Unlock_comicUpdateWithoutUserInput, Unlock_comicUncheckedUpdateWithoutUserInput>
    create: XOR<Unlock_comicCreateWithoutUserInput, Unlock_comicUncheckedCreateWithoutUserInput>
  }

  export type Unlock_comicUpdateWithWhereUniqueWithoutUserInput = {
    where: Unlock_comicWhereUniqueInput
    data: XOR<Unlock_comicUpdateWithoutUserInput, Unlock_comicUncheckedUpdateWithoutUserInput>
  }

  export type Unlock_comicUpdateManyWithWhereWithoutUserInput = {
    where: Unlock_comicScalarWhereInput
    data: XOR<Unlock_comicUpdateManyMutationInput, Unlock_comicUncheckedUpdateManyWithoutUserInput>
  }

  export type Unlock_volumeUpsertWithWhereUniqueWithoutUserInput = {
    where: Unlock_volumeWhereUniqueInput
    update: XOR<Unlock_volumeUpdateWithoutUserInput, Unlock_volumeUncheckedUpdateWithoutUserInput>
    create: XOR<Unlock_volumeCreateWithoutUserInput, Unlock_volumeUncheckedCreateWithoutUserInput>
  }

  export type Unlock_volumeUpdateWithWhereUniqueWithoutUserInput = {
    where: Unlock_volumeWhereUniqueInput
    data: XOR<Unlock_volumeUpdateWithoutUserInput, Unlock_volumeUncheckedUpdateWithoutUserInput>
  }

  export type Unlock_volumeUpdateManyWithWhereWithoutUserInput = {
    where: Unlock_volumeScalarWhereInput
    data: XOR<Unlock_volumeUpdateManyMutationInput, Unlock_volumeUncheckedUpdateManyWithoutUserInput>
  }

  export type Unlock_chapterUpsertWithWhereUniqueWithoutUserInput = {
    where: Unlock_chapterWhereUniqueInput
    update: XOR<Unlock_chapterUpdateWithoutUserInput, Unlock_chapterUncheckedUpdateWithoutUserInput>
    create: XOR<Unlock_chapterCreateWithoutUserInput, Unlock_chapterUncheckedCreateWithoutUserInput>
  }

  export type Unlock_chapterUpdateWithWhereUniqueWithoutUserInput = {
    where: Unlock_chapterWhereUniqueInput
    data: XOR<Unlock_chapterUpdateWithoutUserInput, Unlock_chapterUncheckedUpdateWithoutUserInput>
  }

  export type Unlock_chapterUpdateManyWithWhereWithoutUserInput = {
    where: Unlock_chapterScalarWhereInput
    data: XOR<Unlock_chapterUpdateManyMutationInput, Unlock_chapterUncheckedUpdateManyWithoutUserInput>
  }

  export type UsersCreateWithoutFavoritesInput = {
    name: string
    email: string
    password: string
    description: string
    createdAt?: Date | string
    updatedAt?: Date | string
    isDisabled: boolean
    comics?: ComicsCreateNestedManyWithoutUserInput
    userRole?: RolesCreateNestedManyWithoutUsersInput
    rates?: RatesCreateNestedManyWithoutUserInput
    errors?: ErrorsCreateNestedManyWithoutUserInput
    views?: ViewsCreateNestedManyWithoutUserInput
    coments?: CommentsCreateNestedManyWithoutUserInput
    notifications?: NotificationsCreateNestedManyWithoutUserInput
    wallets?: WalletsCreateNestedOneWithoutUserInput
    unlock_comic?: Unlock_comicCreateNestedManyWithoutUserInput
    unlock_volume?: Unlock_volumeCreateNestedManyWithoutUserInput
    unlock_chapter?: Unlock_chapterCreateNestedManyWithoutUserInput
  }

  export type UsersUncheckedCreateWithoutFavoritesInput = {
    id?: number
    name: string
    email: string
    password: string
    description: string
    createdAt?: Date | string
    updatedAt?: Date | string
    isDisabled: boolean
    comics?: ComicsUncheckedCreateNestedManyWithoutUserInput
    userRole?: RolesUncheckedCreateNestedManyWithoutUsersInput
    rates?: RatesUncheckedCreateNestedManyWithoutUserInput
    errors?: ErrorsUncheckedCreateNestedManyWithoutUserInput
    views?: ViewsUncheckedCreateNestedManyWithoutUserInput
    coments?: CommentsUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationsUncheckedCreateNestedManyWithoutUserInput
    wallets?: WalletsUncheckedCreateNestedOneWithoutUserInput
    unlock_comic?: Unlock_comicUncheckedCreateNestedManyWithoutUserInput
    unlock_volume?: Unlock_volumeUncheckedCreateNestedManyWithoutUserInput
    unlock_chapter?: Unlock_chapterUncheckedCreateNestedManyWithoutUserInput
  }

  export type UsersCreateOrConnectWithoutFavoritesInput = {
    where: UsersWhereUniqueInput
    create: XOR<UsersCreateWithoutFavoritesInput, UsersUncheckedCreateWithoutFavoritesInput>
  }

  export type ComicsCreateWithoutFavoritesInput = {
    title: string
    description: string
    image: string
    keywords: string
    status: string
    price: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
    categories?: CategoriesCreateNestedManyWithoutComicsInput
    authors?: AuthorsCreateNestedManyWithoutComicsInput
    volumes?: VolumesCreateNestedManyWithoutComicInput
    rates?: RatesCreateNestedManyWithoutComicInput
    views?: ViewsCreateNestedManyWithoutComicInput
    comment?: CommentsCreateNestedManyWithoutComicInput
    unlock_comic?: Unlock_comicCreateNestedManyWithoutComicInput
    user: UsersCreateNestedOneWithoutComicsInput
  }

  export type ComicsUncheckedCreateWithoutFavoritesInput = {
    id?: number
    title: string
    description: string
    image: string
    keywords: string
    status: string
    price: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
    userId: number
    categories?: CategoriesUncheckedCreateNestedManyWithoutComicsInput
    authors?: AuthorsUncheckedCreateNestedManyWithoutComicsInput
    volumes?: VolumesUncheckedCreateNestedManyWithoutComicInput
    rates?: RatesUncheckedCreateNestedManyWithoutComicInput
    views?: ViewsUncheckedCreateNestedManyWithoutComicInput
    comment?: CommentsUncheckedCreateNestedManyWithoutComicInput
    unlock_comic?: Unlock_comicUncheckedCreateNestedManyWithoutComicInput
  }

  export type ComicsCreateOrConnectWithoutFavoritesInput = {
    where: ComicsWhereUniqueInput
    create: XOR<ComicsCreateWithoutFavoritesInput, ComicsUncheckedCreateWithoutFavoritesInput>
  }

  export type UsersUpsertWithoutFavoritesInput = {
    update: XOR<UsersUpdateWithoutFavoritesInput, UsersUncheckedUpdateWithoutFavoritesInput>
    create: XOR<UsersCreateWithoutFavoritesInput, UsersUncheckedCreateWithoutFavoritesInput>
    where?: UsersWhereInput
  }

  export type UsersUpdateToOneWithWhereWithoutFavoritesInput = {
    where?: UsersWhereInput
    data: XOR<UsersUpdateWithoutFavoritesInput, UsersUncheckedUpdateWithoutFavoritesInput>
  }

  export type UsersUpdateWithoutFavoritesInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDisabled?: BoolFieldUpdateOperationsInput | boolean
    comics?: ComicsUpdateManyWithoutUserNestedInput
    userRole?: RolesUpdateManyWithoutUsersNestedInput
    rates?: RatesUpdateManyWithoutUserNestedInput
    errors?: ErrorsUpdateManyWithoutUserNestedInput
    views?: ViewsUpdateManyWithoutUserNestedInput
    coments?: CommentsUpdateManyWithoutUserNestedInput
    notifications?: NotificationsUpdateManyWithoutUserNestedInput
    wallets?: WalletsUpdateOneWithoutUserNestedInput
    unlock_comic?: Unlock_comicUpdateManyWithoutUserNestedInput
    unlock_volume?: Unlock_volumeUpdateManyWithoutUserNestedInput
    unlock_chapter?: Unlock_chapterUpdateManyWithoutUserNestedInput
  }

  export type UsersUncheckedUpdateWithoutFavoritesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDisabled?: BoolFieldUpdateOperationsInput | boolean
    comics?: ComicsUncheckedUpdateManyWithoutUserNestedInput
    userRole?: RolesUncheckedUpdateManyWithoutUsersNestedInput
    rates?: RatesUncheckedUpdateManyWithoutUserNestedInput
    errors?: ErrorsUncheckedUpdateManyWithoutUserNestedInput
    views?: ViewsUncheckedUpdateManyWithoutUserNestedInput
    coments?: CommentsUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationsUncheckedUpdateManyWithoutUserNestedInput
    wallets?: WalletsUncheckedUpdateOneWithoutUserNestedInput
    unlock_comic?: Unlock_comicUncheckedUpdateManyWithoutUserNestedInput
    unlock_volume?: Unlock_volumeUncheckedUpdateManyWithoutUserNestedInput
    unlock_chapter?: Unlock_chapterUncheckedUpdateManyWithoutUserNestedInput
  }

  export type ComicsUpsertWithoutFavoritesInput = {
    update: XOR<ComicsUpdateWithoutFavoritesInput, ComicsUncheckedUpdateWithoutFavoritesInput>
    create: XOR<ComicsCreateWithoutFavoritesInput, ComicsUncheckedCreateWithoutFavoritesInput>
    where?: ComicsWhereInput
  }

  export type ComicsUpdateToOneWithWhereWithoutFavoritesInput = {
    where?: ComicsWhereInput
    data: XOR<ComicsUpdateWithoutFavoritesInput, ComicsUncheckedUpdateWithoutFavoritesInput>
  }

  export type ComicsUpdateWithoutFavoritesInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    keywords?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    categories?: CategoriesUpdateManyWithoutComicsNestedInput
    authors?: AuthorsUpdateManyWithoutComicsNestedInput
    volumes?: VolumesUpdateManyWithoutComicNestedInput
    rates?: RatesUpdateManyWithoutComicNestedInput
    views?: ViewsUpdateManyWithoutComicNestedInput
    comment?: CommentsUpdateManyWithoutComicNestedInput
    unlock_comic?: Unlock_comicUpdateManyWithoutComicNestedInput
    user?: UsersUpdateOneRequiredWithoutComicsNestedInput
  }

  export type ComicsUncheckedUpdateWithoutFavoritesInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    keywords?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: IntFieldUpdateOperationsInput | number
    categories?: CategoriesUncheckedUpdateManyWithoutComicsNestedInput
    authors?: AuthorsUncheckedUpdateManyWithoutComicsNestedInput
    volumes?: VolumesUncheckedUpdateManyWithoutComicNestedInput
    rates?: RatesUncheckedUpdateManyWithoutComicNestedInput
    views?: ViewsUncheckedUpdateManyWithoutComicNestedInput
    comment?: CommentsUncheckedUpdateManyWithoutComicNestedInput
    unlock_comic?: Unlock_comicUncheckedUpdateManyWithoutComicNestedInput
  }

  export type UsersCreateWithoutRatesInput = {
    name: string
    email: string
    password: string
    description: string
    createdAt?: Date | string
    updatedAt?: Date | string
    isDisabled: boolean
    comics?: ComicsCreateNestedManyWithoutUserInput
    userRole?: RolesCreateNestedManyWithoutUsersInput
    favorites?: FavoritesCreateNestedManyWithoutUserInput
    errors?: ErrorsCreateNestedManyWithoutUserInput
    views?: ViewsCreateNestedManyWithoutUserInput
    coments?: CommentsCreateNestedManyWithoutUserInput
    notifications?: NotificationsCreateNestedManyWithoutUserInput
    wallets?: WalletsCreateNestedOneWithoutUserInput
    unlock_comic?: Unlock_comicCreateNestedManyWithoutUserInput
    unlock_volume?: Unlock_volumeCreateNestedManyWithoutUserInput
    unlock_chapter?: Unlock_chapterCreateNestedManyWithoutUserInput
  }

  export type UsersUncheckedCreateWithoutRatesInput = {
    id?: number
    name: string
    email: string
    password: string
    description: string
    createdAt?: Date | string
    updatedAt?: Date | string
    isDisabled: boolean
    comics?: ComicsUncheckedCreateNestedManyWithoutUserInput
    userRole?: RolesUncheckedCreateNestedManyWithoutUsersInput
    favorites?: FavoritesUncheckedCreateNestedManyWithoutUserInput
    errors?: ErrorsUncheckedCreateNestedManyWithoutUserInput
    views?: ViewsUncheckedCreateNestedManyWithoutUserInput
    coments?: CommentsUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationsUncheckedCreateNestedManyWithoutUserInput
    wallets?: WalletsUncheckedCreateNestedOneWithoutUserInput
    unlock_comic?: Unlock_comicUncheckedCreateNestedManyWithoutUserInput
    unlock_volume?: Unlock_volumeUncheckedCreateNestedManyWithoutUserInput
    unlock_chapter?: Unlock_chapterUncheckedCreateNestedManyWithoutUserInput
  }

  export type UsersCreateOrConnectWithoutRatesInput = {
    where: UsersWhereUniqueInput
    create: XOR<UsersCreateWithoutRatesInput, UsersUncheckedCreateWithoutRatesInput>
  }

  export type ComicsCreateWithoutRatesInput = {
    title: string
    description: string
    image: string
    keywords: string
    status: string
    price: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
    categories?: CategoriesCreateNestedManyWithoutComicsInput
    authors?: AuthorsCreateNestedManyWithoutComicsInput
    volumes?: VolumesCreateNestedManyWithoutComicInput
    favorites?: FavoritesCreateNestedManyWithoutComicInput
    views?: ViewsCreateNestedManyWithoutComicInput
    comment?: CommentsCreateNestedManyWithoutComicInput
    unlock_comic?: Unlock_comicCreateNestedManyWithoutComicInput
    user: UsersCreateNestedOneWithoutComicsInput
  }

  export type ComicsUncheckedCreateWithoutRatesInput = {
    id?: number
    title: string
    description: string
    image: string
    keywords: string
    status: string
    price: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
    userId: number
    categories?: CategoriesUncheckedCreateNestedManyWithoutComicsInput
    authors?: AuthorsUncheckedCreateNestedManyWithoutComicsInput
    volumes?: VolumesUncheckedCreateNestedManyWithoutComicInput
    favorites?: FavoritesUncheckedCreateNestedManyWithoutComicInput
    views?: ViewsUncheckedCreateNestedManyWithoutComicInput
    comment?: CommentsUncheckedCreateNestedManyWithoutComicInput
    unlock_comic?: Unlock_comicUncheckedCreateNestedManyWithoutComicInput
  }

  export type ComicsCreateOrConnectWithoutRatesInput = {
    where: ComicsWhereUniqueInput
    create: XOR<ComicsCreateWithoutRatesInput, ComicsUncheckedCreateWithoutRatesInput>
  }

  export type UsersUpsertWithoutRatesInput = {
    update: XOR<UsersUpdateWithoutRatesInput, UsersUncheckedUpdateWithoutRatesInput>
    create: XOR<UsersCreateWithoutRatesInput, UsersUncheckedCreateWithoutRatesInput>
    where?: UsersWhereInput
  }

  export type UsersUpdateToOneWithWhereWithoutRatesInput = {
    where?: UsersWhereInput
    data: XOR<UsersUpdateWithoutRatesInput, UsersUncheckedUpdateWithoutRatesInput>
  }

  export type UsersUpdateWithoutRatesInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDisabled?: BoolFieldUpdateOperationsInput | boolean
    comics?: ComicsUpdateManyWithoutUserNestedInput
    userRole?: RolesUpdateManyWithoutUsersNestedInput
    favorites?: FavoritesUpdateManyWithoutUserNestedInput
    errors?: ErrorsUpdateManyWithoutUserNestedInput
    views?: ViewsUpdateManyWithoutUserNestedInput
    coments?: CommentsUpdateManyWithoutUserNestedInput
    notifications?: NotificationsUpdateManyWithoutUserNestedInput
    wallets?: WalletsUpdateOneWithoutUserNestedInput
    unlock_comic?: Unlock_comicUpdateManyWithoutUserNestedInput
    unlock_volume?: Unlock_volumeUpdateManyWithoutUserNestedInput
    unlock_chapter?: Unlock_chapterUpdateManyWithoutUserNestedInput
  }

  export type UsersUncheckedUpdateWithoutRatesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDisabled?: BoolFieldUpdateOperationsInput | boolean
    comics?: ComicsUncheckedUpdateManyWithoutUserNestedInput
    userRole?: RolesUncheckedUpdateManyWithoutUsersNestedInput
    favorites?: FavoritesUncheckedUpdateManyWithoutUserNestedInput
    errors?: ErrorsUncheckedUpdateManyWithoutUserNestedInput
    views?: ViewsUncheckedUpdateManyWithoutUserNestedInput
    coments?: CommentsUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationsUncheckedUpdateManyWithoutUserNestedInput
    wallets?: WalletsUncheckedUpdateOneWithoutUserNestedInput
    unlock_comic?: Unlock_comicUncheckedUpdateManyWithoutUserNestedInput
    unlock_volume?: Unlock_volumeUncheckedUpdateManyWithoutUserNestedInput
    unlock_chapter?: Unlock_chapterUncheckedUpdateManyWithoutUserNestedInput
  }

  export type ComicsUpsertWithoutRatesInput = {
    update: XOR<ComicsUpdateWithoutRatesInput, ComicsUncheckedUpdateWithoutRatesInput>
    create: XOR<ComicsCreateWithoutRatesInput, ComicsUncheckedCreateWithoutRatesInput>
    where?: ComicsWhereInput
  }

  export type ComicsUpdateToOneWithWhereWithoutRatesInput = {
    where?: ComicsWhereInput
    data: XOR<ComicsUpdateWithoutRatesInput, ComicsUncheckedUpdateWithoutRatesInput>
  }

  export type ComicsUpdateWithoutRatesInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    keywords?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    categories?: CategoriesUpdateManyWithoutComicsNestedInput
    authors?: AuthorsUpdateManyWithoutComicsNestedInput
    volumes?: VolumesUpdateManyWithoutComicNestedInput
    favorites?: FavoritesUpdateManyWithoutComicNestedInput
    views?: ViewsUpdateManyWithoutComicNestedInput
    comment?: CommentsUpdateManyWithoutComicNestedInput
    unlock_comic?: Unlock_comicUpdateManyWithoutComicNestedInput
    user?: UsersUpdateOneRequiredWithoutComicsNestedInput
  }

  export type ComicsUncheckedUpdateWithoutRatesInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    keywords?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: IntFieldUpdateOperationsInput | number
    categories?: CategoriesUncheckedUpdateManyWithoutComicsNestedInput
    authors?: AuthorsUncheckedUpdateManyWithoutComicsNestedInput
    volumes?: VolumesUncheckedUpdateManyWithoutComicNestedInput
    favorites?: FavoritesUncheckedUpdateManyWithoutComicNestedInput
    views?: ViewsUncheckedUpdateManyWithoutComicNestedInput
    comment?: CommentsUncheckedUpdateManyWithoutComicNestedInput
    unlock_comic?: Unlock_comicUncheckedUpdateManyWithoutComicNestedInput
  }

  export type UsersCreateWithoutErrorsInput = {
    name: string
    email: string
    password: string
    description: string
    createdAt?: Date | string
    updatedAt?: Date | string
    isDisabled: boolean
    comics?: ComicsCreateNestedManyWithoutUserInput
    userRole?: RolesCreateNestedManyWithoutUsersInput
    favorites?: FavoritesCreateNestedManyWithoutUserInput
    rates?: RatesCreateNestedManyWithoutUserInput
    views?: ViewsCreateNestedManyWithoutUserInput
    coments?: CommentsCreateNestedManyWithoutUserInput
    notifications?: NotificationsCreateNestedManyWithoutUserInput
    wallets?: WalletsCreateNestedOneWithoutUserInput
    unlock_comic?: Unlock_comicCreateNestedManyWithoutUserInput
    unlock_volume?: Unlock_volumeCreateNestedManyWithoutUserInput
    unlock_chapter?: Unlock_chapterCreateNestedManyWithoutUserInput
  }

  export type UsersUncheckedCreateWithoutErrorsInput = {
    id?: number
    name: string
    email: string
    password: string
    description: string
    createdAt?: Date | string
    updatedAt?: Date | string
    isDisabled: boolean
    comics?: ComicsUncheckedCreateNestedManyWithoutUserInput
    userRole?: RolesUncheckedCreateNestedManyWithoutUsersInput
    favorites?: FavoritesUncheckedCreateNestedManyWithoutUserInput
    rates?: RatesUncheckedCreateNestedManyWithoutUserInput
    views?: ViewsUncheckedCreateNestedManyWithoutUserInput
    coments?: CommentsUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationsUncheckedCreateNestedManyWithoutUserInput
    wallets?: WalletsUncheckedCreateNestedOneWithoutUserInput
    unlock_comic?: Unlock_comicUncheckedCreateNestedManyWithoutUserInput
    unlock_volume?: Unlock_volumeUncheckedCreateNestedManyWithoutUserInput
    unlock_chapter?: Unlock_chapterUncheckedCreateNestedManyWithoutUserInput
  }

  export type UsersCreateOrConnectWithoutErrorsInput = {
    where: UsersWhereUniqueInput
    create: XOR<UsersCreateWithoutErrorsInput, UsersUncheckedCreateWithoutErrorsInput>
  }

  export type ChaptersCreateWithoutErrorsInput = {
    title: string
    filePath: string
    content: string
    price: Decimal | DecimalJsLike | number | string
    lock: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    volume: VolumesCreateNestedOneWithoutChaptersInput
    views?: ViewsCreateNestedManyWithoutChapterInput
    coments?: CommentsCreateNestedManyWithoutChapterInput
    unlock_chapter?: Unlock_chapterCreateNestedManyWithoutChapterInput
  }

  export type ChaptersUncheckedCreateWithoutErrorsInput = {
    id?: number
    title: string
    filePath: string
    content: string
    price: Decimal | DecimalJsLike | number | string
    lock: boolean
    volumeId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    views?: ViewsUncheckedCreateNestedManyWithoutChapterInput
    coments?: CommentsUncheckedCreateNestedManyWithoutChapterInput
    unlock_chapter?: Unlock_chapterUncheckedCreateNestedManyWithoutChapterInput
  }

  export type ChaptersCreateOrConnectWithoutErrorsInput = {
    where: ChaptersWhereUniqueInput
    create: XOR<ChaptersCreateWithoutErrorsInput, ChaptersUncheckedCreateWithoutErrorsInput>
  }

  export type UsersUpsertWithoutErrorsInput = {
    update: XOR<UsersUpdateWithoutErrorsInput, UsersUncheckedUpdateWithoutErrorsInput>
    create: XOR<UsersCreateWithoutErrorsInput, UsersUncheckedCreateWithoutErrorsInput>
    where?: UsersWhereInput
  }

  export type UsersUpdateToOneWithWhereWithoutErrorsInput = {
    where?: UsersWhereInput
    data: XOR<UsersUpdateWithoutErrorsInput, UsersUncheckedUpdateWithoutErrorsInput>
  }

  export type UsersUpdateWithoutErrorsInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDisabled?: BoolFieldUpdateOperationsInput | boolean
    comics?: ComicsUpdateManyWithoutUserNestedInput
    userRole?: RolesUpdateManyWithoutUsersNestedInput
    favorites?: FavoritesUpdateManyWithoutUserNestedInput
    rates?: RatesUpdateManyWithoutUserNestedInput
    views?: ViewsUpdateManyWithoutUserNestedInput
    coments?: CommentsUpdateManyWithoutUserNestedInput
    notifications?: NotificationsUpdateManyWithoutUserNestedInput
    wallets?: WalletsUpdateOneWithoutUserNestedInput
    unlock_comic?: Unlock_comicUpdateManyWithoutUserNestedInput
    unlock_volume?: Unlock_volumeUpdateManyWithoutUserNestedInput
    unlock_chapter?: Unlock_chapterUpdateManyWithoutUserNestedInput
  }

  export type UsersUncheckedUpdateWithoutErrorsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDisabled?: BoolFieldUpdateOperationsInput | boolean
    comics?: ComicsUncheckedUpdateManyWithoutUserNestedInput
    userRole?: RolesUncheckedUpdateManyWithoutUsersNestedInput
    favorites?: FavoritesUncheckedUpdateManyWithoutUserNestedInput
    rates?: RatesUncheckedUpdateManyWithoutUserNestedInput
    views?: ViewsUncheckedUpdateManyWithoutUserNestedInput
    coments?: CommentsUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationsUncheckedUpdateManyWithoutUserNestedInput
    wallets?: WalletsUncheckedUpdateOneWithoutUserNestedInput
    unlock_comic?: Unlock_comicUncheckedUpdateManyWithoutUserNestedInput
    unlock_volume?: Unlock_volumeUncheckedUpdateManyWithoutUserNestedInput
    unlock_chapter?: Unlock_chapterUncheckedUpdateManyWithoutUserNestedInput
  }

  export type ChaptersUpsertWithoutErrorsInput = {
    update: XOR<ChaptersUpdateWithoutErrorsInput, ChaptersUncheckedUpdateWithoutErrorsInput>
    create: XOR<ChaptersCreateWithoutErrorsInput, ChaptersUncheckedCreateWithoutErrorsInput>
    where?: ChaptersWhereInput
  }

  export type ChaptersUpdateToOneWithWhereWithoutErrorsInput = {
    where?: ChaptersWhereInput
    data: XOR<ChaptersUpdateWithoutErrorsInput, ChaptersUncheckedUpdateWithoutErrorsInput>
  }

  export type ChaptersUpdateWithoutErrorsInput = {
    title?: StringFieldUpdateOperationsInput | string
    filePath?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    lock?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    volume?: VolumesUpdateOneRequiredWithoutChaptersNestedInput
    views?: ViewsUpdateManyWithoutChapterNestedInput
    coments?: CommentsUpdateManyWithoutChapterNestedInput
    unlock_chapter?: Unlock_chapterUpdateManyWithoutChapterNestedInput
  }

  export type ChaptersUncheckedUpdateWithoutErrorsInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    filePath?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    lock?: BoolFieldUpdateOperationsInput | boolean
    volumeId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    views?: ViewsUncheckedUpdateManyWithoutChapterNestedInput
    coments?: CommentsUncheckedUpdateManyWithoutChapterNestedInput
    unlock_chapter?: Unlock_chapterUncheckedUpdateManyWithoutChapterNestedInput
  }

  export type UsersCreateWithoutViewsInput = {
    name: string
    email: string
    password: string
    description: string
    createdAt?: Date | string
    updatedAt?: Date | string
    isDisabled: boolean
    comics?: ComicsCreateNestedManyWithoutUserInput
    userRole?: RolesCreateNestedManyWithoutUsersInput
    favorites?: FavoritesCreateNestedManyWithoutUserInput
    rates?: RatesCreateNestedManyWithoutUserInput
    errors?: ErrorsCreateNestedManyWithoutUserInput
    coments?: CommentsCreateNestedManyWithoutUserInput
    notifications?: NotificationsCreateNestedManyWithoutUserInput
    wallets?: WalletsCreateNestedOneWithoutUserInput
    unlock_comic?: Unlock_comicCreateNestedManyWithoutUserInput
    unlock_volume?: Unlock_volumeCreateNestedManyWithoutUserInput
    unlock_chapter?: Unlock_chapterCreateNestedManyWithoutUserInput
  }

  export type UsersUncheckedCreateWithoutViewsInput = {
    id?: number
    name: string
    email: string
    password: string
    description: string
    createdAt?: Date | string
    updatedAt?: Date | string
    isDisabled: boolean
    comics?: ComicsUncheckedCreateNestedManyWithoutUserInput
    userRole?: RolesUncheckedCreateNestedManyWithoutUsersInput
    favorites?: FavoritesUncheckedCreateNestedManyWithoutUserInput
    rates?: RatesUncheckedCreateNestedManyWithoutUserInput
    errors?: ErrorsUncheckedCreateNestedManyWithoutUserInput
    coments?: CommentsUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationsUncheckedCreateNestedManyWithoutUserInput
    wallets?: WalletsUncheckedCreateNestedOneWithoutUserInput
    unlock_comic?: Unlock_comicUncheckedCreateNestedManyWithoutUserInput
    unlock_volume?: Unlock_volumeUncheckedCreateNestedManyWithoutUserInput
    unlock_chapter?: Unlock_chapterUncheckedCreateNestedManyWithoutUserInput
  }

  export type UsersCreateOrConnectWithoutViewsInput = {
    where: UsersWhereUniqueInput
    create: XOR<UsersCreateWithoutViewsInput, UsersUncheckedCreateWithoutViewsInput>
  }

  export type ComicsCreateWithoutViewsInput = {
    title: string
    description: string
    image: string
    keywords: string
    status: string
    price: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
    categories?: CategoriesCreateNestedManyWithoutComicsInput
    authors?: AuthorsCreateNestedManyWithoutComicsInput
    volumes?: VolumesCreateNestedManyWithoutComicInput
    favorites?: FavoritesCreateNestedManyWithoutComicInput
    rates?: RatesCreateNestedManyWithoutComicInput
    comment?: CommentsCreateNestedManyWithoutComicInput
    unlock_comic?: Unlock_comicCreateNestedManyWithoutComicInput
    user: UsersCreateNestedOneWithoutComicsInput
  }

  export type ComicsUncheckedCreateWithoutViewsInput = {
    id?: number
    title: string
    description: string
    image: string
    keywords: string
    status: string
    price: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
    userId: number
    categories?: CategoriesUncheckedCreateNestedManyWithoutComicsInput
    authors?: AuthorsUncheckedCreateNestedManyWithoutComicsInput
    volumes?: VolumesUncheckedCreateNestedManyWithoutComicInput
    favorites?: FavoritesUncheckedCreateNestedManyWithoutComicInput
    rates?: RatesUncheckedCreateNestedManyWithoutComicInput
    comment?: CommentsUncheckedCreateNestedManyWithoutComicInput
    unlock_comic?: Unlock_comicUncheckedCreateNestedManyWithoutComicInput
  }

  export type ComicsCreateOrConnectWithoutViewsInput = {
    where: ComicsWhereUniqueInput
    create: XOR<ComicsCreateWithoutViewsInput, ComicsUncheckedCreateWithoutViewsInput>
  }

  export type ChaptersCreateWithoutViewsInput = {
    title: string
    filePath: string
    content: string
    price: Decimal | DecimalJsLike | number | string
    lock: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    volume: VolumesCreateNestedOneWithoutChaptersInput
    errors?: ErrorsCreateNestedManyWithoutChapterInput
    coments?: CommentsCreateNestedManyWithoutChapterInput
    unlock_chapter?: Unlock_chapterCreateNestedManyWithoutChapterInput
  }

  export type ChaptersUncheckedCreateWithoutViewsInput = {
    id?: number
    title: string
    filePath: string
    content: string
    price: Decimal | DecimalJsLike | number | string
    lock: boolean
    volumeId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    errors?: ErrorsUncheckedCreateNestedManyWithoutChapterInput
    coments?: CommentsUncheckedCreateNestedManyWithoutChapterInput
    unlock_chapter?: Unlock_chapterUncheckedCreateNestedManyWithoutChapterInput
  }

  export type ChaptersCreateOrConnectWithoutViewsInput = {
    where: ChaptersWhereUniqueInput
    create: XOR<ChaptersCreateWithoutViewsInput, ChaptersUncheckedCreateWithoutViewsInput>
  }

  export type UsersUpsertWithoutViewsInput = {
    update: XOR<UsersUpdateWithoutViewsInput, UsersUncheckedUpdateWithoutViewsInput>
    create: XOR<UsersCreateWithoutViewsInput, UsersUncheckedCreateWithoutViewsInput>
    where?: UsersWhereInput
  }

  export type UsersUpdateToOneWithWhereWithoutViewsInput = {
    where?: UsersWhereInput
    data: XOR<UsersUpdateWithoutViewsInput, UsersUncheckedUpdateWithoutViewsInput>
  }

  export type UsersUpdateWithoutViewsInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDisabled?: BoolFieldUpdateOperationsInput | boolean
    comics?: ComicsUpdateManyWithoutUserNestedInput
    userRole?: RolesUpdateManyWithoutUsersNestedInput
    favorites?: FavoritesUpdateManyWithoutUserNestedInput
    rates?: RatesUpdateManyWithoutUserNestedInput
    errors?: ErrorsUpdateManyWithoutUserNestedInput
    coments?: CommentsUpdateManyWithoutUserNestedInput
    notifications?: NotificationsUpdateManyWithoutUserNestedInput
    wallets?: WalletsUpdateOneWithoutUserNestedInput
    unlock_comic?: Unlock_comicUpdateManyWithoutUserNestedInput
    unlock_volume?: Unlock_volumeUpdateManyWithoutUserNestedInput
    unlock_chapter?: Unlock_chapterUpdateManyWithoutUserNestedInput
  }

  export type UsersUncheckedUpdateWithoutViewsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDisabled?: BoolFieldUpdateOperationsInput | boolean
    comics?: ComicsUncheckedUpdateManyWithoutUserNestedInput
    userRole?: RolesUncheckedUpdateManyWithoutUsersNestedInput
    favorites?: FavoritesUncheckedUpdateManyWithoutUserNestedInput
    rates?: RatesUncheckedUpdateManyWithoutUserNestedInput
    errors?: ErrorsUncheckedUpdateManyWithoutUserNestedInput
    coments?: CommentsUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationsUncheckedUpdateManyWithoutUserNestedInput
    wallets?: WalletsUncheckedUpdateOneWithoutUserNestedInput
    unlock_comic?: Unlock_comicUncheckedUpdateManyWithoutUserNestedInput
    unlock_volume?: Unlock_volumeUncheckedUpdateManyWithoutUserNestedInput
    unlock_chapter?: Unlock_chapterUncheckedUpdateManyWithoutUserNestedInput
  }

  export type ComicsUpsertWithoutViewsInput = {
    update: XOR<ComicsUpdateWithoutViewsInput, ComicsUncheckedUpdateWithoutViewsInput>
    create: XOR<ComicsCreateWithoutViewsInput, ComicsUncheckedCreateWithoutViewsInput>
    where?: ComicsWhereInput
  }

  export type ComicsUpdateToOneWithWhereWithoutViewsInput = {
    where?: ComicsWhereInput
    data: XOR<ComicsUpdateWithoutViewsInput, ComicsUncheckedUpdateWithoutViewsInput>
  }

  export type ComicsUpdateWithoutViewsInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    keywords?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    categories?: CategoriesUpdateManyWithoutComicsNestedInput
    authors?: AuthorsUpdateManyWithoutComicsNestedInput
    volumes?: VolumesUpdateManyWithoutComicNestedInput
    favorites?: FavoritesUpdateManyWithoutComicNestedInput
    rates?: RatesUpdateManyWithoutComicNestedInput
    comment?: CommentsUpdateManyWithoutComicNestedInput
    unlock_comic?: Unlock_comicUpdateManyWithoutComicNestedInput
    user?: UsersUpdateOneRequiredWithoutComicsNestedInput
  }

  export type ComicsUncheckedUpdateWithoutViewsInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    keywords?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: IntFieldUpdateOperationsInput | number
    categories?: CategoriesUncheckedUpdateManyWithoutComicsNestedInput
    authors?: AuthorsUncheckedUpdateManyWithoutComicsNestedInput
    volumes?: VolumesUncheckedUpdateManyWithoutComicNestedInput
    favorites?: FavoritesUncheckedUpdateManyWithoutComicNestedInput
    rates?: RatesUncheckedUpdateManyWithoutComicNestedInput
    comment?: CommentsUncheckedUpdateManyWithoutComicNestedInput
    unlock_comic?: Unlock_comicUncheckedUpdateManyWithoutComicNestedInput
  }

  export type ChaptersUpsertWithoutViewsInput = {
    update: XOR<ChaptersUpdateWithoutViewsInput, ChaptersUncheckedUpdateWithoutViewsInput>
    create: XOR<ChaptersCreateWithoutViewsInput, ChaptersUncheckedCreateWithoutViewsInput>
    where?: ChaptersWhereInput
  }

  export type ChaptersUpdateToOneWithWhereWithoutViewsInput = {
    where?: ChaptersWhereInput
    data: XOR<ChaptersUpdateWithoutViewsInput, ChaptersUncheckedUpdateWithoutViewsInput>
  }

  export type ChaptersUpdateWithoutViewsInput = {
    title?: StringFieldUpdateOperationsInput | string
    filePath?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    lock?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    volume?: VolumesUpdateOneRequiredWithoutChaptersNestedInput
    errors?: ErrorsUpdateManyWithoutChapterNestedInput
    coments?: CommentsUpdateManyWithoutChapterNestedInput
    unlock_chapter?: Unlock_chapterUpdateManyWithoutChapterNestedInput
  }

  export type ChaptersUncheckedUpdateWithoutViewsInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    filePath?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    lock?: BoolFieldUpdateOperationsInput | boolean
    volumeId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    errors?: ErrorsUncheckedUpdateManyWithoutChapterNestedInput
    coments?: CommentsUncheckedUpdateManyWithoutChapterNestedInput
    unlock_chapter?: Unlock_chapterUncheckedUpdateManyWithoutChapterNestedInput
  }

  export type UsersCreateWithoutComentsInput = {
    name: string
    email: string
    password: string
    description: string
    createdAt?: Date | string
    updatedAt?: Date | string
    isDisabled: boolean
    comics?: ComicsCreateNestedManyWithoutUserInput
    userRole?: RolesCreateNestedManyWithoutUsersInput
    favorites?: FavoritesCreateNestedManyWithoutUserInput
    rates?: RatesCreateNestedManyWithoutUserInput
    errors?: ErrorsCreateNestedManyWithoutUserInput
    views?: ViewsCreateNestedManyWithoutUserInput
    notifications?: NotificationsCreateNestedManyWithoutUserInput
    wallets?: WalletsCreateNestedOneWithoutUserInput
    unlock_comic?: Unlock_comicCreateNestedManyWithoutUserInput
    unlock_volume?: Unlock_volumeCreateNestedManyWithoutUserInput
    unlock_chapter?: Unlock_chapterCreateNestedManyWithoutUserInput
  }

  export type UsersUncheckedCreateWithoutComentsInput = {
    id?: number
    name: string
    email: string
    password: string
    description: string
    createdAt?: Date | string
    updatedAt?: Date | string
    isDisabled: boolean
    comics?: ComicsUncheckedCreateNestedManyWithoutUserInput
    userRole?: RolesUncheckedCreateNestedManyWithoutUsersInput
    favorites?: FavoritesUncheckedCreateNestedManyWithoutUserInput
    rates?: RatesUncheckedCreateNestedManyWithoutUserInput
    errors?: ErrorsUncheckedCreateNestedManyWithoutUserInput
    views?: ViewsUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationsUncheckedCreateNestedManyWithoutUserInput
    wallets?: WalletsUncheckedCreateNestedOneWithoutUserInput
    unlock_comic?: Unlock_comicUncheckedCreateNestedManyWithoutUserInput
    unlock_volume?: Unlock_volumeUncheckedCreateNestedManyWithoutUserInput
    unlock_chapter?: Unlock_chapterUncheckedCreateNestedManyWithoutUserInput
  }

  export type UsersCreateOrConnectWithoutComentsInput = {
    where: UsersWhereUniqueInput
    create: XOR<UsersCreateWithoutComentsInput, UsersUncheckedCreateWithoutComentsInput>
  }

  export type ChaptersCreateWithoutComentsInput = {
    title: string
    filePath: string
    content: string
    price: Decimal | DecimalJsLike | number | string
    lock: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    volume: VolumesCreateNestedOneWithoutChaptersInput
    errors?: ErrorsCreateNestedManyWithoutChapterInput
    views?: ViewsCreateNestedManyWithoutChapterInput
    unlock_chapter?: Unlock_chapterCreateNestedManyWithoutChapterInput
  }

  export type ChaptersUncheckedCreateWithoutComentsInput = {
    id?: number
    title: string
    filePath: string
    content: string
    price: Decimal | DecimalJsLike | number | string
    lock: boolean
    volumeId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    errors?: ErrorsUncheckedCreateNestedManyWithoutChapterInput
    views?: ViewsUncheckedCreateNestedManyWithoutChapterInput
    unlock_chapter?: Unlock_chapterUncheckedCreateNestedManyWithoutChapterInput
  }

  export type ChaptersCreateOrConnectWithoutComentsInput = {
    where: ChaptersWhereUniqueInput
    create: XOR<ChaptersCreateWithoutComentsInput, ChaptersUncheckedCreateWithoutComentsInput>
  }

  export type ComicsCreateWithoutCommentInput = {
    title: string
    description: string
    image: string
    keywords: string
    status: string
    price: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
    categories?: CategoriesCreateNestedManyWithoutComicsInput
    authors?: AuthorsCreateNestedManyWithoutComicsInput
    volumes?: VolumesCreateNestedManyWithoutComicInput
    favorites?: FavoritesCreateNestedManyWithoutComicInput
    rates?: RatesCreateNestedManyWithoutComicInput
    views?: ViewsCreateNestedManyWithoutComicInput
    unlock_comic?: Unlock_comicCreateNestedManyWithoutComicInput
    user: UsersCreateNestedOneWithoutComicsInput
  }

  export type ComicsUncheckedCreateWithoutCommentInput = {
    id?: number
    title: string
    description: string
    image: string
    keywords: string
    status: string
    price: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
    userId: number
    categories?: CategoriesUncheckedCreateNestedManyWithoutComicsInput
    authors?: AuthorsUncheckedCreateNestedManyWithoutComicsInput
    volumes?: VolumesUncheckedCreateNestedManyWithoutComicInput
    favorites?: FavoritesUncheckedCreateNestedManyWithoutComicInput
    rates?: RatesUncheckedCreateNestedManyWithoutComicInput
    views?: ViewsUncheckedCreateNestedManyWithoutComicInput
    unlock_comic?: Unlock_comicUncheckedCreateNestedManyWithoutComicInput
  }

  export type ComicsCreateOrConnectWithoutCommentInput = {
    where: ComicsWhereUniqueInput
    create: XOR<ComicsCreateWithoutCommentInput, ComicsUncheckedCreateWithoutCommentInput>
  }

  export type NotificationsCreateWithoutCommentInput = {
    content: string
    isRead: boolean
    createdAt?: Date | string
    user: UsersCreateNestedOneWithoutNotificationsInput
  }

  export type NotificationsUncheckedCreateWithoutCommentInput = {
    id?: number
    userId: number
    content: string
    isRead: boolean
    createdAt?: Date | string
  }

  export type NotificationsCreateOrConnectWithoutCommentInput = {
    where: NotificationsWhereUniqueInput
    create: XOR<NotificationsCreateWithoutCommentInput, NotificationsUncheckedCreateWithoutCommentInput>
  }

  export type NotificationsCreateManyCommentInputEnvelope = {
    data: NotificationsCreateManyCommentInput | NotificationsCreateManyCommentInput[]
    skipDuplicates?: boolean
  }

  export type UsersUpsertWithoutComentsInput = {
    update: XOR<UsersUpdateWithoutComentsInput, UsersUncheckedUpdateWithoutComentsInput>
    create: XOR<UsersCreateWithoutComentsInput, UsersUncheckedCreateWithoutComentsInput>
    where?: UsersWhereInput
  }

  export type UsersUpdateToOneWithWhereWithoutComentsInput = {
    where?: UsersWhereInput
    data: XOR<UsersUpdateWithoutComentsInput, UsersUncheckedUpdateWithoutComentsInput>
  }

  export type UsersUpdateWithoutComentsInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDisabled?: BoolFieldUpdateOperationsInput | boolean
    comics?: ComicsUpdateManyWithoutUserNestedInput
    userRole?: RolesUpdateManyWithoutUsersNestedInput
    favorites?: FavoritesUpdateManyWithoutUserNestedInput
    rates?: RatesUpdateManyWithoutUserNestedInput
    errors?: ErrorsUpdateManyWithoutUserNestedInput
    views?: ViewsUpdateManyWithoutUserNestedInput
    notifications?: NotificationsUpdateManyWithoutUserNestedInput
    wallets?: WalletsUpdateOneWithoutUserNestedInput
    unlock_comic?: Unlock_comicUpdateManyWithoutUserNestedInput
    unlock_volume?: Unlock_volumeUpdateManyWithoutUserNestedInput
    unlock_chapter?: Unlock_chapterUpdateManyWithoutUserNestedInput
  }

  export type UsersUncheckedUpdateWithoutComentsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDisabled?: BoolFieldUpdateOperationsInput | boolean
    comics?: ComicsUncheckedUpdateManyWithoutUserNestedInput
    userRole?: RolesUncheckedUpdateManyWithoutUsersNestedInput
    favorites?: FavoritesUncheckedUpdateManyWithoutUserNestedInput
    rates?: RatesUncheckedUpdateManyWithoutUserNestedInput
    errors?: ErrorsUncheckedUpdateManyWithoutUserNestedInput
    views?: ViewsUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationsUncheckedUpdateManyWithoutUserNestedInput
    wallets?: WalletsUncheckedUpdateOneWithoutUserNestedInput
    unlock_comic?: Unlock_comicUncheckedUpdateManyWithoutUserNestedInput
    unlock_volume?: Unlock_volumeUncheckedUpdateManyWithoutUserNestedInput
    unlock_chapter?: Unlock_chapterUncheckedUpdateManyWithoutUserNestedInput
  }

  export type ChaptersUpsertWithoutComentsInput = {
    update: XOR<ChaptersUpdateWithoutComentsInput, ChaptersUncheckedUpdateWithoutComentsInput>
    create: XOR<ChaptersCreateWithoutComentsInput, ChaptersUncheckedCreateWithoutComentsInput>
    where?: ChaptersWhereInput
  }

  export type ChaptersUpdateToOneWithWhereWithoutComentsInput = {
    where?: ChaptersWhereInput
    data: XOR<ChaptersUpdateWithoutComentsInput, ChaptersUncheckedUpdateWithoutComentsInput>
  }

  export type ChaptersUpdateWithoutComentsInput = {
    title?: StringFieldUpdateOperationsInput | string
    filePath?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    lock?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    volume?: VolumesUpdateOneRequiredWithoutChaptersNestedInput
    errors?: ErrorsUpdateManyWithoutChapterNestedInput
    views?: ViewsUpdateManyWithoutChapterNestedInput
    unlock_chapter?: Unlock_chapterUpdateManyWithoutChapterNestedInput
  }

  export type ChaptersUncheckedUpdateWithoutComentsInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    filePath?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    lock?: BoolFieldUpdateOperationsInput | boolean
    volumeId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    errors?: ErrorsUncheckedUpdateManyWithoutChapterNestedInput
    views?: ViewsUncheckedUpdateManyWithoutChapterNestedInput
    unlock_chapter?: Unlock_chapterUncheckedUpdateManyWithoutChapterNestedInput
  }

  export type ComicsUpsertWithoutCommentInput = {
    update: XOR<ComicsUpdateWithoutCommentInput, ComicsUncheckedUpdateWithoutCommentInput>
    create: XOR<ComicsCreateWithoutCommentInput, ComicsUncheckedCreateWithoutCommentInput>
    where?: ComicsWhereInput
  }

  export type ComicsUpdateToOneWithWhereWithoutCommentInput = {
    where?: ComicsWhereInput
    data: XOR<ComicsUpdateWithoutCommentInput, ComicsUncheckedUpdateWithoutCommentInput>
  }

  export type ComicsUpdateWithoutCommentInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    keywords?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    categories?: CategoriesUpdateManyWithoutComicsNestedInput
    authors?: AuthorsUpdateManyWithoutComicsNestedInput
    volumes?: VolumesUpdateManyWithoutComicNestedInput
    favorites?: FavoritesUpdateManyWithoutComicNestedInput
    rates?: RatesUpdateManyWithoutComicNestedInput
    views?: ViewsUpdateManyWithoutComicNestedInput
    unlock_comic?: Unlock_comicUpdateManyWithoutComicNestedInput
    user?: UsersUpdateOneRequiredWithoutComicsNestedInput
  }

  export type ComicsUncheckedUpdateWithoutCommentInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    keywords?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: IntFieldUpdateOperationsInput | number
    categories?: CategoriesUncheckedUpdateManyWithoutComicsNestedInput
    authors?: AuthorsUncheckedUpdateManyWithoutComicsNestedInput
    volumes?: VolumesUncheckedUpdateManyWithoutComicNestedInput
    favorites?: FavoritesUncheckedUpdateManyWithoutComicNestedInput
    rates?: RatesUncheckedUpdateManyWithoutComicNestedInput
    views?: ViewsUncheckedUpdateManyWithoutComicNestedInput
    unlock_comic?: Unlock_comicUncheckedUpdateManyWithoutComicNestedInput
  }

  export type NotificationsUpsertWithWhereUniqueWithoutCommentInput = {
    where: NotificationsWhereUniqueInput
    update: XOR<NotificationsUpdateWithoutCommentInput, NotificationsUncheckedUpdateWithoutCommentInput>
    create: XOR<NotificationsCreateWithoutCommentInput, NotificationsUncheckedCreateWithoutCommentInput>
  }

  export type NotificationsUpdateWithWhereUniqueWithoutCommentInput = {
    where: NotificationsWhereUniqueInput
    data: XOR<NotificationsUpdateWithoutCommentInput, NotificationsUncheckedUpdateWithoutCommentInput>
  }

  export type NotificationsUpdateManyWithWhereWithoutCommentInput = {
    where: NotificationsScalarWhereInput
    data: XOR<NotificationsUpdateManyMutationInput, NotificationsUncheckedUpdateManyWithoutCommentInput>
  }

  export type UsersCreateWithoutNotificationsInput = {
    name: string
    email: string
    password: string
    description: string
    createdAt?: Date | string
    updatedAt?: Date | string
    isDisabled: boolean
    comics?: ComicsCreateNestedManyWithoutUserInput
    userRole?: RolesCreateNestedManyWithoutUsersInput
    favorites?: FavoritesCreateNestedManyWithoutUserInput
    rates?: RatesCreateNestedManyWithoutUserInput
    errors?: ErrorsCreateNestedManyWithoutUserInput
    views?: ViewsCreateNestedManyWithoutUserInput
    coments?: CommentsCreateNestedManyWithoutUserInput
    wallets?: WalletsCreateNestedOneWithoutUserInput
    unlock_comic?: Unlock_comicCreateNestedManyWithoutUserInput
    unlock_volume?: Unlock_volumeCreateNestedManyWithoutUserInput
    unlock_chapter?: Unlock_chapterCreateNestedManyWithoutUserInput
  }

  export type UsersUncheckedCreateWithoutNotificationsInput = {
    id?: number
    name: string
    email: string
    password: string
    description: string
    createdAt?: Date | string
    updatedAt?: Date | string
    isDisabled: boolean
    comics?: ComicsUncheckedCreateNestedManyWithoutUserInput
    userRole?: RolesUncheckedCreateNestedManyWithoutUsersInput
    favorites?: FavoritesUncheckedCreateNestedManyWithoutUserInput
    rates?: RatesUncheckedCreateNestedManyWithoutUserInput
    errors?: ErrorsUncheckedCreateNestedManyWithoutUserInput
    views?: ViewsUncheckedCreateNestedManyWithoutUserInput
    coments?: CommentsUncheckedCreateNestedManyWithoutUserInput
    wallets?: WalletsUncheckedCreateNestedOneWithoutUserInput
    unlock_comic?: Unlock_comicUncheckedCreateNestedManyWithoutUserInput
    unlock_volume?: Unlock_volumeUncheckedCreateNestedManyWithoutUserInput
    unlock_chapter?: Unlock_chapterUncheckedCreateNestedManyWithoutUserInput
  }

  export type UsersCreateOrConnectWithoutNotificationsInput = {
    where: UsersWhereUniqueInput
    create: XOR<UsersCreateWithoutNotificationsInput, UsersUncheckedCreateWithoutNotificationsInput>
  }

  export type CommentsCreateWithoutNotificationInput = {
    content: string
    createdAt?: Date | string
    user: UsersCreateNestedOneWithoutComentsInput
    chapter?: ChaptersCreateNestedOneWithoutComentsInput
    comic: ComicsCreateNestedOneWithoutCommentInput
  }

  export type CommentsUncheckedCreateWithoutNotificationInput = {
    id?: number
    content: string
    userId: number
    chapterId?: number | null
    comicId: number
    createdAt?: Date | string
  }

  export type CommentsCreateOrConnectWithoutNotificationInput = {
    where: CommentsWhereUniqueInput
    create: XOR<CommentsCreateWithoutNotificationInput, CommentsUncheckedCreateWithoutNotificationInput>
  }

  export type UsersUpsertWithoutNotificationsInput = {
    update: XOR<UsersUpdateWithoutNotificationsInput, UsersUncheckedUpdateWithoutNotificationsInput>
    create: XOR<UsersCreateWithoutNotificationsInput, UsersUncheckedCreateWithoutNotificationsInput>
    where?: UsersWhereInput
  }

  export type UsersUpdateToOneWithWhereWithoutNotificationsInput = {
    where?: UsersWhereInput
    data: XOR<UsersUpdateWithoutNotificationsInput, UsersUncheckedUpdateWithoutNotificationsInput>
  }

  export type UsersUpdateWithoutNotificationsInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDisabled?: BoolFieldUpdateOperationsInput | boolean
    comics?: ComicsUpdateManyWithoutUserNestedInput
    userRole?: RolesUpdateManyWithoutUsersNestedInput
    favorites?: FavoritesUpdateManyWithoutUserNestedInput
    rates?: RatesUpdateManyWithoutUserNestedInput
    errors?: ErrorsUpdateManyWithoutUserNestedInput
    views?: ViewsUpdateManyWithoutUserNestedInput
    coments?: CommentsUpdateManyWithoutUserNestedInput
    wallets?: WalletsUpdateOneWithoutUserNestedInput
    unlock_comic?: Unlock_comicUpdateManyWithoutUserNestedInput
    unlock_volume?: Unlock_volumeUpdateManyWithoutUserNestedInput
    unlock_chapter?: Unlock_chapterUpdateManyWithoutUserNestedInput
  }

  export type UsersUncheckedUpdateWithoutNotificationsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDisabled?: BoolFieldUpdateOperationsInput | boolean
    comics?: ComicsUncheckedUpdateManyWithoutUserNestedInput
    userRole?: RolesUncheckedUpdateManyWithoutUsersNestedInput
    favorites?: FavoritesUncheckedUpdateManyWithoutUserNestedInput
    rates?: RatesUncheckedUpdateManyWithoutUserNestedInput
    errors?: ErrorsUncheckedUpdateManyWithoutUserNestedInput
    views?: ViewsUncheckedUpdateManyWithoutUserNestedInput
    coments?: CommentsUncheckedUpdateManyWithoutUserNestedInput
    wallets?: WalletsUncheckedUpdateOneWithoutUserNestedInput
    unlock_comic?: Unlock_comicUncheckedUpdateManyWithoutUserNestedInput
    unlock_volume?: Unlock_volumeUncheckedUpdateManyWithoutUserNestedInput
    unlock_chapter?: Unlock_chapterUncheckedUpdateManyWithoutUserNestedInput
  }

  export type CommentsUpsertWithoutNotificationInput = {
    update: XOR<CommentsUpdateWithoutNotificationInput, CommentsUncheckedUpdateWithoutNotificationInput>
    create: XOR<CommentsCreateWithoutNotificationInput, CommentsUncheckedCreateWithoutNotificationInput>
    where?: CommentsWhereInput
  }

  export type CommentsUpdateToOneWithWhereWithoutNotificationInput = {
    where?: CommentsWhereInput
    data: XOR<CommentsUpdateWithoutNotificationInput, CommentsUncheckedUpdateWithoutNotificationInput>
  }

  export type CommentsUpdateWithoutNotificationInput = {
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UsersUpdateOneRequiredWithoutComentsNestedInput
    chapter?: ChaptersUpdateOneWithoutComentsNestedInput
    comic?: ComicsUpdateOneRequiredWithoutCommentNestedInput
  }

  export type CommentsUncheckedUpdateWithoutNotificationInput = {
    id?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    userId?: IntFieldUpdateOperationsInput | number
    chapterId?: NullableIntFieldUpdateOperationsInput | number | null
    comicId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UsersCreateWithoutWalletsInput = {
    name: string
    email: string
    password: string
    description: string
    createdAt?: Date | string
    updatedAt?: Date | string
    isDisabled: boolean
    comics?: ComicsCreateNestedManyWithoutUserInput
    userRole?: RolesCreateNestedManyWithoutUsersInput
    favorites?: FavoritesCreateNestedManyWithoutUserInput
    rates?: RatesCreateNestedManyWithoutUserInput
    errors?: ErrorsCreateNestedManyWithoutUserInput
    views?: ViewsCreateNestedManyWithoutUserInput
    coments?: CommentsCreateNestedManyWithoutUserInput
    notifications?: NotificationsCreateNestedManyWithoutUserInput
    unlock_comic?: Unlock_comicCreateNestedManyWithoutUserInput
    unlock_volume?: Unlock_volumeCreateNestedManyWithoutUserInput
    unlock_chapter?: Unlock_chapterCreateNestedManyWithoutUserInput
  }

  export type UsersUncheckedCreateWithoutWalletsInput = {
    id?: number
    name: string
    email: string
    password: string
    description: string
    createdAt?: Date | string
    updatedAt?: Date | string
    isDisabled: boolean
    comics?: ComicsUncheckedCreateNestedManyWithoutUserInput
    userRole?: RolesUncheckedCreateNestedManyWithoutUsersInput
    favorites?: FavoritesUncheckedCreateNestedManyWithoutUserInput
    rates?: RatesUncheckedCreateNestedManyWithoutUserInput
    errors?: ErrorsUncheckedCreateNestedManyWithoutUserInput
    views?: ViewsUncheckedCreateNestedManyWithoutUserInput
    coments?: CommentsUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationsUncheckedCreateNestedManyWithoutUserInput
    unlock_comic?: Unlock_comicUncheckedCreateNestedManyWithoutUserInput
    unlock_volume?: Unlock_volumeUncheckedCreateNestedManyWithoutUserInput
    unlock_chapter?: Unlock_chapterUncheckedCreateNestedManyWithoutUserInput
  }

  export type UsersCreateOrConnectWithoutWalletsInput = {
    where: UsersWhereUniqueInput
    create: XOR<UsersCreateWithoutWalletsInput, UsersUncheckedCreateWithoutWalletsInput>
  }

  export type TransactionsCreateWithoutWalletInput = {
    amount: Decimal | DecimalJsLike | number | string
    description: string
    status: string
    createdAt?: Date | string
    unlock_comic?: Unlock_comicCreateNestedManyWithoutTransactionInput
    unlock_volume?: Unlock_volumeCreateNestedManyWithoutTransactionInput
    unlock_chapter?: Unlock_chapterCreateNestedManyWithoutTransactionInput
  }

  export type TransactionsUncheckedCreateWithoutWalletInput = {
    id?: number
    amount: Decimal | DecimalJsLike | number | string
    description: string
    status: string
    createdAt?: Date | string
    unlock_comic?: Unlock_comicUncheckedCreateNestedManyWithoutTransactionInput
    unlock_volume?: Unlock_volumeUncheckedCreateNestedManyWithoutTransactionInput
    unlock_chapter?: Unlock_chapterUncheckedCreateNestedManyWithoutTransactionInput
  }

  export type TransactionsCreateOrConnectWithoutWalletInput = {
    where: TransactionsWhereUniqueInput
    create: XOR<TransactionsCreateWithoutWalletInput, TransactionsUncheckedCreateWithoutWalletInput>
  }

  export type TransactionsCreateManyWalletInputEnvelope = {
    data: TransactionsCreateManyWalletInput | TransactionsCreateManyWalletInput[]
    skipDuplicates?: boolean
  }

  export type UsersUpsertWithoutWalletsInput = {
    update: XOR<UsersUpdateWithoutWalletsInput, UsersUncheckedUpdateWithoutWalletsInput>
    create: XOR<UsersCreateWithoutWalletsInput, UsersUncheckedCreateWithoutWalletsInput>
    where?: UsersWhereInput
  }

  export type UsersUpdateToOneWithWhereWithoutWalletsInput = {
    where?: UsersWhereInput
    data: XOR<UsersUpdateWithoutWalletsInput, UsersUncheckedUpdateWithoutWalletsInput>
  }

  export type UsersUpdateWithoutWalletsInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDisabled?: BoolFieldUpdateOperationsInput | boolean
    comics?: ComicsUpdateManyWithoutUserNestedInput
    userRole?: RolesUpdateManyWithoutUsersNestedInput
    favorites?: FavoritesUpdateManyWithoutUserNestedInput
    rates?: RatesUpdateManyWithoutUserNestedInput
    errors?: ErrorsUpdateManyWithoutUserNestedInput
    views?: ViewsUpdateManyWithoutUserNestedInput
    coments?: CommentsUpdateManyWithoutUserNestedInput
    notifications?: NotificationsUpdateManyWithoutUserNestedInput
    unlock_comic?: Unlock_comicUpdateManyWithoutUserNestedInput
    unlock_volume?: Unlock_volumeUpdateManyWithoutUserNestedInput
    unlock_chapter?: Unlock_chapterUpdateManyWithoutUserNestedInput
  }

  export type UsersUncheckedUpdateWithoutWalletsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDisabled?: BoolFieldUpdateOperationsInput | boolean
    comics?: ComicsUncheckedUpdateManyWithoutUserNestedInput
    userRole?: RolesUncheckedUpdateManyWithoutUsersNestedInput
    favorites?: FavoritesUncheckedUpdateManyWithoutUserNestedInput
    rates?: RatesUncheckedUpdateManyWithoutUserNestedInput
    errors?: ErrorsUncheckedUpdateManyWithoutUserNestedInput
    views?: ViewsUncheckedUpdateManyWithoutUserNestedInput
    coments?: CommentsUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationsUncheckedUpdateManyWithoutUserNestedInput
    unlock_comic?: Unlock_comicUncheckedUpdateManyWithoutUserNestedInput
    unlock_volume?: Unlock_volumeUncheckedUpdateManyWithoutUserNestedInput
    unlock_chapter?: Unlock_chapterUncheckedUpdateManyWithoutUserNestedInput
  }

  export type TransactionsUpsertWithWhereUniqueWithoutWalletInput = {
    where: TransactionsWhereUniqueInput
    update: XOR<TransactionsUpdateWithoutWalletInput, TransactionsUncheckedUpdateWithoutWalletInput>
    create: XOR<TransactionsCreateWithoutWalletInput, TransactionsUncheckedCreateWithoutWalletInput>
  }

  export type TransactionsUpdateWithWhereUniqueWithoutWalletInput = {
    where: TransactionsWhereUniqueInput
    data: XOR<TransactionsUpdateWithoutWalletInput, TransactionsUncheckedUpdateWithoutWalletInput>
  }

  export type TransactionsUpdateManyWithWhereWithoutWalletInput = {
    where: TransactionsScalarWhereInput
    data: XOR<TransactionsUpdateManyMutationInput, TransactionsUncheckedUpdateManyWithoutWalletInput>
  }

  export type TransactionsScalarWhereInput = {
    AND?: TransactionsScalarWhereInput | TransactionsScalarWhereInput[]
    OR?: TransactionsScalarWhereInput[]
    NOT?: TransactionsScalarWhereInput | TransactionsScalarWhereInput[]
    id?: IntFilter<"Transactions"> | number
    walletId?: IntFilter<"Transactions"> | number
    amount?: DecimalFilter<"Transactions"> | Decimal | DecimalJsLike | number | string
    description?: StringFilter<"Transactions"> | string
    status?: StringFilter<"Transactions"> | string
    createdAt?: DateTimeFilter<"Transactions"> | Date | string
  }

  export type WalletsCreateWithoutTransactionsInput = {
    value: Decimal | DecimalJsLike | number | string
    updatedAt?: Date | string
    user: UsersCreateNestedOneWithoutWalletsInput
  }

  export type WalletsUncheckedCreateWithoutTransactionsInput = {
    id?: number
    userId: number
    value: Decimal | DecimalJsLike | number | string
    updatedAt?: Date | string
  }

  export type WalletsCreateOrConnectWithoutTransactionsInput = {
    where: WalletsWhereUniqueInput
    create: XOR<WalletsCreateWithoutTransactionsInput, WalletsUncheckedCreateWithoutTransactionsInput>
  }

  export type Unlock_comicCreateWithoutTransactionInput = {
    createdAt?: Date | string
    user: UsersCreateNestedOneWithoutUnlock_comicInput
    comic: ComicsCreateNestedOneWithoutUnlock_comicInput
  }

  export type Unlock_comicUncheckedCreateWithoutTransactionInput = {
    userId: number
    comicId: number
    createdAt?: Date | string
  }

  export type Unlock_comicCreateOrConnectWithoutTransactionInput = {
    where: Unlock_comicWhereUniqueInput
    create: XOR<Unlock_comicCreateWithoutTransactionInput, Unlock_comicUncheckedCreateWithoutTransactionInput>
  }

  export type Unlock_comicCreateManyTransactionInputEnvelope = {
    data: Unlock_comicCreateManyTransactionInput | Unlock_comicCreateManyTransactionInput[]
    skipDuplicates?: boolean
  }

  export type Unlock_volumeCreateWithoutTransactionInput = {
    createdAt?: Date | string
    user: UsersCreateNestedOneWithoutUnlock_volumeInput
    volume: VolumesCreateNestedOneWithoutUnlock_volumeInput
  }

  export type Unlock_volumeUncheckedCreateWithoutTransactionInput = {
    userId: number
    volumeId: number
    createdAt?: Date | string
  }

  export type Unlock_volumeCreateOrConnectWithoutTransactionInput = {
    where: Unlock_volumeWhereUniqueInput
    create: XOR<Unlock_volumeCreateWithoutTransactionInput, Unlock_volumeUncheckedCreateWithoutTransactionInput>
  }

  export type Unlock_volumeCreateManyTransactionInputEnvelope = {
    data: Unlock_volumeCreateManyTransactionInput | Unlock_volumeCreateManyTransactionInput[]
    skipDuplicates?: boolean
  }

  export type Unlock_chapterCreateWithoutTransactionInput = {
    createdAt?: Date | string
    user: UsersCreateNestedOneWithoutUnlock_chapterInput
    chapter: ChaptersCreateNestedOneWithoutUnlock_chapterInput
  }

  export type Unlock_chapterUncheckedCreateWithoutTransactionInput = {
    userId: number
    chapterId: number
    createdAt?: Date | string
  }

  export type Unlock_chapterCreateOrConnectWithoutTransactionInput = {
    where: Unlock_chapterWhereUniqueInput
    create: XOR<Unlock_chapterCreateWithoutTransactionInput, Unlock_chapterUncheckedCreateWithoutTransactionInput>
  }

  export type Unlock_chapterCreateManyTransactionInputEnvelope = {
    data: Unlock_chapterCreateManyTransactionInput | Unlock_chapterCreateManyTransactionInput[]
    skipDuplicates?: boolean
  }

  export type WalletsUpsertWithoutTransactionsInput = {
    update: XOR<WalletsUpdateWithoutTransactionsInput, WalletsUncheckedUpdateWithoutTransactionsInput>
    create: XOR<WalletsCreateWithoutTransactionsInput, WalletsUncheckedCreateWithoutTransactionsInput>
    where?: WalletsWhereInput
  }

  export type WalletsUpdateToOneWithWhereWithoutTransactionsInput = {
    where?: WalletsWhereInput
    data: XOR<WalletsUpdateWithoutTransactionsInput, WalletsUncheckedUpdateWithoutTransactionsInput>
  }

  export type WalletsUpdateWithoutTransactionsInput = {
    value?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UsersUpdateOneRequiredWithoutWalletsNestedInput
  }

  export type WalletsUncheckedUpdateWithoutTransactionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    value?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type Unlock_comicUpsertWithWhereUniqueWithoutTransactionInput = {
    where: Unlock_comicWhereUniqueInput
    update: XOR<Unlock_comicUpdateWithoutTransactionInput, Unlock_comicUncheckedUpdateWithoutTransactionInput>
    create: XOR<Unlock_comicCreateWithoutTransactionInput, Unlock_comicUncheckedCreateWithoutTransactionInput>
  }

  export type Unlock_comicUpdateWithWhereUniqueWithoutTransactionInput = {
    where: Unlock_comicWhereUniqueInput
    data: XOR<Unlock_comicUpdateWithoutTransactionInput, Unlock_comicUncheckedUpdateWithoutTransactionInput>
  }

  export type Unlock_comicUpdateManyWithWhereWithoutTransactionInput = {
    where: Unlock_comicScalarWhereInput
    data: XOR<Unlock_comicUpdateManyMutationInput, Unlock_comicUncheckedUpdateManyWithoutTransactionInput>
  }

  export type Unlock_volumeUpsertWithWhereUniqueWithoutTransactionInput = {
    where: Unlock_volumeWhereUniqueInput
    update: XOR<Unlock_volumeUpdateWithoutTransactionInput, Unlock_volumeUncheckedUpdateWithoutTransactionInput>
    create: XOR<Unlock_volumeCreateWithoutTransactionInput, Unlock_volumeUncheckedCreateWithoutTransactionInput>
  }

  export type Unlock_volumeUpdateWithWhereUniqueWithoutTransactionInput = {
    where: Unlock_volumeWhereUniqueInput
    data: XOR<Unlock_volumeUpdateWithoutTransactionInput, Unlock_volumeUncheckedUpdateWithoutTransactionInput>
  }

  export type Unlock_volumeUpdateManyWithWhereWithoutTransactionInput = {
    where: Unlock_volumeScalarWhereInput
    data: XOR<Unlock_volumeUpdateManyMutationInput, Unlock_volumeUncheckedUpdateManyWithoutTransactionInput>
  }

  export type Unlock_chapterUpsertWithWhereUniqueWithoutTransactionInput = {
    where: Unlock_chapterWhereUniqueInput
    update: XOR<Unlock_chapterUpdateWithoutTransactionInput, Unlock_chapterUncheckedUpdateWithoutTransactionInput>
    create: XOR<Unlock_chapterCreateWithoutTransactionInput, Unlock_chapterUncheckedCreateWithoutTransactionInput>
  }

  export type Unlock_chapterUpdateWithWhereUniqueWithoutTransactionInput = {
    where: Unlock_chapterWhereUniqueInput
    data: XOR<Unlock_chapterUpdateWithoutTransactionInput, Unlock_chapterUncheckedUpdateWithoutTransactionInput>
  }

  export type Unlock_chapterUpdateManyWithWhereWithoutTransactionInput = {
    where: Unlock_chapterScalarWhereInput
    data: XOR<Unlock_chapterUpdateManyMutationInput, Unlock_chapterUncheckedUpdateManyWithoutTransactionInput>
  }

  export type UsersCreateWithoutUnlock_comicInput = {
    name: string
    email: string
    password: string
    description: string
    createdAt?: Date | string
    updatedAt?: Date | string
    isDisabled: boolean
    comics?: ComicsCreateNestedManyWithoutUserInput
    userRole?: RolesCreateNestedManyWithoutUsersInput
    favorites?: FavoritesCreateNestedManyWithoutUserInput
    rates?: RatesCreateNestedManyWithoutUserInput
    errors?: ErrorsCreateNestedManyWithoutUserInput
    views?: ViewsCreateNestedManyWithoutUserInput
    coments?: CommentsCreateNestedManyWithoutUserInput
    notifications?: NotificationsCreateNestedManyWithoutUserInput
    wallets?: WalletsCreateNestedOneWithoutUserInput
    unlock_volume?: Unlock_volumeCreateNestedManyWithoutUserInput
    unlock_chapter?: Unlock_chapterCreateNestedManyWithoutUserInput
  }

  export type UsersUncheckedCreateWithoutUnlock_comicInput = {
    id?: number
    name: string
    email: string
    password: string
    description: string
    createdAt?: Date | string
    updatedAt?: Date | string
    isDisabled: boolean
    comics?: ComicsUncheckedCreateNestedManyWithoutUserInput
    userRole?: RolesUncheckedCreateNestedManyWithoutUsersInput
    favorites?: FavoritesUncheckedCreateNestedManyWithoutUserInput
    rates?: RatesUncheckedCreateNestedManyWithoutUserInput
    errors?: ErrorsUncheckedCreateNestedManyWithoutUserInput
    views?: ViewsUncheckedCreateNestedManyWithoutUserInput
    coments?: CommentsUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationsUncheckedCreateNestedManyWithoutUserInput
    wallets?: WalletsUncheckedCreateNestedOneWithoutUserInput
    unlock_volume?: Unlock_volumeUncheckedCreateNestedManyWithoutUserInput
    unlock_chapter?: Unlock_chapterUncheckedCreateNestedManyWithoutUserInput
  }

  export type UsersCreateOrConnectWithoutUnlock_comicInput = {
    where: UsersWhereUniqueInput
    create: XOR<UsersCreateWithoutUnlock_comicInput, UsersUncheckedCreateWithoutUnlock_comicInput>
  }

  export type ComicsCreateWithoutUnlock_comicInput = {
    title: string
    description: string
    image: string
    keywords: string
    status: string
    price: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
    categories?: CategoriesCreateNestedManyWithoutComicsInput
    authors?: AuthorsCreateNestedManyWithoutComicsInput
    volumes?: VolumesCreateNestedManyWithoutComicInput
    favorites?: FavoritesCreateNestedManyWithoutComicInput
    rates?: RatesCreateNestedManyWithoutComicInput
    views?: ViewsCreateNestedManyWithoutComicInput
    comment?: CommentsCreateNestedManyWithoutComicInput
    user: UsersCreateNestedOneWithoutComicsInput
  }

  export type ComicsUncheckedCreateWithoutUnlock_comicInput = {
    id?: number
    title: string
    description: string
    image: string
    keywords: string
    status: string
    price: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
    userId: number
    categories?: CategoriesUncheckedCreateNestedManyWithoutComicsInput
    authors?: AuthorsUncheckedCreateNestedManyWithoutComicsInput
    volumes?: VolumesUncheckedCreateNestedManyWithoutComicInput
    favorites?: FavoritesUncheckedCreateNestedManyWithoutComicInput
    rates?: RatesUncheckedCreateNestedManyWithoutComicInput
    views?: ViewsUncheckedCreateNestedManyWithoutComicInput
    comment?: CommentsUncheckedCreateNestedManyWithoutComicInput
  }

  export type ComicsCreateOrConnectWithoutUnlock_comicInput = {
    where: ComicsWhereUniqueInput
    create: XOR<ComicsCreateWithoutUnlock_comicInput, ComicsUncheckedCreateWithoutUnlock_comicInput>
  }

  export type TransactionsCreateWithoutUnlock_comicInput = {
    amount: Decimal | DecimalJsLike | number | string
    description: string
    status: string
    createdAt?: Date | string
    wallet: WalletsCreateNestedOneWithoutTransactionsInput
    unlock_volume?: Unlock_volumeCreateNestedManyWithoutTransactionInput
    unlock_chapter?: Unlock_chapterCreateNestedManyWithoutTransactionInput
  }

  export type TransactionsUncheckedCreateWithoutUnlock_comicInput = {
    id?: number
    walletId: number
    amount: Decimal | DecimalJsLike | number | string
    description: string
    status: string
    createdAt?: Date | string
    unlock_volume?: Unlock_volumeUncheckedCreateNestedManyWithoutTransactionInput
    unlock_chapter?: Unlock_chapterUncheckedCreateNestedManyWithoutTransactionInput
  }

  export type TransactionsCreateOrConnectWithoutUnlock_comicInput = {
    where: TransactionsWhereUniqueInput
    create: XOR<TransactionsCreateWithoutUnlock_comicInput, TransactionsUncheckedCreateWithoutUnlock_comicInput>
  }

  export type UsersUpsertWithoutUnlock_comicInput = {
    update: XOR<UsersUpdateWithoutUnlock_comicInput, UsersUncheckedUpdateWithoutUnlock_comicInput>
    create: XOR<UsersCreateWithoutUnlock_comicInput, UsersUncheckedCreateWithoutUnlock_comicInput>
    where?: UsersWhereInput
  }

  export type UsersUpdateToOneWithWhereWithoutUnlock_comicInput = {
    where?: UsersWhereInput
    data: XOR<UsersUpdateWithoutUnlock_comicInput, UsersUncheckedUpdateWithoutUnlock_comicInput>
  }

  export type UsersUpdateWithoutUnlock_comicInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDisabled?: BoolFieldUpdateOperationsInput | boolean
    comics?: ComicsUpdateManyWithoutUserNestedInput
    userRole?: RolesUpdateManyWithoutUsersNestedInput
    favorites?: FavoritesUpdateManyWithoutUserNestedInput
    rates?: RatesUpdateManyWithoutUserNestedInput
    errors?: ErrorsUpdateManyWithoutUserNestedInput
    views?: ViewsUpdateManyWithoutUserNestedInput
    coments?: CommentsUpdateManyWithoutUserNestedInput
    notifications?: NotificationsUpdateManyWithoutUserNestedInput
    wallets?: WalletsUpdateOneWithoutUserNestedInput
    unlock_volume?: Unlock_volumeUpdateManyWithoutUserNestedInput
    unlock_chapter?: Unlock_chapterUpdateManyWithoutUserNestedInput
  }

  export type UsersUncheckedUpdateWithoutUnlock_comicInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDisabled?: BoolFieldUpdateOperationsInput | boolean
    comics?: ComicsUncheckedUpdateManyWithoutUserNestedInput
    userRole?: RolesUncheckedUpdateManyWithoutUsersNestedInput
    favorites?: FavoritesUncheckedUpdateManyWithoutUserNestedInput
    rates?: RatesUncheckedUpdateManyWithoutUserNestedInput
    errors?: ErrorsUncheckedUpdateManyWithoutUserNestedInput
    views?: ViewsUncheckedUpdateManyWithoutUserNestedInput
    coments?: CommentsUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationsUncheckedUpdateManyWithoutUserNestedInput
    wallets?: WalletsUncheckedUpdateOneWithoutUserNestedInput
    unlock_volume?: Unlock_volumeUncheckedUpdateManyWithoutUserNestedInput
    unlock_chapter?: Unlock_chapterUncheckedUpdateManyWithoutUserNestedInput
  }

  export type ComicsUpsertWithoutUnlock_comicInput = {
    update: XOR<ComicsUpdateWithoutUnlock_comicInput, ComicsUncheckedUpdateWithoutUnlock_comicInput>
    create: XOR<ComicsCreateWithoutUnlock_comicInput, ComicsUncheckedCreateWithoutUnlock_comicInput>
    where?: ComicsWhereInput
  }

  export type ComicsUpdateToOneWithWhereWithoutUnlock_comicInput = {
    where?: ComicsWhereInput
    data: XOR<ComicsUpdateWithoutUnlock_comicInput, ComicsUncheckedUpdateWithoutUnlock_comicInput>
  }

  export type ComicsUpdateWithoutUnlock_comicInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    keywords?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    categories?: CategoriesUpdateManyWithoutComicsNestedInput
    authors?: AuthorsUpdateManyWithoutComicsNestedInput
    volumes?: VolumesUpdateManyWithoutComicNestedInput
    favorites?: FavoritesUpdateManyWithoutComicNestedInput
    rates?: RatesUpdateManyWithoutComicNestedInput
    views?: ViewsUpdateManyWithoutComicNestedInput
    comment?: CommentsUpdateManyWithoutComicNestedInput
    user?: UsersUpdateOneRequiredWithoutComicsNestedInput
  }

  export type ComicsUncheckedUpdateWithoutUnlock_comicInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    keywords?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: IntFieldUpdateOperationsInput | number
    categories?: CategoriesUncheckedUpdateManyWithoutComicsNestedInput
    authors?: AuthorsUncheckedUpdateManyWithoutComicsNestedInput
    volumes?: VolumesUncheckedUpdateManyWithoutComicNestedInput
    favorites?: FavoritesUncheckedUpdateManyWithoutComicNestedInput
    rates?: RatesUncheckedUpdateManyWithoutComicNestedInput
    views?: ViewsUncheckedUpdateManyWithoutComicNestedInput
    comment?: CommentsUncheckedUpdateManyWithoutComicNestedInput
  }

  export type TransactionsUpsertWithoutUnlock_comicInput = {
    update: XOR<TransactionsUpdateWithoutUnlock_comicInput, TransactionsUncheckedUpdateWithoutUnlock_comicInput>
    create: XOR<TransactionsCreateWithoutUnlock_comicInput, TransactionsUncheckedCreateWithoutUnlock_comicInput>
    where?: TransactionsWhereInput
  }

  export type TransactionsUpdateToOneWithWhereWithoutUnlock_comicInput = {
    where?: TransactionsWhereInput
    data: XOR<TransactionsUpdateWithoutUnlock_comicInput, TransactionsUncheckedUpdateWithoutUnlock_comicInput>
  }

  export type TransactionsUpdateWithoutUnlock_comicInput = {
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    description?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    wallet?: WalletsUpdateOneRequiredWithoutTransactionsNestedInput
    unlock_volume?: Unlock_volumeUpdateManyWithoutTransactionNestedInput
    unlock_chapter?: Unlock_chapterUpdateManyWithoutTransactionNestedInput
  }

  export type TransactionsUncheckedUpdateWithoutUnlock_comicInput = {
    id?: IntFieldUpdateOperationsInput | number
    walletId?: IntFieldUpdateOperationsInput | number
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    description?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    unlock_volume?: Unlock_volumeUncheckedUpdateManyWithoutTransactionNestedInput
    unlock_chapter?: Unlock_chapterUncheckedUpdateManyWithoutTransactionNestedInput
  }

  export type UsersCreateWithoutUnlock_volumeInput = {
    name: string
    email: string
    password: string
    description: string
    createdAt?: Date | string
    updatedAt?: Date | string
    isDisabled: boolean
    comics?: ComicsCreateNestedManyWithoutUserInput
    userRole?: RolesCreateNestedManyWithoutUsersInput
    favorites?: FavoritesCreateNestedManyWithoutUserInput
    rates?: RatesCreateNestedManyWithoutUserInput
    errors?: ErrorsCreateNestedManyWithoutUserInput
    views?: ViewsCreateNestedManyWithoutUserInput
    coments?: CommentsCreateNestedManyWithoutUserInput
    notifications?: NotificationsCreateNestedManyWithoutUserInput
    wallets?: WalletsCreateNestedOneWithoutUserInput
    unlock_comic?: Unlock_comicCreateNestedManyWithoutUserInput
    unlock_chapter?: Unlock_chapterCreateNestedManyWithoutUserInput
  }

  export type UsersUncheckedCreateWithoutUnlock_volumeInput = {
    id?: number
    name: string
    email: string
    password: string
    description: string
    createdAt?: Date | string
    updatedAt?: Date | string
    isDisabled: boolean
    comics?: ComicsUncheckedCreateNestedManyWithoutUserInput
    userRole?: RolesUncheckedCreateNestedManyWithoutUsersInput
    favorites?: FavoritesUncheckedCreateNestedManyWithoutUserInput
    rates?: RatesUncheckedCreateNestedManyWithoutUserInput
    errors?: ErrorsUncheckedCreateNestedManyWithoutUserInput
    views?: ViewsUncheckedCreateNestedManyWithoutUserInput
    coments?: CommentsUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationsUncheckedCreateNestedManyWithoutUserInput
    wallets?: WalletsUncheckedCreateNestedOneWithoutUserInput
    unlock_comic?: Unlock_comicUncheckedCreateNestedManyWithoutUserInput
    unlock_chapter?: Unlock_chapterUncheckedCreateNestedManyWithoutUserInput
  }

  export type UsersCreateOrConnectWithoutUnlock_volumeInput = {
    where: UsersWhereUniqueInput
    create: XOR<UsersCreateWithoutUnlock_volumeInput, UsersUncheckedCreateWithoutUnlock_volumeInput>
  }

  export type VolumesCreateWithoutUnlock_volumeInput = {
    title: string
    description: string
    price: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
    comic: ComicsCreateNestedOneWithoutVolumesInput
    chapters?: ChaptersCreateNestedManyWithoutVolumeInput
  }

  export type VolumesUncheckedCreateWithoutUnlock_volumeInput = {
    id?: number
    title: string
    description: string
    price: Decimal | DecimalJsLike | number | string
    comicId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    chapters?: ChaptersUncheckedCreateNestedManyWithoutVolumeInput
  }

  export type VolumesCreateOrConnectWithoutUnlock_volumeInput = {
    where: VolumesWhereUniqueInput
    create: XOR<VolumesCreateWithoutUnlock_volumeInput, VolumesUncheckedCreateWithoutUnlock_volumeInput>
  }

  export type TransactionsCreateWithoutUnlock_volumeInput = {
    amount: Decimal | DecimalJsLike | number | string
    description: string
    status: string
    createdAt?: Date | string
    wallet: WalletsCreateNestedOneWithoutTransactionsInput
    unlock_comic?: Unlock_comicCreateNestedManyWithoutTransactionInput
    unlock_chapter?: Unlock_chapterCreateNestedManyWithoutTransactionInput
  }

  export type TransactionsUncheckedCreateWithoutUnlock_volumeInput = {
    id?: number
    walletId: number
    amount: Decimal | DecimalJsLike | number | string
    description: string
    status: string
    createdAt?: Date | string
    unlock_comic?: Unlock_comicUncheckedCreateNestedManyWithoutTransactionInput
    unlock_chapter?: Unlock_chapterUncheckedCreateNestedManyWithoutTransactionInput
  }

  export type TransactionsCreateOrConnectWithoutUnlock_volumeInput = {
    where: TransactionsWhereUniqueInput
    create: XOR<TransactionsCreateWithoutUnlock_volumeInput, TransactionsUncheckedCreateWithoutUnlock_volumeInput>
  }

  export type UsersUpsertWithoutUnlock_volumeInput = {
    update: XOR<UsersUpdateWithoutUnlock_volumeInput, UsersUncheckedUpdateWithoutUnlock_volumeInput>
    create: XOR<UsersCreateWithoutUnlock_volumeInput, UsersUncheckedCreateWithoutUnlock_volumeInput>
    where?: UsersWhereInput
  }

  export type UsersUpdateToOneWithWhereWithoutUnlock_volumeInput = {
    where?: UsersWhereInput
    data: XOR<UsersUpdateWithoutUnlock_volumeInput, UsersUncheckedUpdateWithoutUnlock_volumeInput>
  }

  export type UsersUpdateWithoutUnlock_volumeInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDisabled?: BoolFieldUpdateOperationsInput | boolean
    comics?: ComicsUpdateManyWithoutUserNestedInput
    userRole?: RolesUpdateManyWithoutUsersNestedInput
    favorites?: FavoritesUpdateManyWithoutUserNestedInput
    rates?: RatesUpdateManyWithoutUserNestedInput
    errors?: ErrorsUpdateManyWithoutUserNestedInput
    views?: ViewsUpdateManyWithoutUserNestedInput
    coments?: CommentsUpdateManyWithoutUserNestedInput
    notifications?: NotificationsUpdateManyWithoutUserNestedInput
    wallets?: WalletsUpdateOneWithoutUserNestedInput
    unlock_comic?: Unlock_comicUpdateManyWithoutUserNestedInput
    unlock_chapter?: Unlock_chapterUpdateManyWithoutUserNestedInput
  }

  export type UsersUncheckedUpdateWithoutUnlock_volumeInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDisabled?: BoolFieldUpdateOperationsInput | boolean
    comics?: ComicsUncheckedUpdateManyWithoutUserNestedInput
    userRole?: RolesUncheckedUpdateManyWithoutUsersNestedInput
    favorites?: FavoritesUncheckedUpdateManyWithoutUserNestedInput
    rates?: RatesUncheckedUpdateManyWithoutUserNestedInput
    errors?: ErrorsUncheckedUpdateManyWithoutUserNestedInput
    views?: ViewsUncheckedUpdateManyWithoutUserNestedInput
    coments?: CommentsUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationsUncheckedUpdateManyWithoutUserNestedInput
    wallets?: WalletsUncheckedUpdateOneWithoutUserNestedInput
    unlock_comic?: Unlock_comicUncheckedUpdateManyWithoutUserNestedInput
    unlock_chapter?: Unlock_chapterUncheckedUpdateManyWithoutUserNestedInput
  }

  export type VolumesUpsertWithoutUnlock_volumeInput = {
    update: XOR<VolumesUpdateWithoutUnlock_volumeInput, VolumesUncheckedUpdateWithoutUnlock_volumeInput>
    create: XOR<VolumesCreateWithoutUnlock_volumeInput, VolumesUncheckedCreateWithoutUnlock_volumeInput>
    where?: VolumesWhereInput
  }

  export type VolumesUpdateToOneWithWhereWithoutUnlock_volumeInput = {
    where?: VolumesWhereInput
    data: XOR<VolumesUpdateWithoutUnlock_volumeInput, VolumesUncheckedUpdateWithoutUnlock_volumeInput>
  }

  export type VolumesUpdateWithoutUnlock_volumeInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    comic?: ComicsUpdateOneRequiredWithoutVolumesNestedInput
    chapters?: ChaptersUpdateManyWithoutVolumeNestedInput
  }

  export type VolumesUncheckedUpdateWithoutUnlock_volumeInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    comicId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    chapters?: ChaptersUncheckedUpdateManyWithoutVolumeNestedInput
  }

  export type TransactionsUpsertWithoutUnlock_volumeInput = {
    update: XOR<TransactionsUpdateWithoutUnlock_volumeInput, TransactionsUncheckedUpdateWithoutUnlock_volumeInput>
    create: XOR<TransactionsCreateWithoutUnlock_volumeInput, TransactionsUncheckedCreateWithoutUnlock_volumeInput>
    where?: TransactionsWhereInput
  }

  export type TransactionsUpdateToOneWithWhereWithoutUnlock_volumeInput = {
    where?: TransactionsWhereInput
    data: XOR<TransactionsUpdateWithoutUnlock_volumeInput, TransactionsUncheckedUpdateWithoutUnlock_volumeInput>
  }

  export type TransactionsUpdateWithoutUnlock_volumeInput = {
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    description?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    wallet?: WalletsUpdateOneRequiredWithoutTransactionsNestedInput
    unlock_comic?: Unlock_comicUpdateManyWithoutTransactionNestedInput
    unlock_chapter?: Unlock_chapterUpdateManyWithoutTransactionNestedInput
  }

  export type TransactionsUncheckedUpdateWithoutUnlock_volumeInput = {
    id?: IntFieldUpdateOperationsInput | number
    walletId?: IntFieldUpdateOperationsInput | number
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    description?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    unlock_comic?: Unlock_comicUncheckedUpdateManyWithoutTransactionNestedInput
    unlock_chapter?: Unlock_chapterUncheckedUpdateManyWithoutTransactionNestedInput
  }

  export type UsersCreateWithoutUnlock_chapterInput = {
    name: string
    email: string
    password: string
    description: string
    createdAt?: Date | string
    updatedAt?: Date | string
    isDisabled: boolean
    comics?: ComicsCreateNestedManyWithoutUserInput
    userRole?: RolesCreateNestedManyWithoutUsersInput
    favorites?: FavoritesCreateNestedManyWithoutUserInput
    rates?: RatesCreateNestedManyWithoutUserInput
    errors?: ErrorsCreateNestedManyWithoutUserInput
    views?: ViewsCreateNestedManyWithoutUserInput
    coments?: CommentsCreateNestedManyWithoutUserInput
    notifications?: NotificationsCreateNestedManyWithoutUserInput
    wallets?: WalletsCreateNestedOneWithoutUserInput
    unlock_comic?: Unlock_comicCreateNestedManyWithoutUserInput
    unlock_volume?: Unlock_volumeCreateNestedManyWithoutUserInput
  }

  export type UsersUncheckedCreateWithoutUnlock_chapterInput = {
    id?: number
    name: string
    email: string
    password: string
    description: string
    createdAt?: Date | string
    updatedAt?: Date | string
    isDisabled: boolean
    comics?: ComicsUncheckedCreateNestedManyWithoutUserInput
    userRole?: RolesUncheckedCreateNestedManyWithoutUsersInput
    favorites?: FavoritesUncheckedCreateNestedManyWithoutUserInput
    rates?: RatesUncheckedCreateNestedManyWithoutUserInput
    errors?: ErrorsUncheckedCreateNestedManyWithoutUserInput
    views?: ViewsUncheckedCreateNestedManyWithoutUserInput
    coments?: CommentsUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationsUncheckedCreateNestedManyWithoutUserInput
    wallets?: WalletsUncheckedCreateNestedOneWithoutUserInput
    unlock_comic?: Unlock_comicUncheckedCreateNestedManyWithoutUserInput
    unlock_volume?: Unlock_volumeUncheckedCreateNestedManyWithoutUserInput
  }

  export type UsersCreateOrConnectWithoutUnlock_chapterInput = {
    where: UsersWhereUniqueInput
    create: XOR<UsersCreateWithoutUnlock_chapterInput, UsersUncheckedCreateWithoutUnlock_chapterInput>
  }

  export type ChaptersCreateWithoutUnlock_chapterInput = {
    title: string
    filePath: string
    content: string
    price: Decimal | DecimalJsLike | number | string
    lock: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    volume: VolumesCreateNestedOneWithoutChaptersInput
    errors?: ErrorsCreateNestedManyWithoutChapterInput
    views?: ViewsCreateNestedManyWithoutChapterInput
    coments?: CommentsCreateNestedManyWithoutChapterInput
  }

  export type ChaptersUncheckedCreateWithoutUnlock_chapterInput = {
    id?: number
    title: string
    filePath: string
    content: string
    price: Decimal | DecimalJsLike | number | string
    lock: boolean
    volumeId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    errors?: ErrorsUncheckedCreateNestedManyWithoutChapterInput
    views?: ViewsUncheckedCreateNestedManyWithoutChapterInput
    coments?: CommentsUncheckedCreateNestedManyWithoutChapterInput
  }

  export type ChaptersCreateOrConnectWithoutUnlock_chapterInput = {
    where: ChaptersWhereUniqueInput
    create: XOR<ChaptersCreateWithoutUnlock_chapterInput, ChaptersUncheckedCreateWithoutUnlock_chapterInput>
  }

  export type TransactionsCreateWithoutUnlock_chapterInput = {
    amount: Decimal | DecimalJsLike | number | string
    description: string
    status: string
    createdAt?: Date | string
    wallet: WalletsCreateNestedOneWithoutTransactionsInput
    unlock_comic?: Unlock_comicCreateNestedManyWithoutTransactionInput
    unlock_volume?: Unlock_volumeCreateNestedManyWithoutTransactionInput
  }

  export type TransactionsUncheckedCreateWithoutUnlock_chapterInput = {
    id?: number
    walletId: number
    amount: Decimal | DecimalJsLike | number | string
    description: string
    status: string
    createdAt?: Date | string
    unlock_comic?: Unlock_comicUncheckedCreateNestedManyWithoutTransactionInput
    unlock_volume?: Unlock_volumeUncheckedCreateNestedManyWithoutTransactionInput
  }

  export type TransactionsCreateOrConnectWithoutUnlock_chapterInput = {
    where: TransactionsWhereUniqueInput
    create: XOR<TransactionsCreateWithoutUnlock_chapterInput, TransactionsUncheckedCreateWithoutUnlock_chapterInput>
  }

  export type UsersUpsertWithoutUnlock_chapterInput = {
    update: XOR<UsersUpdateWithoutUnlock_chapterInput, UsersUncheckedUpdateWithoutUnlock_chapterInput>
    create: XOR<UsersCreateWithoutUnlock_chapterInput, UsersUncheckedCreateWithoutUnlock_chapterInput>
    where?: UsersWhereInput
  }

  export type UsersUpdateToOneWithWhereWithoutUnlock_chapterInput = {
    where?: UsersWhereInput
    data: XOR<UsersUpdateWithoutUnlock_chapterInput, UsersUncheckedUpdateWithoutUnlock_chapterInput>
  }

  export type UsersUpdateWithoutUnlock_chapterInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDisabled?: BoolFieldUpdateOperationsInput | boolean
    comics?: ComicsUpdateManyWithoutUserNestedInput
    userRole?: RolesUpdateManyWithoutUsersNestedInput
    favorites?: FavoritesUpdateManyWithoutUserNestedInput
    rates?: RatesUpdateManyWithoutUserNestedInput
    errors?: ErrorsUpdateManyWithoutUserNestedInput
    views?: ViewsUpdateManyWithoutUserNestedInput
    coments?: CommentsUpdateManyWithoutUserNestedInput
    notifications?: NotificationsUpdateManyWithoutUserNestedInput
    wallets?: WalletsUpdateOneWithoutUserNestedInput
    unlock_comic?: Unlock_comicUpdateManyWithoutUserNestedInput
    unlock_volume?: Unlock_volumeUpdateManyWithoutUserNestedInput
  }

  export type UsersUncheckedUpdateWithoutUnlock_chapterInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDisabled?: BoolFieldUpdateOperationsInput | boolean
    comics?: ComicsUncheckedUpdateManyWithoutUserNestedInput
    userRole?: RolesUncheckedUpdateManyWithoutUsersNestedInput
    favorites?: FavoritesUncheckedUpdateManyWithoutUserNestedInput
    rates?: RatesUncheckedUpdateManyWithoutUserNestedInput
    errors?: ErrorsUncheckedUpdateManyWithoutUserNestedInput
    views?: ViewsUncheckedUpdateManyWithoutUserNestedInput
    coments?: CommentsUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationsUncheckedUpdateManyWithoutUserNestedInput
    wallets?: WalletsUncheckedUpdateOneWithoutUserNestedInput
    unlock_comic?: Unlock_comicUncheckedUpdateManyWithoutUserNestedInput
    unlock_volume?: Unlock_volumeUncheckedUpdateManyWithoutUserNestedInput
  }

  export type ChaptersUpsertWithoutUnlock_chapterInput = {
    update: XOR<ChaptersUpdateWithoutUnlock_chapterInput, ChaptersUncheckedUpdateWithoutUnlock_chapterInput>
    create: XOR<ChaptersCreateWithoutUnlock_chapterInput, ChaptersUncheckedCreateWithoutUnlock_chapterInput>
    where?: ChaptersWhereInput
  }

  export type ChaptersUpdateToOneWithWhereWithoutUnlock_chapterInput = {
    where?: ChaptersWhereInput
    data: XOR<ChaptersUpdateWithoutUnlock_chapterInput, ChaptersUncheckedUpdateWithoutUnlock_chapterInput>
  }

  export type ChaptersUpdateWithoutUnlock_chapterInput = {
    title?: StringFieldUpdateOperationsInput | string
    filePath?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    lock?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    volume?: VolumesUpdateOneRequiredWithoutChaptersNestedInput
    errors?: ErrorsUpdateManyWithoutChapterNestedInput
    views?: ViewsUpdateManyWithoutChapterNestedInput
    coments?: CommentsUpdateManyWithoutChapterNestedInput
  }

  export type ChaptersUncheckedUpdateWithoutUnlock_chapterInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    filePath?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    lock?: BoolFieldUpdateOperationsInput | boolean
    volumeId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    errors?: ErrorsUncheckedUpdateManyWithoutChapterNestedInput
    views?: ViewsUncheckedUpdateManyWithoutChapterNestedInput
    coments?: CommentsUncheckedUpdateManyWithoutChapterNestedInput
  }

  export type TransactionsUpsertWithoutUnlock_chapterInput = {
    update: XOR<TransactionsUpdateWithoutUnlock_chapterInput, TransactionsUncheckedUpdateWithoutUnlock_chapterInput>
    create: XOR<TransactionsCreateWithoutUnlock_chapterInput, TransactionsUncheckedCreateWithoutUnlock_chapterInput>
    where?: TransactionsWhereInput
  }

  export type TransactionsUpdateToOneWithWhereWithoutUnlock_chapterInput = {
    where?: TransactionsWhereInput
    data: XOR<TransactionsUpdateWithoutUnlock_chapterInput, TransactionsUncheckedUpdateWithoutUnlock_chapterInput>
  }

  export type TransactionsUpdateWithoutUnlock_chapterInput = {
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    description?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    wallet?: WalletsUpdateOneRequiredWithoutTransactionsNestedInput
    unlock_comic?: Unlock_comicUpdateManyWithoutTransactionNestedInput
    unlock_volume?: Unlock_volumeUpdateManyWithoutTransactionNestedInput
  }

  export type TransactionsUncheckedUpdateWithoutUnlock_chapterInput = {
    id?: IntFieldUpdateOperationsInput | number
    walletId?: IntFieldUpdateOperationsInput | number
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    description?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    unlock_comic?: Unlock_comicUncheckedUpdateManyWithoutTransactionNestedInput
    unlock_volume?: Unlock_volumeUncheckedUpdateManyWithoutTransactionNestedInput
  }

  export type ComicsUpdateWithoutCategoriesInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    keywords?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    authors?: AuthorsUpdateManyWithoutComicsNestedInput
    volumes?: VolumesUpdateManyWithoutComicNestedInput
    favorites?: FavoritesUpdateManyWithoutComicNestedInput
    rates?: RatesUpdateManyWithoutComicNestedInput
    views?: ViewsUpdateManyWithoutComicNestedInput
    comment?: CommentsUpdateManyWithoutComicNestedInput
    unlock_comic?: Unlock_comicUpdateManyWithoutComicNestedInput
    user?: UsersUpdateOneRequiredWithoutComicsNestedInput
  }

  export type ComicsUncheckedUpdateWithoutCategoriesInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    keywords?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: IntFieldUpdateOperationsInput | number
    authors?: AuthorsUncheckedUpdateManyWithoutComicsNestedInput
    volumes?: VolumesUncheckedUpdateManyWithoutComicNestedInput
    favorites?: FavoritesUncheckedUpdateManyWithoutComicNestedInput
    rates?: RatesUncheckedUpdateManyWithoutComicNestedInput
    views?: ViewsUncheckedUpdateManyWithoutComicNestedInput
    comment?: CommentsUncheckedUpdateManyWithoutComicNestedInput
    unlock_comic?: Unlock_comicUncheckedUpdateManyWithoutComicNestedInput
  }

  export type ComicsUncheckedUpdateManyWithoutCategoriesInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    keywords?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: IntFieldUpdateOperationsInput | number
  }

  export type ComicsUpdateWithoutAuthorsInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    keywords?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    categories?: CategoriesUpdateManyWithoutComicsNestedInput
    volumes?: VolumesUpdateManyWithoutComicNestedInput
    favorites?: FavoritesUpdateManyWithoutComicNestedInput
    rates?: RatesUpdateManyWithoutComicNestedInput
    views?: ViewsUpdateManyWithoutComicNestedInput
    comment?: CommentsUpdateManyWithoutComicNestedInput
    unlock_comic?: Unlock_comicUpdateManyWithoutComicNestedInput
    user?: UsersUpdateOneRequiredWithoutComicsNestedInput
  }

  export type ComicsUncheckedUpdateWithoutAuthorsInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    keywords?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: IntFieldUpdateOperationsInput | number
    categories?: CategoriesUncheckedUpdateManyWithoutComicsNestedInput
    volumes?: VolumesUncheckedUpdateManyWithoutComicNestedInput
    favorites?: FavoritesUncheckedUpdateManyWithoutComicNestedInput
    rates?: RatesUncheckedUpdateManyWithoutComicNestedInput
    views?: ViewsUncheckedUpdateManyWithoutComicNestedInput
    comment?: CommentsUncheckedUpdateManyWithoutComicNestedInput
    unlock_comic?: Unlock_comicUncheckedUpdateManyWithoutComicNestedInput
  }

  export type ComicsUncheckedUpdateManyWithoutAuthorsInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    keywords?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: IntFieldUpdateOperationsInput | number
  }

  export type VolumesCreateManyComicInput = {
    id?: number
    title: string
    description: string
    price: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FavoritesCreateManyComicInput = {
    userId: number
    addedAt?: Date | string
  }

  export type RatesCreateManyComicInput = {
    userId: number
    score?: number
    content: string
    createdAt?: Date | string
  }

  export type ViewsCreateManyComicInput = {
    userId: number
    chapterId: number
    lastedAt?: Date | string
  }

  export type CommentsCreateManyComicInput = {
    id?: number
    content: string
    userId: number
    chapterId?: number | null
    createdAt?: Date | string
  }

  export type Unlock_comicCreateManyComicInput = {
    userId: number
    transactionId: number
    createdAt?: Date | string
  }

  export type CategoriesUpdateWithoutComicsInput = {
    title?: StringFieldUpdateOperationsInput | string
  }

  export type CategoriesUncheckedUpdateWithoutComicsInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
  }

  export type CategoriesUncheckedUpdateManyWithoutComicsInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
  }

  export type AuthorsUpdateWithoutComicsInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    keywords?: StringFieldUpdateOperationsInput | string
  }

  export type AuthorsUncheckedUpdateWithoutComicsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    keywords?: StringFieldUpdateOperationsInput | string
  }

  export type AuthorsUncheckedUpdateManyWithoutComicsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    keywords?: StringFieldUpdateOperationsInput | string
  }

  export type VolumesUpdateWithoutComicInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    chapters?: ChaptersUpdateManyWithoutVolumeNestedInput
    unlock_volume?: Unlock_volumeUpdateManyWithoutVolumeNestedInput
  }

  export type VolumesUncheckedUpdateWithoutComicInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    chapters?: ChaptersUncheckedUpdateManyWithoutVolumeNestedInput
    unlock_volume?: Unlock_volumeUncheckedUpdateManyWithoutVolumeNestedInput
  }

  export type VolumesUncheckedUpdateManyWithoutComicInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FavoritesUpdateWithoutComicInput = {
    addedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UsersUpdateOneRequiredWithoutFavoritesNestedInput
  }

  export type FavoritesUncheckedUpdateWithoutComicInput = {
    userId?: IntFieldUpdateOperationsInput | number
    addedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FavoritesUncheckedUpdateManyWithoutComicInput = {
    userId?: IntFieldUpdateOperationsInput | number
    addedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RatesUpdateWithoutComicInput = {
    score?: FloatFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UsersUpdateOneRequiredWithoutRatesNestedInput
  }

  export type RatesUncheckedUpdateWithoutComicInput = {
    userId?: IntFieldUpdateOperationsInput | number
    score?: FloatFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RatesUncheckedUpdateManyWithoutComicInput = {
    userId?: IntFieldUpdateOperationsInput | number
    score?: FloatFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ViewsUpdateWithoutComicInput = {
    lastedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UsersUpdateOneRequiredWithoutViewsNestedInput
    chapter?: ChaptersUpdateOneRequiredWithoutViewsNestedInput
  }

  export type ViewsUncheckedUpdateWithoutComicInput = {
    userId?: IntFieldUpdateOperationsInput | number
    chapterId?: IntFieldUpdateOperationsInput | number
    lastedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ViewsUncheckedUpdateManyWithoutComicInput = {
    userId?: IntFieldUpdateOperationsInput | number
    chapterId?: IntFieldUpdateOperationsInput | number
    lastedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommentsUpdateWithoutComicInput = {
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UsersUpdateOneRequiredWithoutComentsNestedInput
    chapter?: ChaptersUpdateOneWithoutComentsNestedInput
    notification?: NotificationsUpdateManyWithoutCommentNestedInput
  }

  export type CommentsUncheckedUpdateWithoutComicInput = {
    id?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    userId?: IntFieldUpdateOperationsInput | number
    chapterId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notification?: NotificationsUncheckedUpdateManyWithoutCommentNestedInput
  }

  export type CommentsUncheckedUpdateManyWithoutComicInput = {
    id?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    userId?: IntFieldUpdateOperationsInput | number
    chapterId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type Unlock_comicUpdateWithoutComicInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UsersUpdateOneRequiredWithoutUnlock_comicNestedInput
    transaction?: TransactionsUpdateOneRequiredWithoutUnlock_comicNestedInput
  }

  export type Unlock_comicUncheckedUpdateWithoutComicInput = {
    userId?: IntFieldUpdateOperationsInput | number
    transactionId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type Unlock_comicUncheckedUpdateManyWithoutComicInput = {
    userId?: IntFieldUpdateOperationsInput | number
    transactionId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChaptersCreateManyVolumeInput = {
    id?: number
    title: string
    filePath: string
    content: string
    price: Decimal | DecimalJsLike | number | string
    lock: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type Unlock_volumeCreateManyVolumeInput = {
    userId: number
    transactionId: number
    createdAt?: Date | string
  }

  export type ChaptersUpdateWithoutVolumeInput = {
    title?: StringFieldUpdateOperationsInput | string
    filePath?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    lock?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    errors?: ErrorsUpdateManyWithoutChapterNestedInput
    views?: ViewsUpdateManyWithoutChapterNestedInput
    coments?: CommentsUpdateManyWithoutChapterNestedInput
    unlock_chapter?: Unlock_chapterUpdateManyWithoutChapterNestedInput
  }

  export type ChaptersUncheckedUpdateWithoutVolumeInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    filePath?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    lock?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    errors?: ErrorsUncheckedUpdateManyWithoutChapterNestedInput
    views?: ViewsUncheckedUpdateManyWithoutChapterNestedInput
    coments?: CommentsUncheckedUpdateManyWithoutChapterNestedInput
    unlock_chapter?: Unlock_chapterUncheckedUpdateManyWithoutChapterNestedInput
  }

  export type ChaptersUncheckedUpdateManyWithoutVolumeInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    filePath?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    lock?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type Unlock_volumeUpdateWithoutVolumeInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UsersUpdateOneRequiredWithoutUnlock_volumeNestedInput
    transaction?: TransactionsUpdateOneRequiredWithoutUnlock_volumeNestedInput
  }

  export type Unlock_volumeUncheckedUpdateWithoutVolumeInput = {
    userId?: IntFieldUpdateOperationsInput | number
    transactionId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type Unlock_volumeUncheckedUpdateManyWithoutVolumeInput = {
    userId?: IntFieldUpdateOperationsInput | number
    transactionId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ErrorsCreateManyChapterInput = {
    userId: number
    content: string
    status: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ViewsCreateManyChapterInput = {
    userId: number
    comicId: number
    lastedAt?: Date | string
  }

  export type CommentsCreateManyChapterInput = {
    id?: number
    content: string
    userId: number
    comicId: number
    createdAt?: Date | string
  }

  export type Unlock_chapterCreateManyChapterInput = {
    userId: number
    transactionId: number
    createdAt?: Date | string
  }

  export type ErrorsUpdateWithoutChapterInput = {
    content?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UsersUpdateOneRequiredWithoutErrorsNestedInput
  }

  export type ErrorsUncheckedUpdateWithoutChapterInput = {
    userId?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ErrorsUncheckedUpdateManyWithoutChapterInput = {
    userId?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ViewsUpdateWithoutChapterInput = {
    lastedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UsersUpdateOneRequiredWithoutViewsNestedInput
    comic?: ComicsUpdateOneRequiredWithoutViewsNestedInput
  }

  export type ViewsUncheckedUpdateWithoutChapterInput = {
    userId?: IntFieldUpdateOperationsInput | number
    comicId?: IntFieldUpdateOperationsInput | number
    lastedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ViewsUncheckedUpdateManyWithoutChapterInput = {
    userId?: IntFieldUpdateOperationsInput | number
    comicId?: IntFieldUpdateOperationsInput | number
    lastedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommentsUpdateWithoutChapterInput = {
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UsersUpdateOneRequiredWithoutComentsNestedInput
    comic?: ComicsUpdateOneRequiredWithoutCommentNestedInput
    notification?: NotificationsUpdateManyWithoutCommentNestedInput
  }

  export type CommentsUncheckedUpdateWithoutChapterInput = {
    id?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    userId?: IntFieldUpdateOperationsInput | number
    comicId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notification?: NotificationsUncheckedUpdateManyWithoutCommentNestedInput
  }

  export type CommentsUncheckedUpdateManyWithoutChapterInput = {
    id?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    userId?: IntFieldUpdateOperationsInput | number
    comicId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type Unlock_chapterUpdateWithoutChapterInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UsersUpdateOneRequiredWithoutUnlock_chapterNestedInput
    transaction?: TransactionsUpdateOneRequiredWithoutUnlock_chapterNestedInput
  }

  export type Unlock_chapterUncheckedUpdateWithoutChapterInput = {
    userId?: IntFieldUpdateOperationsInput | number
    transactionId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type Unlock_chapterUncheckedUpdateManyWithoutChapterInput = {
    userId?: IntFieldUpdateOperationsInput | number
    transactionId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UsersUpdateWithoutUserRoleInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDisabled?: BoolFieldUpdateOperationsInput | boolean
    comics?: ComicsUpdateManyWithoutUserNestedInput
    favorites?: FavoritesUpdateManyWithoutUserNestedInput
    rates?: RatesUpdateManyWithoutUserNestedInput
    errors?: ErrorsUpdateManyWithoutUserNestedInput
    views?: ViewsUpdateManyWithoutUserNestedInput
    coments?: CommentsUpdateManyWithoutUserNestedInput
    notifications?: NotificationsUpdateManyWithoutUserNestedInput
    wallets?: WalletsUpdateOneWithoutUserNestedInput
    unlock_comic?: Unlock_comicUpdateManyWithoutUserNestedInput
    unlock_volume?: Unlock_volumeUpdateManyWithoutUserNestedInput
    unlock_chapter?: Unlock_chapterUpdateManyWithoutUserNestedInput
  }

  export type UsersUncheckedUpdateWithoutUserRoleInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDisabled?: BoolFieldUpdateOperationsInput | boolean
    comics?: ComicsUncheckedUpdateManyWithoutUserNestedInput
    favorites?: FavoritesUncheckedUpdateManyWithoutUserNestedInput
    rates?: RatesUncheckedUpdateManyWithoutUserNestedInput
    errors?: ErrorsUncheckedUpdateManyWithoutUserNestedInput
    views?: ViewsUncheckedUpdateManyWithoutUserNestedInput
    coments?: CommentsUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationsUncheckedUpdateManyWithoutUserNestedInput
    wallets?: WalletsUncheckedUpdateOneWithoutUserNestedInput
    unlock_comic?: Unlock_comicUncheckedUpdateManyWithoutUserNestedInput
    unlock_volume?: Unlock_volumeUncheckedUpdateManyWithoutUserNestedInput
    unlock_chapter?: Unlock_chapterUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UsersUncheckedUpdateManyWithoutUserRoleInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDisabled?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ComicsCreateManyUserInput = {
    id?: number
    title: string
    description: string
    image: string
    keywords: string
    status: string
    price: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FavoritesCreateManyUserInput = {
    comicId: number
    addedAt?: Date | string
  }

  export type RatesCreateManyUserInput = {
    comicId: number
    score?: number
    content: string
    createdAt?: Date | string
  }

  export type ErrorsCreateManyUserInput = {
    chapterId: number
    content: string
    status: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ViewsCreateManyUserInput = {
    comicId: number
    chapterId: number
    lastedAt?: Date | string
  }

  export type CommentsCreateManyUserInput = {
    id?: number
    content: string
    chapterId?: number | null
    comicId: number
    createdAt?: Date | string
  }

  export type NotificationsCreateManyUserInput = {
    id?: number
    commentId?: number | null
    content: string
    isRead: boolean
    createdAt?: Date | string
  }

  export type Unlock_comicCreateManyUserInput = {
    comicId: number
    transactionId: number
    createdAt?: Date | string
  }

  export type Unlock_volumeCreateManyUserInput = {
    volumeId: number
    transactionId: number
    createdAt?: Date | string
  }

  export type Unlock_chapterCreateManyUserInput = {
    chapterId: number
    transactionId: number
    createdAt?: Date | string
  }

  export type ComicsUpdateWithoutUserInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    keywords?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    categories?: CategoriesUpdateManyWithoutComicsNestedInput
    authors?: AuthorsUpdateManyWithoutComicsNestedInput
    volumes?: VolumesUpdateManyWithoutComicNestedInput
    favorites?: FavoritesUpdateManyWithoutComicNestedInput
    rates?: RatesUpdateManyWithoutComicNestedInput
    views?: ViewsUpdateManyWithoutComicNestedInput
    comment?: CommentsUpdateManyWithoutComicNestedInput
    unlock_comic?: Unlock_comicUpdateManyWithoutComicNestedInput
  }

  export type ComicsUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    keywords?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    categories?: CategoriesUncheckedUpdateManyWithoutComicsNestedInput
    authors?: AuthorsUncheckedUpdateManyWithoutComicsNestedInput
    volumes?: VolumesUncheckedUpdateManyWithoutComicNestedInput
    favorites?: FavoritesUncheckedUpdateManyWithoutComicNestedInput
    rates?: RatesUncheckedUpdateManyWithoutComicNestedInput
    views?: ViewsUncheckedUpdateManyWithoutComicNestedInput
    comment?: CommentsUncheckedUpdateManyWithoutComicNestedInput
    unlock_comic?: Unlock_comicUncheckedUpdateManyWithoutComicNestedInput
  }

  export type ComicsUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    keywords?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RolesUpdateWithoutUsersInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
  }

  export type RolesUncheckedUpdateWithoutUsersInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
  }

  export type RolesUncheckedUpdateManyWithoutUsersInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
  }

  export type FavoritesUpdateWithoutUserInput = {
    addedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    comic?: ComicsUpdateOneRequiredWithoutFavoritesNestedInput
  }

  export type FavoritesUncheckedUpdateWithoutUserInput = {
    comicId?: IntFieldUpdateOperationsInput | number
    addedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FavoritesUncheckedUpdateManyWithoutUserInput = {
    comicId?: IntFieldUpdateOperationsInput | number
    addedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RatesUpdateWithoutUserInput = {
    score?: FloatFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    comic?: ComicsUpdateOneRequiredWithoutRatesNestedInput
  }

  export type RatesUncheckedUpdateWithoutUserInput = {
    comicId?: IntFieldUpdateOperationsInput | number
    score?: FloatFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RatesUncheckedUpdateManyWithoutUserInput = {
    comicId?: IntFieldUpdateOperationsInput | number
    score?: FloatFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ErrorsUpdateWithoutUserInput = {
    content?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    chapter?: ChaptersUpdateOneRequiredWithoutErrorsNestedInput
  }

  export type ErrorsUncheckedUpdateWithoutUserInput = {
    chapterId?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ErrorsUncheckedUpdateManyWithoutUserInput = {
    chapterId?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ViewsUpdateWithoutUserInput = {
    lastedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    comic?: ComicsUpdateOneRequiredWithoutViewsNestedInput
    chapter?: ChaptersUpdateOneRequiredWithoutViewsNestedInput
  }

  export type ViewsUncheckedUpdateWithoutUserInput = {
    comicId?: IntFieldUpdateOperationsInput | number
    chapterId?: IntFieldUpdateOperationsInput | number
    lastedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ViewsUncheckedUpdateManyWithoutUserInput = {
    comicId?: IntFieldUpdateOperationsInput | number
    chapterId?: IntFieldUpdateOperationsInput | number
    lastedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommentsUpdateWithoutUserInput = {
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    chapter?: ChaptersUpdateOneWithoutComentsNestedInput
    comic?: ComicsUpdateOneRequiredWithoutCommentNestedInput
    notification?: NotificationsUpdateManyWithoutCommentNestedInput
  }

  export type CommentsUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    chapterId?: NullableIntFieldUpdateOperationsInput | number | null
    comicId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notification?: NotificationsUncheckedUpdateManyWithoutCommentNestedInput
  }

  export type CommentsUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    chapterId?: NullableIntFieldUpdateOperationsInput | number | null
    comicId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationsUpdateWithoutUserInput = {
    content?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    comment?: CommentsUpdateOneWithoutNotificationNestedInput
  }

  export type NotificationsUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    commentId?: NullableIntFieldUpdateOperationsInput | number | null
    content?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationsUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    commentId?: NullableIntFieldUpdateOperationsInput | number | null
    content?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type Unlock_comicUpdateWithoutUserInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    comic?: ComicsUpdateOneRequiredWithoutUnlock_comicNestedInput
    transaction?: TransactionsUpdateOneRequiredWithoutUnlock_comicNestedInput
  }

  export type Unlock_comicUncheckedUpdateWithoutUserInput = {
    comicId?: IntFieldUpdateOperationsInput | number
    transactionId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type Unlock_comicUncheckedUpdateManyWithoutUserInput = {
    comicId?: IntFieldUpdateOperationsInput | number
    transactionId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type Unlock_volumeUpdateWithoutUserInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    volume?: VolumesUpdateOneRequiredWithoutUnlock_volumeNestedInput
    transaction?: TransactionsUpdateOneRequiredWithoutUnlock_volumeNestedInput
  }

  export type Unlock_volumeUncheckedUpdateWithoutUserInput = {
    volumeId?: IntFieldUpdateOperationsInput | number
    transactionId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type Unlock_volumeUncheckedUpdateManyWithoutUserInput = {
    volumeId?: IntFieldUpdateOperationsInput | number
    transactionId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type Unlock_chapterUpdateWithoutUserInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    chapter?: ChaptersUpdateOneRequiredWithoutUnlock_chapterNestedInput
    transaction?: TransactionsUpdateOneRequiredWithoutUnlock_chapterNestedInput
  }

  export type Unlock_chapterUncheckedUpdateWithoutUserInput = {
    chapterId?: IntFieldUpdateOperationsInput | number
    transactionId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type Unlock_chapterUncheckedUpdateManyWithoutUserInput = {
    chapterId?: IntFieldUpdateOperationsInput | number
    transactionId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationsCreateManyCommentInput = {
    id?: number
    userId: number
    content: string
    isRead: boolean
    createdAt?: Date | string
  }

  export type NotificationsUpdateWithoutCommentInput = {
    content?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UsersUpdateOneRequiredWithoutNotificationsNestedInput
  }

  export type NotificationsUncheckedUpdateWithoutCommentInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationsUncheckedUpdateManyWithoutCommentInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransactionsCreateManyWalletInput = {
    id?: number
    amount: Decimal | DecimalJsLike | number | string
    description: string
    status: string
    createdAt?: Date | string
  }

  export type TransactionsUpdateWithoutWalletInput = {
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    description?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    unlock_comic?: Unlock_comicUpdateManyWithoutTransactionNestedInput
    unlock_volume?: Unlock_volumeUpdateManyWithoutTransactionNestedInput
    unlock_chapter?: Unlock_chapterUpdateManyWithoutTransactionNestedInput
  }

  export type TransactionsUncheckedUpdateWithoutWalletInput = {
    id?: IntFieldUpdateOperationsInput | number
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    description?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    unlock_comic?: Unlock_comicUncheckedUpdateManyWithoutTransactionNestedInput
    unlock_volume?: Unlock_volumeUncheckedUpdateManyWithoutTransactionNestedInput
    unlock_chapter?: Unlock_chapterUncheckedUpdateManyWithoutTransactionNestedInput
  }

  export type TransactionsUncheckedUpdateManyWithoutWalletInput = {
    id?: IntFieldUpdateOperationsInput | number
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    description?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type Unlock_comicCreateManyTransactionInput = {
    userId: number
    comicId: number
    createdAt?: Date | string
  }

  export type Unlock_volumeCreateManyTransactionInput = {
    userId: number
    volumeId: number
    createdAt?: Date | string
  }

  export type Unlock_chapterCreateManyTransactionInput = {
    userId: number
    chapterId: number
    createdAt?: Date | string
  }

  export type Unlock_comicUpdateWithoutTransactionInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UsersUpdateOneRequiredWithoutUnlock_comicNestedInput
    comic?: ComicsUpdateOneRequiredWithoutUnlock_comicNestedInput
  }

  export type Unlock_comicUncheckedUpdateWithoutTransactionInput = {
    userId?: IntFieldUpdateOperationsInput | number
    comicId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type Unlock_comicUncheckedUpdateManyWithoutTransactionInput = {
    userId?: IntFieldUpdateOperationsInput | number
    comicId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type Unlock_volumeUpdateWithoutTransactionInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UsersUpdateOneRequiredWithoutUnlock_volumeNestedInput
    volume?: VolumesUpdateOneRequiredWithoutUnlock_volumeNestedInput
  }

  export type Unlock_volumeUncheckedUpdateWithoutTransactionInput = {
    userId?: IntFieldUpdateOperationsInput | number
    volumeId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type Unlock_volumeUncheckedUpdateManyWithoutTransactionInput = {
    userId?: IntFieldUpdateOperationsInput | number
    volumeId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type Unlock_chapterUpdateWithoutTransactionInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UsersUpdateOneRequiredWithoutUnlock_chapterNestedInput
    chapter?: ChaptersUpdateOneRequiredWithoutUnlock_chapterNestedInput
  }

  export type Unlock_chapterUncheckedUpdateWithoutTransactionInput = {
    userId?: IntFieldUpdateOperationsInput | number
    chapterId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type Unlock_chapterUncheckedUpdateManyWithoutTransactionInput = {
    userId?: IntFieldUpdateOperationsInput | number
    chapterId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}